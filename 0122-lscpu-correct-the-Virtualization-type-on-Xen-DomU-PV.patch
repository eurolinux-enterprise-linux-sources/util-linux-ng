From f67aec63e783ba71838c2fcd2a497ce1aad12a37 Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang@oracle.com>
Date: Tue, 22 Mar 2016 13:38:14 +0800
Subject: [PATCH 122/127] lscpu: correct the Virtualization type on Xen DomU PV
 guest

Nowadays, most Intel CPUs have "cpuid faulting" available which could trap
the execution of "cpuid" instruction when CPL>0  with GP fault. Thus,
"cpuid" instruction could trap to Xen hypervisor on the paravirtualized PV
guest on most servers today, except on old CPUs prior to 2011. On CPU after
2011, Xen will put "XenVMMXenVMM" on both HVM and PV guests, which could
have lscpu command erroneously classify the guest as type "full".  The
current lscpu command, which is based on "cpuid" instruction, still assumes
that it will not cause the trap to Xen hypervisor on Xen PV guest and uses
/proc/xen to identify whether it's running on PV DomU or not.  To identify
this kind of information under the help of
/sys/hypervisor/properties/features would be more accurate for the CPU
nowadays. The bit 5 (XENFEAT_mmu_pt_update_preserve_ad) of the features
will be set only when it's running on Xen PV domain. The combo of bit 3 and
8 (XENFEAT_supervisor_mode_kernel and XENFEAT_hvm_callback_vector) will be
set simultaneously only when it's running on Xen PVH domain.

Upstream: https://git.kernel.org/cgit/utils/util-linux/util-linux.git/commit/?id=0ebbe9f1048e1c7ef7d74034bd3b092fd0ef4d3e
Upstream: https://git.kernel.org/cgit/utils/util-linux/util-linux.git/commit/?id=b4d1fbda1efdc6444f79c5e15e4ec6c74bbb5601
Addresses: https://bugzilla.redhat.com/show_bug.cgi?id=1320360
Signed-off-by: Dongli Zhang <dongli.zhang@oracle.com>
Signed-off-by: Karel Zak <kzak@redhat.com>
---
 sys-utils/lscpu.c | 36 ++++++++++++++++++++++++++++++++----
 1 file changed, 32 insertions(+), 4 deletions(-)

diff --git a/sys-utils/lscpu.c b/sys-utils/lscpu.c
index f81bb33..bb2f531 100644
--- a/sys-utils/lscpu.c
+++ b/sys-utils/lscpu.c
@@ -47,6 +47,7 @@
 
 /* /sys paths */
 #define _PATH_SYS_SYSTEM	"/sys/devices/system"
+#define _PATH_SYS_HYP_FEATURES "/sys/hypervisor/properties/features"
 #define _PATH_SYS_CPU		_PATH_SYS_SYSTEM "/cpu"
 #define _PATH_SYS_NODE		_PATH_SYS_SYSTEM "/node"
 #define _PATH_PROC_XEN		"/proc/xen"
@@ -55,6 +56,15 @@
 #define _PATH_PROC_PCIDEVS	"/proc/bus/pci/devices"
 #define _PATH_PROC_SYSINFO	"/proc/sysinfo"
 
+/* Xen Domain feature flag used for /sys/hypervisor/properties/features */
+#define XENFEAT_supervisor_mode_kernel		3
+#define XENFEAT_mmu_pt_update_preserve_ad	5
+#define XENFEAT_hvm_callback_vector			8
+
+#define XEN_FEATURES_PV_MASK	(1U << XENFEAT_mmu_pt_update_preserve_ad)
+#define XEN_FEATURES_PVH_MASK	( (1U << XENFEAT_supervisor_mode_kernel) \
+								| (1U << XENFEAT_hvm_callback_vector) )
+
 /* virtualization types */
 enum {
 	VIRT_NONE	= 0,
@@ -533,12 +543,30 @@ read_hypervisor(struct lscpu_desc *desc, struct lscpu_modifier *mod)
 	if (mod->system != SYSTEM_SNAPSHOT)
 		read_hypervisor_cpuid(desc);
 
-	if (desc->hyper)
-		/* hvm */
+	if (desc->hyper) {
 		desc->virtype = VIRT_FULL;
 
-	else if (path_exist(_PATH_PROC_XEN)) {
-		/* Xen para-virt or dom0 */
+		if (desc->hyper == HYPER_XEN) {
+			uint32_t features;
+
+			FILE *fd = path_fopen("r", 0, _PATH_SYS_HYP_FEATURES);
+			if (fd && fscanf(fd, "%x", &features) == 1) {
+				/* Xen PV domain */
+				if (features & XEN_FEATURES_PV_MASK)
+					desc->virtype = VIRT_PARA;
+				/* Xen PVH domain */
+				else if ((features & XEN_FEATURES_PVH_MASK)
+								== XEN_FEATURES_PVH_MASK)
+					desc->virtype = VIRT_PARA;
+				fclose(fd);
+			} else {
+				err(EXIT_FAILURE, _("failed to read from: %s"),
+						_PATH_SYS_HYP_FEATURES);
+			}
+		}
+
+	/* Xen para-virt or dom0 */
+	} else if (path_exist(_PATH_PROC_XEN)) {
 		FILE *fd = path_fopen("r", 0, _PATH_PROC_XENCAP);
 		int dom0 = 0;
 
-- 
2.7.4

