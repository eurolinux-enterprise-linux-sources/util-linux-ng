From 534fd9d9f9fa589a125b4dcdf2077f001b1736d0 Mon Sep 17 00:00:00 2001
From: Karel Zak <kzak@redhat.com>
Date: Fri, 13 Jun 2014 12:05:40 +0200
Subject: [PATCH] nsenter: backport fromupstream

---
 sys-utils/Makefile.am |    6 +
 sys-utils/nsenter.1   |  146 +++++++++++++++++++++++
 sys-utils/nsenter.c   |  311 +++++++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 463 insertions(+), 0 deletions(-)
 create mode 100644 sys-utils/nsenter.1
 create mode 100644 sys-utils/nsenter.c

diff --git a/sys-utils/Makefile.am b/sys-utils/Makefile.am
index 8ce9235..142e934 100644
--- a/sys-utils/Makefile.am
+++ b/sys-utils/Makefile.am
@@ -62,6 +62,12 @@ usrbin_exec_PROGRAMS += unshare
 unshare_SOURCES = unshare.c \
 	$(top_srcdir)/lib/exec_shell.c
 dist_man_MANS += unshare.1
+
+usrbin_exec_PROGRAMS += nsenter
+nsenter_SOURCES = nsenter.c \
+	$(top_srcdir)/lib/exec_shell.c \
+	$(top_srcdir)/lib/strutils.c
+dist_man_MANS += nsenter.1
 endif
 
 if BUILD_ARCH
diff --git a/sys-utils/nsenter.1 b/sys-utils/nsenter.1
new file mode 100644
index 0000000..21cc2e5
--- /dev/null
+++ b/sys-utils/nsenter.1
@@ -0,0 +1,146 @@
+.TH NSENTER 1 "June 2013" "util-linux" "User Commands"
+.SH NAME
+nsenter \- run program with namespaces of other processes
+.SH SYNOPSIS
+.B nsenter
+.RI [ options ]
+.RI [ program
+.RI [ arguments ]]
+.SH DESCRIPTION
+Enters the namespaces of one or more other processes and then executes the specified
+program.  Enterable namespaces are:
+.TP
+.B mount namespace
+Mounting and unmounting filesystems will not affect the rest of the system
+.RB ( CLONE_\:NEWNS
+flag), except for filesystems which are explicitly marked as shared (with
+\fBmount --make-\:shared\fP; see \fI/proc\:/self\:/mountinfo\fP for the
+\fBshared\fP flag).
+.TP
+.B UTS namespace
+Setting hostname or domainname will not affect the rest of the system.
+.RB ( CLONE_\:NEWUTS
+flag)
+.TP
+.B IPC namespace
+The process will have an independent namespace for System V message queues,
+semaphore sets and shared memory segments.
+.RB ( CLONE_\:NEWIPC
+flag)
+.TP
+.B network namespace
+The process will have independent IPv4 and IPv6 stacks, IP routing tables,
+firewall rules, the
+.I /proc\:/net
+and
+.I /sys\:/class\:/net
+directory trees, sockets, etc.
+.RB ( CLONE_\:NEWNET
+flag)
+.TP
+.B PID namespace
+Children will have a set of PID to process mappings separate from the
+.B nsenter
+process
+.RB ( CLONE_\:NEWPID
+flag).
+.B nsenter
+will fork by default if changing the PID namespace, so that the new program
+and its children share the same PID namespace and are visible to each other.
+If \fB\-\-no\-fork\fP is used, the new program will be exec'ed without forking.
+.TP
+See \fBclone\fP(2) for the exact semantics of the flags.
+.TP
+If \fIprogram\fP is not given, then ``${SHELL}'' is run (default: /bin\:/sh).
+
+.SH OPTIONS
+.TP
+\fB\-t\fR, \fB\-\-target\fR \fIpid\fP
+Specify a target process to get contexts from.  The paths to the contexts
+specified by
+.I pid
+are:
+.RS
+.PD 0
+.IP "" 20
+.TP
+/proc/\fIpid\fR/ns/mnt
+the mount namespace
+.TP
+/proc/\fIpid\fR/ns/uts
+the UTS namespace
+.TP
+/proc/\fIpid\fR/ns/ipc
+the IPC namespace
+.TP
+/proc/\fIpid\fR/ns/net
+the network namespace
+.TP
+/proc/\fIpid\fR/ns/pid
+the PID namespace
+.TP
+/proc/\fIpid\fR/root
+the root directory
+.TP
+/proc/\fIpid\fR/cwd
+the working directory respectively
+.PD
+.RE
+.TP
+\fB\-m\fR, \fB\-\-mount\fR[=\fIfile\fR]
+Enter the mount namespace.  If no file is specified, enter the mount namespace
+of the target process.  If file is specified, enter the mount namespace
+specified by file.
+.TP
+\fB\-u\fR, \fB\-\-uts\fR[=\fIfile\fR]
+Enter the UTS namespace.  If no file is specified, enter the UTS namespace of
+the target process.  If file is specified, enter the UTS namespace specified by
+file.
+.TP
+\fB\-i\fR, \fB\-\-ipc\fR[=\fIfile\fR]
+Enter the IPC namespace.  If no file is specified, enter the IPC namespace of
+the target process.  If file is specified, enter the IPC namespace specified by
+file.
+.TP
+\fB\-n\fR, \fB\-\-net\fR[=\fIfile\fR]
+Enter the network namespace.  If no file is specified, enter the network
+namespace of the target process.  If file is specified, enter the network
+namespace specified by file.
+.TP
+\fB\-p\fR, \fB\-\-pid\fR[=\fIfile\fR]
+Enter the PID namespace.  If no file is specified, enter the PID namespace of
+the target process.  If file is specified, enter the PID namespace specified by
+file.
+.TP
+\fB\-r\fR, \fB\-\-root\fR[=\fIdirectory\fR]
+Set the root directory.  If no directory is specified, set the root directory to
+the root directory of the target process.  If directory is specified, set the
+root directory to the specified directory.
+.TP
+\fB\-w\fR, \fB\-\-wd\fR[=\fIdirectory\fR]
+Set the working directory.  If no directory is specified, set the working
+directory to the working directory of the target process.  If directory is
+specified, set the working directory to the specified directory.
+.TP
+\fB\-F\fR, \fB\-\-no-fork\fR
+Do not fork before exec'ing the specified program.  By default, when entering a
+PID namespace, \fBnsenter\fP calls \fBfork\fP before calling \fBexec\fP so that
+any children will also be in the newly entered PID namespace.
+.TP
+\fB\-V\fR, \fB\-\-version\fR
+Display version information and exit.
+.TP
+\fB\-h\fR, \fB\-\-help\fR
+Display help text and exit.
+.SH SEE ALSO
+.BR setns (2),
+.BR clone (2)
+.SH AUTHOR
+.MT ebiederm@xmission.com
+Eric Biederman
+.ME
+.SH AVAILABILITY
+The nsenter command is part of the util-linux package and is available from
+.UR ftp://\:ftp.kernel.org\:/pub\:/linux\:/utils\:/util-linux/
+Linux Kernel Archive
+.UE .
diff --git a/sys-utils/nsenter.c b/sys-utils/nsenter.c
new file mode 100644
index 0000000..8bff22b
--- /dev/null
+++ b/sys-utils/nsenter.c
@@ -0,0 +1,311 @@
+/*
+ * nsenter(1) - command-line interface for setns(2)
+ *
+ * Copyright (C) 2012-2013 Eric Biederman <ebiederm@xmission.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; version 2.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <dirent.h>
+#include <errno.h>
+#include <getopt.h>
+#include <sched.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <unistd.h>
+#include <assert.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <err.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+
+#include "strutils.h"
+#include "nls.h"
+#include "c.h"
+#include "namespace.h"
+#include "exec_shell.h"
+
+static struct namespace_file {
+	int nstype;
+	const char *name;
+	int fd;
+} namespace_files[] = {
+	{ .nstype = CLONE_NEWIPC,  .name = "ns/ipc",  .fd = -1 },
+	{ .nstype = CLONE_NEWUTS,  .name = "ns/uts",  .fd = -1 },
+	{ .nstype = CLONE_NEWNET,  .name = "ns/net",  .fd = -1 },
+	{ .nstype = CLONE_NEWPID,  .name = "ns/pid",  .fd = -1 },
+	{ .nstype = CLONE_NEWNS,   .name = "ns/mnt",  .fd = -1 },
+	{ .nstype = 0, .name = NULL, .fd = -1 }
+};
+
+static void usage(int status)
+{
+	FILE *out = status == EXIT_SUCCESS ? stdout : stderr;
+
+	fputs(USAGE_HEADER, out);
+	fprintf(out, _(" %s [options] <program> [args...]\n"),
+		program_invocation_short_name);
+
+	fputs(USAGE_OPTIONS, out);
+	fputs(_(" -t, --target <pid>     target process to get namespaces from\n"), out);
+	fputs(_(" -m, --mount [=<file>]  enter mount namespace\n"), out);
+	fputs(_(" -u, --uts   [=<file>]  enter UTS namespace (hostname etc)\n"), out);
+	fputs(_(" -i, --ipc   [=<file>]  enter System V IPC namespace\n"), out);
+	fputs(_(" -n, --net   [=<file>]  enter network namespace\n"), out);
+	fputs(_(" -p, --pid   [=<file>]  enter pid namespace\n"), out);
+	fputs(_(" -r, --root  [=<dir>]   set the root directory\n"), out);
+	fputs(_(" -w, --wd    [=<dir>]   set the working directory\n"), out);
+	fputs(_(" -F, --no-fork          do not fork before exec'ing <program>\n"), out);
+
+	fputs(USAGE_SEPARATOR, out);
+	fputs(USAGE_HELP, out);
+	fputs(USAGE_VERSION, out);
+	fprintf(out, USAGE_MAN_TAIL("nsenter(1)"));
+
+	exit(status);
+}
+
+static pid_t namespace_target_pid = 0;
+static int root_fd = -1;
+static int wd_fd = -1;
+
+static void open_target_fd(int *fd, const char *type, const char *path)
+{
+	char pathbuf[PATH_MAX];
+
+	if (!path && namespace_target_pid) {
+		snprintf(pathbuf, sizeof(pathbuf), "/proc/%u/%s",
+			 namespace_target_pid, type);
+		path = pathbuf;
+	}
+	if (!path)
+		errx(EXIT_FAILURE,
+		     _("neither filename nor target pid supplied for %s"),
+		     type);
+
+	if (*fd >= 0)
+		close(*fd);
+
+	*fd = open(path, O_RDONLY);
+	if (*fd < 0)
+		err(EXIT_FAILURE, _("cannot open %s"), path);
+}
+
+static void open_namespace_fd(int nstype, const char *path)
+{
+	struct namespace_file *nsfile;
+
+	for (nsfile = namespace_files; nsfile->nstype; nsfile++) {
+		if (nstype != nsfile->nstype)
+			continue;
+
+		open_target_fd(&nsfile->fd, nsfile->name, path);
+		return;
+	}
+	/* This should never happen */
+	assert(nsfile->nstype);
+}
+
+static void continue_as_child(void)
+{
+	pid_t child = fork();
+	int status;
+	pid_t ret;
+
+	if (child < 0)
+		err(EXIT_FAILURE, _("fork failed"));
+
+	/* Only the child returns */
+	if (child == 0)
+		return;
+
+	for (;;) {
+		ret = waitpid(child, &status, WUNTRACED);
+		if ((ret == child) && (WIFSTOPPED(status))) {
+			/* The child suspended so suspend us as well */
+			kill(getpid(), SIGSTOP);
+			kill(child, SIGCONT);
+		} else {
+			break;
+		}
+	}
+	/* Return the child's exit code if possible */
+	if (WIFEXITED(status)) {
+		exit(WEXITSTATUS(status));
+	} else if (WIFSIGNALED(status)) {
+		kill(getpid(), WTERMSIG(status));
+	}
+	exit(EXIT_FAILURE);
+}
+
+int main(int argc, char *argv[])
+{
+	static const struct option longopts[] = {
+		{ "help", no_argument, NULL, 'h' },
+		{ "version", no_argument, NULL, 'V'},
+		{ "target", required_argument, NULL, 't' },
+		{ "mount", optional_argument, NULL, 'm' },
+		{ "uts", optional_argument, NULL, 'u' },
+		{ "ipc", optional_argument, NULL, 'i' },
+		{ "net", optional_argument, NULL, 'n' },
+		{ "pid", optional_argument, NULL, 'p' },
+		{ "root", optional_argument, NULL, 'r' },
+		{ "wd", optional_argument, NULL, 'w' },
+		{ "no-fork", no_argument, NULL, 'F' },
+		{ NULL, 0, NULL, 0 }
+	};
+
+	struct namespace_file *nsfile;
+	int c, namespaces = 0;
+	bool do_rd = false, do_wd = false;
+	int do_fork = -1; /* unknown yet */
+	uid_t uid = 0;
+	gid_t gid = 0;
+
+	setlocale(LC_ALL, "");
+	bindtextdomain(PACKAGE, LOCALEDIR);
+	textdomain(PACKAGE);
+
+	while ((c =
+		getopt_long(argc, argv, "+hVt:m::u::i::n::p::r::w::F",
+			    longopts, NULL)) != -1) {
+		switch (c) {
+		case 'h':
+			usage(EXIT_SUCCESS);
+		case 'V':
+			printf(UTIL_LINUX_VERSION);
+			return EXIT_SUCCESS;
+		case 't':
+			namespace_target_pid =
+			    strtoul_or_err(optarg, _("failed to parse pid"));
+			break;
+		case 'm':
+			if (optarg)
+				open_namespace_fd(CLONE_NEWNS, optarg);
+			else
+				namespaces |= CLONE_NEWNS;
+			break;
+		case 'u':
+			if (optarg)
+				open_namespace_fd(CLONE_NEWUTS, optarg);
+			else
+				namespaces |= CLONE_NEWUTS;
+			break;
+		case 'i':
+			if (optarg)
+				open_namespace_fd(CLONE_NEWIPC, optarg);
+			else
+				namespaces |= CLONE_NEWIPC;
+			break;
+		case 'n':
+			if (optarg)
+				open_namespace_fd(CLONE_NEWNET, optarg);
+			else
+				namespaces |= CLONE_NEWNET;
+			break;
+		case 'p':
+			if (optarg)
+				open_namespace_fd(CLONE_NEWPID, optarg);
+			else
+				namespaces |= CLONE_NEWPID;
+			break;
+		case 'F':
+			do_fork = 0;
+			break;
+		case 'r':
+			if (optarg)
+				open_target_fd(&root_fd, "root", optarg);
+			else
+				do_rd = true;
+			break;
+		case 'w':
+			if (optarg)
+				open_target_fd(&wd_fd, "cwd", optarg);
+			else
+				do_wd = true;
+			break;
+		default:
+			usage(EXIT_FAILURE);
+		}
+	}
+
+	/*
+	 * Open remaining namespace and directory descriptors.
+	 */
+	for (nsfile = namespace_files; nsfile->nstype; nsfile++)
+		if (nsfile->nstype & namespaces)
+			open_namespace_fd(nsfile->nstype, NULL);
+	if (do_rd)
+		open_target_fd(&root_fd, "root", NULL);
+	if (do_wd)
+		open_target_fd(&wd_fd, "cwd", NULL);
+
+	/*
+	 * Now that we know which namespaces we want to enter, enter them.
+	 */
+	for (nsfile = namespace_files; nsfile->nstype; nsfile++) {
+		if (nsfile->fd < 0)
+			continue;
+		if (nsfile->nstype == CLONE_NEWPID && do_fork == -1)
+			do_fork = 1;
+		if (setns(nsfile->fd, nsfile->nstype))
+			err(EXIT_FAILURE,
+			    _("reassociate to namespace '%s' failed"),
+			    nsfile->name);
+		close(nsfile->fd);
+		nsfile->fd = -1;
+	}
+
+	/* Remember the current working directory if I'm not changing it */
+	if (root_fd >= 0 && wd_fd < 0) {
+		wd_fd = open(".", O_RDONLY);
+		if (wd_fd < 0)
+			err(EXIT_FAILURE,
+			    _("cannot open current working directory"));
+	}
+
+	/* Change the root directory */
+	if (root_fd >= 0) {
+		if (fchdir(root_fd) < 0)
+			err(EXIT_FAILURE,
+			    _("change directory by root file descriptor failed"));
+
+		if (chroot(".") < 0)
+			err(EXIT_FAILURE, _("chroot failed"));
+
+		close(root_fd);
+		root_fd = -1;
+	}
+
+	/* Change the working directory */
+	if (wd_fd >= 0) {
+		if (fchdir(wd_fd) < 0)
+			err(EXIT_FAILURE,
+			    _("change directory by working directory file descriptor failed"));
+
+		close(wd_fd);
+		wd_fd = -1;
+	}
+
+	if (do_fork == 1)
+		continue_as_child();
+
+	if (optind < argc) {
+		execvp(argv[optind], argv + optind);
+		err(EXIT_FAILURE, _("failed to execute %s"), argv[optind]);
+	}
+	exec_shell();
+}
-- 
1.7.1

