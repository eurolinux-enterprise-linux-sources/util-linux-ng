diff -up util-linux-ng-2.17.2/configure.ac.base util-linux-ng-2.17.2/configure.ac
--- util-linux-ng-2.17.2/configure.ac.base	2010-03-22 10:08:00.000000000 +0100
+++ util-linux-ng-2.17.2/configure.ac	2012-10-08 12:03:34.857028208 +0200
@@ -170,6 +170,9 @@ AC_CHECK_FUNCS(
 	jrand48 \
 	lchown \
 	llseek \
+	strndup \
+	strnlen \
+	strnchr \
 	lseek64 \
 	strtoull \
 	sysconf \
diff -up util-linux-ng-2.17.2/include/all-io.h.base util-linux-ng-2.17.2/include/all-io.h
--- util-linux-ng-2.17.2/include/all-io.h.base	2012-10-08 12:03:34.857028208 +0200
+++ util-linux-ng-2.17.2/include/all-io.h	2012-10-08 12:03:34.857028208 +0200
@@ -0,0 +1,72 @@
+#ifndef UTIL_LINUX_ALL_IO_H
+#define UTIL_LINUX_ALL_IO_H
+
+#include <string.h>
+#include <unistd.h>
+#include <errno.h>
+
+static inline int write_all(int fd, const void *buf, size_t count)
+{
+	while (count) {
+		ssize_t tmp;
+
+		errno = 0;
+		tmp = write(fd, buf, count);
+		if (tmp > 0) {
+			count -= tmp;
+			if (count)
+				buf = (void *) ((char *) buf + tmp);
+		} else if (errno != EINTR && errno != EAGAIN)
+			return -1;
+		if (errno == EAGAIN)	/* Try later, *sigh* */
+			usleep(10000);
+	}
+	return 0;
+}
+
+static inline int fwrite_all(const void *ptr, size_t size,
+			     size_t nmemb, FILE *stream)
+{
+	while (nmemb) {
+		size_t tmp;
+
+		errno = 0;
+		tmp = fwrite(ptr, size, nmemb, stream);
+		if (tmp > 0) {
+			nmemb -= tmp;
+			if (nmemb)
+				ptr = (void *) ((char *) ptr + (tmp * size));
+		} else if (errno != EINTR && errno != EAGAIN)
+			return -1;
+		if (errno == EAGAIN)	/* Try later, *sigh* */
+			usleep(10000);
+	}
+	return 0;
+}
+
+static inline ssize_t read_all(int fd, char *buf, size_t count)
+{
+	ssize_t ret;
+	ssize_t c = 0;
+	int tries = 0;
+
+	memset(buf, 0, count);
+	while (count > 0) {
+		ret = read(fd, buf, count);
+		if (ret <= 0) {
+			if ((errno == EAGAIN || errno == EINTR || ret == 0) &&
+			    (tries++ < 5))
+				continue;
+			return c ? c : -1;
+		}
+		if (ret > 0)
+			tries = 0;
+		count -= ret;
+		buf += ret;
+		c += ret;
+	}
+	return c;
+}
+
+
+#endif /* UTIL_LINUX_ALL_IO_H */
diff -up util-linux-ng-2.17.2/include/at.h.base util-linux-ng-2.17.2/include/at.h
--- util-linux-ng-2.17.2/include/at.h.base	2012-10-08 12:03:34.857028208 +0200
+++ util-linux-ng-2.17.2/include/at.h	2012-10-08 12:03:34.857028208 +0200
@@ -0,0 +1,32 @@
+/*
+ * wrappers for "at" functions.
+ *
+ * Copyright (C) 2010 Karel Zak <kzak@redhat.com>
+ *
+ * This file may be redistributed under the terms of the
+ * GNU Lesser General Public License.
+ */
+#ifndef UTIL_LINUX_AT_H
+#define UTIL_LINUX_AT_H
+
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+
+#include "c.h"
+
+extern int fstat_at(int dir, const char *dirname,
+			const char *filename, struct stat *st, int nofollow);
+
+extern int open_at(int dir, const char *dirname,
+			const char *filename, int flags);
+
+extern FILE *fopen_at(int dir, const char *dirname, const char *filename,
+			int flags, const char *mode);
+
+extern ssize_t readlink_at(int dir, const char *dirname, const char *pathname,
+                    char *buf, size_t bufsiz);
+
+
+#endif /* UTIL_LINUX_AT_H */
diff -up util-linux-ng-2.17.2/include/c.h.base util-linux-ng-2.17.2/include/c.h
--- util-linux-ng-2.17.2/include/c.h.base	2010-03-22 09:18:51.000000000 +0100
+++ util-linux-ng-2.17.2/include/c.h	2012-10-08 12:03:34.857028208 +0200
@@ -62,4 +62,19 @@
 	_max1 > _max2 ? _max1 : _max2; })
 #endif
 
+
+/*
+ * Constant strings for usage() functions. For more info see
+ * Documentation/howto-usage-function.txt and sys-utils/arch.c
+ */
+#define USAGE_HEADER     _("\nUsage:\n")
+#define USAGE_OPTIONS    _("\nOptions:\n")
+#define USAGE_SEPARATOR  _("\n")
+#define USAGE_HELP       _(" -h, --help     display this help and exit\n")
+#define USAGE_VERSION    _(" -V, --version  output version information and exit\n")
+#define USAGE_MAN_TAIL(_man)   _("\nFor more details see %s.\n"), _man
+
+#define UTIL_LINUX_VERSION _("%s from %s\n"), program_invocation_short_name, PACKAGE_STRING
+
+
 #endif /* UTIL_LINUX_C_H */
diff -up util-linux-ng-2.17.2/include/list.h.base util-linux-ng-2.17.2/include/list.h
--- util-linux-ng-2.17.2/include/list.h.base	2012-10-08 12:03:34.857028208 +0200
+++ util-linux-ng-2.17.2/include/list.h	2012-10-08 12:03:34.857028208 +0200
@@ -0,0 +1,333 @@
+/*
+ * Copyright (C) 2008 Karel Zak <kzak@redhat.com>
+ * Copyright (C) 1999-2008 by Theodore Ts'o
+ *
+ * (based on list.h from e2fsprogs)
+ * Merge sort based on kernel's implementation.
+ */
+
+#ifndef UTIL_LINUX_LIST_H
+#define UTIL_LINUX_LIST_H
+
+/* TODO: use AC_C_INLINE */
+#ifdef __GNUC__
+#define _INLINE_ static __inline__
+#else                         /* For Watcom C */
+#define _INLINE_ static inline
+#endif
+
+/*
+ * Simple doubly linked list implementation.
+ *
+ * Some of the internal functions ("__xxx") are useful when
+ * manipulating whole lists rather than single entries, as
+ * sometimes we already know the next/prev entries and we can
+ * generate better code by using them directly rather than
+ * using the generic single-entry routines.
+ */
+
+struct list_head {
+	struct list_head *next, *prev;
+};
+
+#define LIST_HEAD_INIT(name) { &(name), &(name) }
+
+#define LIST_HEAD(name) \
+	struct list_head name = LIST_HEAD_INIT(name)
+
+#define INIT_LIST_HEAD(ptr) do { \
+	(ptr)->next = (ptr); (ptr)->prev = (ptr); \
+} while (0)
+
+/*
+ * Insert a new entry between two known consecutive entries.
+ *
+ * This is only for internal list manipulation where we know
+ * the prev/next entries already!
+ */
+_INLINE_ void __list_add(struct list_head * add,
+	struct list_head * prev,
+	struct list_head * next)
+{
+	next->prev = add;
+	add->next = next;
+	add->prev = prev;
+	prev->next = add;
+}
+
+/**
+ * list_add - add a new entry
+ * @add:	new entry to be added
+ * @head:	list head to add it after
+ *
+ * Insert a new entry after the specified head.
+ * This is good for implementing stacks.
+ */
+_INLINE_ void list_add(struct list_head *add, struct list_head *head)
+{
+	__list_add(add, head, head->next);
+}
+
+/**
+ * list_add_tail - add a new entry
+ * @add:	new entry to be added
+ * @head:	list head to add it before
+ *
+ * Insert a new entry before the specified head.
+ * This is useful for implementing queues.
+ */
+_INLINE_ void list_add_tail(struct list_head *add, struct list_head *head)
+{
+	__list_add(add, head->prev, head);
+}
+
+/*
+ * Delete a list entry by making the prev/next entries
+ * point to each other.
+ *
+ * This is only for internal list manipulation where we know
+ * the prev/next entries already!
+ */
+_INLINE_ void __list_del(struct list_head * prev,
+				  struct list_head * next)
+{
+	next->prev = prev;
+	prev->next = next;
+}
+
+/**
+ * list_del - deletes entry from list.
+ * @entry:	the element to delete from the list.
+ *
+ * list_empty() on @entry does not return true after this, @entry is
+ * in an undefined state.
+ */
+_INLINE_ void list_del(struct list_head *entry)
+{
+	__list_del(entry->prev, entry->next);
+}
+
+/**
+ * list_del_init - deletes entry from list and reinitialize it.
+ * @entry:	the element to delete from the list.
+ */
+_INLINE_ void list_del_init(struct list_head *entry)
+{
+	__list_del(entry->prev, entry->next);
+	INIT_LIST_HEAD(entry);
+}
+
+/**
+ * list_empty - tests whether a list is empty
+ * @head:	the list to test.
+ */
+_INLINE_ int list_empty(struct list_head *head)
+{
+	return head->next == head;
+}
+
+/**
+ * list_last_entry - tests whether is entry last in the list
+ * @entry:	the entry to test.
+ * @head:	the list to test.
+ */
+_INLINE_ int list_last_entry(struct list_head *entry, struct list_head *head)
+{
+	return head->prev == entry;
+}
+
+/**
+ * list_splice - join two lists
+ * @list:	the new list to add.
+ * @head:	the place to add it in the first list.
+ */
+_INLINE_ void list_splice(struct list_head *list, struct list_head *head)
+{
+	struct list_head *first = list->next;
+
+	if (first != list) {
+		struct list_head *last = list->prev;
+		struct list_head *at = head->next;
+
+		first->prev = head;
+		head->next = first;
+
+		last->next = at;
+		at->prev = last;
+	}
+}
+
+/**
+ * list_entry - get the struct for this entry
+ * @ptr:	the &struct list_head pointer.
+ * @type:	the type of the struct this is embedded in.
+ * @member:	the name of the list_struct within the struct.
+ */
+#define list_entry(ptr, type, member) \
+	((type *)((char *)(ptr)-(unsigned long)(&((type *)0)->member)))
+
+
+#define list_first_entry(head, type, member) \
+	((head) && (head)->next != (head) ? list_entry((head)->next, type, member) : NULL)
+
+/**
+ * list_for_each - iterate over elements in a list
+ * @pos:	the &struct list_head to use as a loop counter.
+ * @head:	the head for your list.
+ */
+#define list_for_each(pos, head) \
+	for (pos = (head)->next; pos != (head); pos = pos->next)
+
+/**
+ * list_for_each_backwardly - iterate over elements in a list in reverse
+ * @pos:	the &struct list_head to use as a loop counter.
+ * @head:	the head for your list.
+ */
+#define list_for_each_backwardly(pos, head) \
+	for (pos = (head)->prev; pos != (head); pos = pos->prev)
+
+/**
+ * list_for_each_safe - iterate over elements in a list, but don't dereference
+ *                      pos after the body is done (in case it is freed)
+ * @pos:	the &struct list_head to use as a loop counter.
+ * @pnext:	the &struct list_head to use as a pointer to the next item.
+ * @head:	the head for your list (not included in iteration).
+ */
+#define list_for_each_safe(pos, pnext, head) \
+	for (pos = (head)->next, pnext = pos->next; pos != (head); \
+	     pos = pnext, pnext = pos->next)
+
+#define MAX_LIST_LENGTH_BITS 20
+
+/*
+ * Returns a list organized in an intermediate format suited
+ * to chaining of merge() calls: null-terminated, no reserved or
+ * sentinel head node, "prev" links not maintained.
+ */
+_INLINE_ struct list_head *merge(int (*cmp)(struct list_head *a,
+					  struct list_head *b),
+			       struct list_head *a, struct list_head *b)
+{
+	struct list_head head, *tail = &head;
+
+	while (a && b) {
+		/* if equal, take 'a' -- important for sort stability */
+		if ((*cmp)(a, b) <= 0) {
+			tail->next = a;
+			a = a->next;
+		} else {
+			tail->next = b;
+			b = b->next;
+		}
+		tail = tail->next;
+	}
+	tail->next = a ? a : b;
+	return head.next;
+}
+
+/*
+ * Combine final list merge with restoration of standard doubly-linked
+ * list structure.  This approach duplicates code from merge(), but
+ * runs faster than the tidier alternatives of either a separate final
+ * prev-link restoration pass, or maintaining the prev links
+ * throughout.
+ */
+_INLINE_ void merge_and_restore_back_links(int (*cmp)(struct list_head *a,
+						    struct list_head *b),
+					 struct list_head *head,
+					 struct list_head *a, struct list_head *b)
+{
+	struct list_head *tail = head;
+
+	while (a && b) {
+		/* if equal, take 'a' -- important for sort stability */
+		if ((*cmp)(a, b) <= 0) {
+			tail->next = a;
+			a->prev = tail;
+			a = a->next;
+		} else {
+			tail->next = b;
+			b->prev = tail;
+			b = b->next;
+		}
+		tail = tail->next;
+	}
+	tail->next = a ? a : b;
+
+	do {
+		/*
+		 * In worst cases this loop may run many iterations.
+		 * Continue callbacks to the client even though no
+		 * element comparison is needed, so the client's cmp()
+		 * routine can invoke cond_resched() periodically.
+		 */
+		(*cmp)(tail->next, tail->next);
+
+		tail->next->prev = tail;
+		tail = tail->next;
+	} while (tail->next);
+
+	tail->next = head;
+	head->prev = tail;
+}
+
+
+/**
+ * list_sort - sort a list
+ * @head: the list to sort
+ * @cmp: the elements comparison function
+ *
+ * This function implements "merge sort", which has O(nlog(n))
+ * complexity.
+ *
+ * The comparison function @cmp must return a negative value if @a
+ * should sort before @b, and a positive value if @a should sort after
+ * @b. If @a and @b are equivalent, and their original relative
+ * ordering is to be preserved, @cmp must return 0.
+ */
+_INLINE_ void list_sort(struct list_head *head,
+			int (*cmp)(struct list_head *a,
+				   struct list_head *b))
+{
+	struct list_head *part[MAX_LIST_LENGTH_BITS+1]; /* sorted partial lists
+							   -- last slot is a sentinel */
+	size_t lev;  /* index into part[] */
+	size_t max_lev = 0;
+	struct list_head *list;
+
+	if (list_empty(head))
+		return;
+
+	memset(part, 0, sizeof(part));
+
+	head->prev->next = NULL;
+	list = head->next;
+
+	while (list) {
+		struct list_head *cur = list;
+		list = list->next;
+		cur->next = NULL;
+
+		for (lev = 0; part[lev]; lev++) {
+			cur = merge(cmp, part[lev], cur);
+			part[lev] = NULL;
+		}
+		if (lev > max_lev) {
+			/* list passed to list_sort() too long for efficiency */
+			if (lev >= ARRAY_SIZE(part) - 1)
+				lev--;
+			max_lev = lev;
+		}
+		part[lev] = cur;
+	}
+
+	for (lev = 0; lev < max_lev; lev++)
+		if (part[lev])
+			list = merge(cmp, part[lev], list);
+
+	merge_and_restore_back_links(cmp, head, part[max_lev], list);
+}
+
+#undef _INLINE_
+
+#endif /* UTIL_LINUX_LIST_H */
diff -up util-linux-ng-2.17.2/include/mbsalign.h.base util-linux-ng-2.17.2/include/mbsalign.h
--- util-linux-ng-2.17.2/include/mbsalign.h.base	2012-10-08 12:03:34.857028208 +0200
+++ util-linux-ng-2.17.2/include/mbsalign.h	2012-10-08 12:03:34.857028208 +0200
@@ -0,0 +1,45 @@
+/* Align/Truncate a string in a given screen width
+   Copyright (C) 2009-2010 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include <stddef.h>
+
+typedef enum { MBS_ALIGN_LEFT, MBS_ALIGN_RIGHT, MBS_ALIGN_CENTER } mbs_align_t;
+
+enum {
+  /* Use unibyte mode for invalid multibyte strings or
+     or when heap memory is exhausted.  */
+  MBA_UNIBYTE_FALLBACK = 0x0001,
+
+#if 0 /* Other possible options.  */
+  /* Skip invalid multibyte chars rather than failing  */
+  MBA_IGNORE_INVALID   = 0x0002,
+
+  /* Align multibyte strings using "figure space" (\u2007)  */
+  MBA_USE_FIGURE_SPACE = 0x0004,
+
+  /* Don't add any padding  */
+  MBA_TRUNCATE_ONLY    = 0x0008,
+
+  /* Don't truncate  */
+  MBA_PAD_ONLY         = 0x0010,
+#endif
+};
+
+extern size_t mbs_truncate(char *str, size_t *width);
+
+extern size_t mbsalign (const char *src, char *dest,
+			size_t dest_size,  size_t *width,
+			mbs_align_t align, int flags);
diff -up util-linux-ng-2.17.2/include/optutils.h.base util-linux-ng-2.17.2/include/optutils.h
--- util-linux-ng-2.17.2/include/optutils.h.base	2012-10-08 12:03:34.857028208 +0200
+++ util-linux-ng-2.17.2/include/optutils.h	2012-10-08 12:03:34.857028208 +0200
@@ -0,0 +1,97 @@
+#ifndef UTIL_LINUX_OPTUTILS_H
+#define UTIL_LINUX_OPTUTILS_H
+
+#include "c.h"
+#include "nls.h"
+
+#include <err.h>
+
+static inline const char *option_to_longopt(int c, const struct option *opts)
+{
+	const struct option *o;
+
+	for (o = opts; o->name; o++)
+		if (o->val == c)
+			return o->name;
+	return NULL;
+}
+
+#ifndef OPTUTILS_EXIT_CODE
+# define OPTUTILS_EXIT_CODE EXIT_FAILURE
+#endif
+
+/*
+ * Check collisions between options.
+ *
+ * The conflicts between options are described in ul_excl_t array. The
+ * array contains groups of mutually exclusive options. For example
+ *
+ *	static const ul_excl_t excl[] = {
+ *		{ 'Z','b','c' },		// first group
+ *		{ 'b','x' },			// second group
+ *		{ 0 }
+ *	};
+ *
+ *	int excl_st[ARRAY_SIZE(excl)] = UL_EXCL_STATUS_INIT;
+ *
+ *	while ((c = getopt_long(argc, argv, "Zbcx", longopts, NULL)) != -1) {
+ *
+ *		err_exclusive_options(c, longopts, excl, excl_st);
+ *
+ *		switch (c) {
+ *		case 'Z':
+ *		   ....
+ *		}
+ *	}
+ *
+ * The array excl[] defines two groups of the mutually exclusive options. The
+ * option '-b' is in the both groups.
+ *
+ * Note that the options in the group have to be in ASCII order (ABC..abc..) and
+ * groups have to be also in ASCII order.
+ *
+ * The current status of options is stored in excl_st array. The size of the array
+ * must be the same as number of the groups in the ul_excl_t array.
+ *
+ * If you're unsure then see sys-utils/mount.c or misc-utils/findmnt.c.
+ */
+#define UL_EXCL_STATUS_INIT	{ 0 }
+typedef int ul_excl_t[16];
+
+static inline void err_exclusive_options(
+			int c,
+			const struct option *opts,
+			const ul_excl_t *excl,
+			int *status)
+{
+	int e;
+
+	for (e = 0; excl[e][0] && excl[e][0] <= c; e++) {
+		const int *op = excl[e];
+
+		for (; *op && *op <= c; op++) {
+			if (*op != c)
+				continue;
+			if (status[e] == 0)
+				status[e] = c;
+			else if (status[e] != c) {
+				fprintf(stderr, _("%s: options "),
+						program_invocation_short_name);
+				for (op = excl[e]; *op; op++) {
+					if (opts)
+						fprintf(stderr, "--%s ",
+							option_to_longopt(*op, opts));
+					else
+						fprintf(stderr, "-%c ", *op);
+				}
+				fprintf(stderr, _("are mutually exclusive."));
+				fputc('\n', stderr);
+				exit(OPTUTILS_EXIT_CODE);
+			}
+			break;
+		}
+	}
+}
+
+#endif
+
diff -up util-linux-ng-2.17.2/include/path.h.base util-linux-ng-2.17.2/include/path.h
--- util-linux-ng-2.17.2/include/path.h.base	2012-10-08 12:03:34.858028214 +0200
+++ util-linux-ng-2.17.2/include/path.h	2012-10-08 12:03:34.858028214 +0200
@@ -0,0 +1,17 @@
+#include <stdio.h>
+
+extern FILE *path_fopen(const char *mode, int exit_on_err, const char *path, ...)
+			__attribute__ ((__format__ (__printf__, 3, 4)));
+extern void path_getstr(char *result, size_t len, const char *path, ...)
+			__attribute__ ((__format__ (__printf__, 3, 4)));
+extern int path_writestr(const char *str, const char *path, ...)
+			 __attribute__ ((__format__ (__printf__, 2, 3)));
+extern int path_getnum(const char *path, ...)
+		       __attribute__ ((__format__ (__printf__, 1, 2)));
+extern int path_exist(const char *path, ...)
+		      __attribute__ ((__format__ (__printf__, 1, 2)));
+extern cpu_set_t *path_cpuset(int, const char *path, ...)
+			      __attribute__ ((__format__ (__printf__, 2, 3)));
+extern cpu_set_t *path_cpulist(int, const char *path, ...)
+			       __attribute__ ((__format__ (__printf__, 2, 3)));
+extern void path_setprefix(const char *);
diff -up util-linux-ng-2.17.2/include/pathnames.h.base util-linux-ng-2.17.2/include/pathnames.h
--- util-linux-ng-2.17.2/include/pathnames.h.base	2010-03-22 09:05:42.000000000 +0100
+++ util-linux-ng-2.17.2/include/pathnames.h	2012-10-08 12:22:21.740736313 +0200
@@ -76,6 +76,9 @@
 #define _PATH_PROC_PARTITIONS	"/proc/partitions"
 #define _PATH_PROC_DEVICES	"/proc/devices"
 
+#define _PATH_SYS_BLOCK		"/sys/block"
+#define _PATH_SYS_DEVBLOCK	"/sys/dev/block"
+
 #ifndef _PATH_MOUNTED
 # ifdef MOUNTED					/* deprecated */
 #  define _PATH_MOUNTED		MOUNTED
diff -up util-linux-ng-2.17.2/include/strutils.h.base util-linux-ng-2.17.2/include/strutils.h
--- util-linux-ng-2.17.2/include/strutils.h.base	2012-10-08 12:03:34.858028214 +0200
+++ util-linux-ng-2.17.2/include/strutils.h	2012-10-08 12:03:34.858028214 +0200
@@ -0,0 +1,76 @@
+#ifndef UTIL_LINUX_STRUTILS
+#define UTIL_LINUX_STRUTILS
+
+#include <inttypes.h>
+#include <string.h>
+#include <sys/types.h>
+
+/* default strtoxx_or_err() exit code */
+#ifndef STRTOXX_EXIT_CODE
+# define STRTOXX_EXIT_CODE EXIT_FAILURE
+#endif
+
+
+extern int strtosize(const char *str, uintmax_t *res);
+extern uintmax_t strtosize_or_err(const char *str, const char *errmesg);
+
+extern int16_t strtos16_or_err(const char *str, const char *errmesg);
+extern uint16_t strtou16_or_err(const char *str, const char *errmesg);
+
+extern int32_t strtos32_or_err(const char *str, const char *errmesg);
+extern uint32_t strtou32_or_err(const char *str, const char *errmesg);
+
+extern int64_t strtos64_or_err(const char *str, const char *errmesg);
+extern uint64_t strtou64_or_err(const char *str, const char *errmesg);
+
+extern double strtod_or_err(const char *str, const char *errmesg);
+
+extern long strtol_or_err(const char *str, const char *errmesg);
+extern unsigned long strtoul_or_err(const char *str, const char *errmesg);
+
+#ifndef HAVE_STRNLEN
+extern size_t strnlen(const char *s, size_t maxlen);
+#endif
+#ifndef HAVE_STRNDUP
+extern char *strndup(const char *s, size_t n);
+#endif
+#ifndef HAVE_STRNCHR
+extern char *strnchr(const char *s, size_t maxlen, int c);
+#endif
+
+/* caller guarantees n > 0 */
+static inline void xstrncpy(char *dest, const char *src, size_t n)
+{
+	strncpy(dest, src, n-1);
+	dest[n-1] = 0;
+}
+
+extern void strmode(mode_t mode, char *str);
+
+/* Options for size_to_human_string() */
+enum
+{
+        SIZE_SUFFIX_1LETTER = 0,
+        SIZE_SUFFIX_3LETTER = 1,
+        SIZE_SUFFIX_SPACE   = 2
+};
+
+extern char *size_to_human_string(int options, uint64_t bytes);
+
+extern int string_to_idarray(const char *list, int ary[], size_t arysz,
+			   int (name2id)(const char *, size_t));
+extern int string_add_to_idarray(const char *list, int ary[],
+				 size_t arysz, int *ary_pos,
+				 int (name2id)(const char *, size_t));
+
+extern int string_to_bitarray(const char *list, char *ary,
+			    int (*name2bit)(const char *, size_t));
+
+extern int string_to_bitmask(const char *list,
+			     unsigned long *mask,
+			     long (*name2flag)(const char *, size_t));
+extern int parse_range(const char *str, int *lower, int *upper, int def);
+
+extern int streq_except_trailing_slash(const char *s1, const char *s2);
+
+#endif
diff -up util-linux-ng-2.17.2/include/sysfs.h.base util-linux-ng-2.17.2/include/sysfs.h
--- util-linux-ng-2.17.2/include/sysfs.h.base	2012-10-08 12:03:34.858028214 +0200
+++ util-linux-ng-2.17.2/include/sysfs.h	2012-10-08 12:03:34.858028214 +0200
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2011 Karel Zak <kzak@redhat.com>
+ */
+#ifndef UTIL_LINUX_SYSFS_H
+#define UTIL_LINUX_SYSFS_H
+
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <stdint.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <string.h>
+#include <inttypes.h>
+#include <dirent.h>
+
+struct sysfs_cxt {
+	dev_t	devno;
+	int	dir_fd;		/* /sys/block/<name> */
+	char	*dir_path;
+	struct sysfs_cxt *parent;
+};
+
+#define UL_SYSFSCXT_EMPTY { 0, -1, NULL, NULL }
+
+extern char *sysfs_devno_attribute_path(dev_t devno, char *buf,
+                                 size_t bufsiz, const char *attr);
+extern int sysfs_devno_has_attribute(dev_t devno, const char *attr);
+extern char *sysfs_devno_path(dev_t devno, char *buf, size_t bufsiz);
+extern char *sysfs_devno_to_devpath(dev_t devno, char *buf, size_t bufsiz);
+extern dev_t sysfs_devname_to_devno(const char *name, const char *parent);
+
+extern int sysfs_init(struct sysfs_cxt *cxt, dev_t devno, struct sysfs_cxt *parent)
+					__attribute__ ((warn_unused_result));
+extern void sysfs_deinit(struct sysfs_cxt *cxt);
+
+extern DIR *sysfs_opendir(struct sysfs_cxt *cxt, const char *attr);
+
+extern int sysfs_stat(struct sysfs_cxt *cxt, const char *attr, struct stat *st);
+extern ssize_t sysfs_readlink(struct sysfs_cxt *cxt, const char *attr,
+	                   char *buf, size_t bufsiz);
+extern int sysfs_has_attribute(struct sysfs_cxt *cxt, const char *attr);
+
+extern int sysfs_scanf(struct sysfs_cxt *cxt,  const char *attr,
+		       const char *fmt, ...)
+		        __attribute__ ((format (scanf, 3, 4)));
+
+extern int sysfs_read_s64(struct sysfs_cxt *cxt, const char *attr, int64_t *res);
+extern int sysfs_read_u64(struct sysfs_cxt *cxt, const char *attr, uint64_t *res);
+extern int sysfs_read_int(struct sysfs_cxt *cxt, const char *attr, int *res);
+
+extern char *sysfs_get_devname(struct sysfs_cxt *cxt, char *buf, size_t bufsiz);
+
+extern char *sysfs_strdup(struct sysfs_cxt *cxt, const char *attr);
+
+extern int sysfs_count_dirents(struct sysfs_cxt *cxt, const char *attr);
+extern int sysfs_count_partitions(struct sysfs_cxt *cxt, const char *devname);
+extern dev_t sysfs_partno_to_devno(struct sysfs_cxt *cxt, int partno);
+extern char *sysfs_get_slave(struct sysfs_cxt *cxt);
+
+extern int sysfs_is_partition_dirent(DIR *dir, struct dirent *d,
+			const char *parent_name);
+
+extern int sysfs_devno_to_wholedisk(dev_t dev, char *diskname,
+            size_t len, dev_t *diskdevno);
+#endif /* UTIL_LINUX_SYSFS_H */
diff -up util-linux-ng-2.17.2/include/tt.h.base util-linux-ng-2.17.2/include/tt.h
--- util-linux-ng-2.17.2/include/tt.h.base	2012-10-08 12:03:34.858028214 +0200
+++ util-linux-ng-2.17.2/include/tt.h	2012-10-08 12:03:34.858028214 +0200
@@ -0,0 +1,93 @@
+/*
+ * Prints table or tree. See lib/table.c for more details and example.
+ *
+ * Copyright (C) 2010 Karel Zak <kzak@redhat.com>
+ *
+ * This file may be redistributed under the terms of the
+ * GNU Lesser General Public License.
+ */
+#ifndef UTIL_LINUX_TT_H
+#define UTIL_LINUX_TT_H
+
+#include "list.h"
+
+enum {
+	/*
+	 * Global flags
+	 */
+	TT_FL_RAW         = (1 << 1),
+	TT_FL_ASCII       = (1 << 2),
+	TT_FL_NOHEADINGS  = (1 << 3),
+	TT_FL_EXPORT      = (1 << 4),
+
+	/*
+	 * Column flags
+	 */
+	TT_FL_TRUNC       = (1 << 5),	/* truncate fields data if necessary */
+	TT_FL_TREE        = (1 << 6),	/* use tree "ascii art" */
+	TT_FL_RIGHT	  = (1 << 7),	/* align to the right */
+	TT_FL_STRICTWIDTH = (1 << 8),	/* don't reduce width if column is empty */
+	TT_FL_NOEXTREMES  = (1 << 9)    /* ignore extreme fields when count column width*/
+};
+
+struct tt {
+	size_t	ncols;		/* number of columns */
+	size_t	termwidth;	/* terminal width */
+	int	flags;
+	int	first_run;
+
+	struct list_head	tb_columns;
+	struct list_head	tb_lines;
+
+	const struct tt_symbols	*symbols;
+};
+
+struct tt_column {
+	const char *name;	/* header */
+	size_t	seqnum;
+
+	size_t	width;		/* real column width */
+	size_t	width_min;	/* minimal width (usually header width) */
+	size_t  width_max;	/* maximal width */
+	size_t  width_avg;	/* average width, used to detect extreme fields */
+	double	width_hint;	/* hint (N < 1 is in percent of termwidth) */
+
+	int	flags;
+	int	is_extreme;
+
+	struct list_head	cl_columns;
+};
+
+struct tt_line {
+	struct tt	*table;
+	char const	**data;
+	void		*userdata;
+	size_t		data_sz;		/* strlen of all data */
+
+	struct list_head	ln_lines;	/* table lines */
+
+	struct list_head	ln_branch;	/* begin of branch (head of ln_children) */
+	struct list_head	ln_children;
+
+	struct tt_line	*parent;
+};
+
+extern struct tt *tt_new_table(int flags);
+extern void tt_free_table(struct tt *tb);
+extern void tt_remove_lines(struct tt *tb);
+extern int tt_print_table(struct tt *tb);
+
+extern struct tt_column *tt_define_column(struct tt *tb, const char *name,
+						double whint, int flags);
+
+extern struct tt_column *tt_get_column(struct tt *tb, size_t colnum);
+
+extern struct tt_line *tt_add_line(struct tt *tb, struct tt_line *parent);
+
+extern int tt_line_set_data(struct tt_line *ln, int colnum, const char *data);
+extern int tt_line_set_userdata(struct tt_line *ln, void *data);
+
+extern void tt_fputs_quoted(const char *data, FILE *out);
+extern void tt_fputs_nonblank(const char *data, FILE *out);
+
+#endif /* UTIL_LINUX_TT_H */
diff -up util-linux-ng-2.17.2/include/ttyutils.h.base util-linux-ng-2.17.2/include/ttyutils.h
--- util-linux-ng-2.17.2/include/ttyutils.h.base	2012-10-08 12:03:34.858028214 +0200
+++ util-linux-ng-2.17.2/include/ttyutils.h	2012-10-08 12:03:34.858028214 +0200
@@ -0,0 +1,118 @@
+#ifndef UTIL_LINUX_TTYUTILS_H
+#define UTIL_LINUX_TTYUTILS_H
+
+#include <stdlib.h>
+#include <termios.h>
+#include <limits.h>
+#ifdef HAVE_SYS_IOCTL_H
+#include <sys/ioctl.h>
+#endif
+
+#include <errno.h>
+
+#define UL_TTY_KEEPCFLAGS	(1 << 1)
+#define UL_TTY_UTF8		(1 << 2)
+
+static inline void reset_virtual_console(struct termios *tp, int flags)
+{
+	/* Use defaults of <sys/ttydefaults.h> for base settings */
+	tp->c_iflag |= TTYDEF_IFLAG;
+	tp->c_oflag |= TTYDEF_OFLAG;
+	tp->c_lflag |= TTYDEF_LFLAG;
+
+	if ((flags & UL_TTY_KEEPCFLAGS) == 0) {
+#ifdef CBAUD
+		tp->c_lflag &= ~CBAUD;
+#endif
+		tp->c_cflag |= (B38400 | TTYDEF_CFLAG);
+	}
+
+	/* Sane setting, allow eight bit characters, no carriage return delay
+	 * the same result as `stty sane cr0 pass8'
+	 */
+	tp->c_iflag |=  (BRKINT | ICRNL | IMAXBEL);
+	tp->c_iflag &= ~(IGNBRK | INLCR | IGNCR | IXOFF | IUCLC | IXANY | ISTRIP);
+	tp->c_oflag |=  (OPOST | ONLCR | NL0 | CR0 | TAB0 | BS0 | VT0 | FF0);
+	tp->c_oflag &= ~(OLCUC | OCRNL | ONOCR | ONLRET | OFILL | \
+			    NLDLY|CRDLY|TABDLY|BSDLY|VTDLY|FFDLY);
+	tp->c_lflag |=  (ISIG | ICANON | IEXTEN | ECHO|ECHOE|ECHOK|ECHOKE);
+	tp->c_lflag &= ~(ECHONL|ECHOCTL|ECHOPRT | NOFLSH | TOSTOP);
+
+	if ((flags & UL_TTY_KEEPCFLAGS) == 0) {
+		tp->c_cflag |=  (CREAD | CS8 | HUPCL);
+		tp->c_cflag &= ~(PARODD | PARENB);
+	}
+#ifdef OFDEL
+	tp->c_oflag &= ~OFDEL;
+#endif
+#ifdef XCASE
+	tp->c_lflag &= ~XCASE;
+#endif
+#ifdef IUTF8
+	if (flags & UL_TTY_UTF8)
+		tp->c_iflag |= IUTF8;	    /* Set UTF-8 input flag */
+	else
+		tp->c_iflag &= ~IUTF8;
+#endif
+	/* VTIME and VMIN can overlap with VEOF and VEOL since they are
+	 * only used for non-canonical mode. We just set the at the
+	 * beginning, so nothing bad should happen.
+	 */
+	tp->c_cc[VTIME]    = 0;
+	tp->c_cc[VMIN]     = 1;
+	tp->c_cc[VINTR]    = CINTR;
+	tp->c_cc[VQUIT]    = CQUIT;
+	tp->c_cc[VERASE]   = CERASE; /* ASCII DEL (0177) */
+	tp->c_cc[VKILL]    = CKILL;
+	tp->c_cc[VEOF]     = CEOF;
+#ifdef VSWTC
+	tp->c_cc[VSWTC]    = _POSIX_VDISABLE;
+#elif defined(VSWTCH)
+	tp->c_cc[VSWTCH]   = _POSIX_VDISABLE;
+#endif
+	tp->c_cc[VSTART]   = CSTART;
+	tp->c_cc[VSTOP]    = CSTOP;
+	tp->c_cc[VSUSP]    = CSUSP;
+	tp->c_cc[VEOL]     = _POSIX_VDISABLE;
+	tp->c_cc[VREPRINT] = CREPRINT;
+	tp->c_cc[VDISCARD] = CDISCARD;
+	tp->c_cc[VWERASE]  = CWERASE;
+	tp->c_cc[VLNEXT]   = CLNEXT;
+	tp->c_cc[VEOL2]    = _POSIX_VDISABLE;
+}
+
+static inline int get_terminal_width(void)
+{
+#ifdef TIOCGSIZE
+	struct ttysize	t_win;
+#endif
+#ifdef TIOCGWINSZ
+	struct winsize	w_win;
+#endif
+        const char	*cp;
+
+#ifdef TIOCGSIZE
+	if (ioctl (0, TIOCGSIZE, &t_win) == 0)
+		return t_win.ts_cols;
+#endif
+#ifdef TIOCGWINSZ
+	if (ioctl (0, TIOCGWINSZ, &w_win) == 0)
+		return w_win.ws_col;
+#endif
+        cp = getenv("COLUMNS");
+	if (cp) {
+		char *end = NULL;
+		long c;
+
+		errno = 0;
+		c = strtol(cp, &end, 10);
+
+		if (errno == 0 && end && *end == '\0' && end > cp &&
+		    c > 0 && c <= INT_MAX)
+			return c;
+	}
+	return 0;
+}
+
+
+#endif /* UTIL_LINUX_TTYUTILS_H */
diff -up util-linux-ng-2.17.2/include/xalloc.h.base util-linux-ng-2.17.2/include/xalloc.h
--- util-linux-ng-2.17.2/include/xalloc.h.base	2012-10-08 12:03:34.859028220 +0200
+++ util-linux-ng-2.17.2/include/xalloc.h	2012-10-08 12:03:34.859028220 +0200
@@ -0,0 +1,98 @@
+/*
+ * Copyright (C) 2010 Davidlohr Bueso <dave@gnu.org>
+ *
+ * This file may be redistributed under the terms of the
+ * GNU Lesser General Public License.
+ *
+ * General memory allocation wrappers for malloc, realloc, calloc and strdup
+ */
+
+#ifndef UTIL_LINUX_XALLOC_H
+#define UTIL_LINUX_XALLOC_H
+
+#include <stdlib.h>
+#include <string.h>
+
+#include "c.h"
+
+/* <RHEL6> hardcoded for backport */
+#include <err.h>
+
+#ifndef __ul_alloc_size
+# if __GNUC_PREREQ (4, 3)
+#  define __ul_alloc_size(s) __attribute__((alloc_size(s)))
+# else
+#  define __ul_alloc_size(s)
+# endif
+#endif
+
+#ifndef __ul_calloc_size
+# if __GNUC_PREREQ (4, 3)
+#  define __ul_calloc_size(n, s) __attribute__((alloc_size(n, s)))
+# else
+#  define __ul_calloc_size(n, s)
+# endif
+#endif
+/* </RHEL6> */
+
+#ifndef XALLOC_EXIT_CODE
+# define XALLOC_EXIT_CODE EXIT_FAILURE
+#endif
+
+static inline __ul_alloc_size(1)
+void *xmalloc(const size_t size)
+{
+        void *ret = malloc(size);
+
+        if (!ret && size)
+                err(XALLOC_EXIT_CODE, "cannot allocate %zu bytes", size);
+        return ret;
+}
+
+static inline __ul_alloc_size(2)
+void *xrealloc(void *ptr, const size_t size)
+{
+        void *ret = realloc(ptr, size);
+
+        if (!ret && size)
+                err(XALLOC_EXIT_CODE, "cannot allocate %zu bytes", size);
+        return ret;
+}
+
+static inline __ul_calloc_size(1, 2)
+void *xcalloc(const size_t nelems, const size_t size)
+{
+        void *ret = calloc(nelems, size);
+
+        if (!ret && size && nelems)
+                err(XALLOC_EXIT_CODE, "cannot allocate %zu bytes", size);
+        return ret;
+}
+
+static inline char *xstrdup(const char *str)
+{
+        char *ret;
+
+        if (!str)
+                return NULL;
+
+        ret = strdup(str);
+
+        if (!ret)
+                err(XALLOC_EXIT_CODE, "cannot duplicate string");
+        return ret;
+}
+
+static inline int __attribute__ ((__format__(printf, 2, 3)))
+    xasprintf(char **strp, const char *fmt, ...)
+{
+	int ret;
+	va_list args;
+	va_start(args, fmt);
+	ret = vasprintf(&(*strp), fmt, args);
+	va_end(args);
+	if (ret < 0)
+		err(XALLOC_EXIT_CODE, "cannot allocate string");
+	return ret;
+}
+#endif
diff -up util-linux-ng-2.17.2/lib/at.c.base util-linux-ng-2.17.2/lib/at.c
--- util-linux-ng-2.17.2/lib/at.c.base	2012-10-08 12:03:34.859028220 +0200
+++ util-linux-ng-2.17.2/lib/at.c	2012-10-08 12:03:34.859028220 +0200
@@ -0,0 +1,140 @@
+/*
+ * Portable xxxat() functions.
+ *
+ * Copyright (C) 2010 Karel Zak <kzak@redhat.com>
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+
+#include "at.h"
+#include "c.h"
+
+#ifdef HAVE_FSTATAT
+int fstat_at(int dir, const char *dirname __attribute__ ((__unused__)),
+	     const char *filename, struct stat *st, int nofollow)
+{
+	return fstatat(dir, filename, st,
+			nofollow ? AT_SYMLINK_NOFOLLOW : 0);
+}
+#else
+int fstat_at(int dir, const char *dirname, const char *filename,
+				struct stat *st, int nofollow)
+{
+
+	if (*filename != '/') {
+		char path[PATH_MAX];
+		int len;
+
+		len = snprintf(path, sizeof(path), "%s/%s", dirname, filename);
+		if (len < 0 || len + 1 > sizeof(path))
+			return -1;
+
+		return nofollow ? lstat(path, st) : stat(path, st);
+	}
+
+	return nofollow ? lstat(filename, st) : stat(filename, st);
+}
+#endif
+
+#ifdef HAVE_FSTATAT
+int open_at(int dir, const char *dirname __attribute__ ((__unused__)),
+	    const char *filename, int flags)
+{
+	return openat(dir, filename, flags);
+}
+#else
+int open_at(int dir, const char *dirname, const char *filename, int flags)
+{
+	if (*filename != '/') {
+		char path[PATH_MAX];
+		int len;
+
+		len = snprintf(path, sizeof(path), "%s/%s", dirname, filename);
+		if (len < 0 || len + 1 > sizeof(path))
+			return -1;
+
+		return open(path, flags);
+	}
+	return open(filename, flags);
+}
+#endif
+
+FILE *fopen_at(int dir, const char *dirname, const char *filename, int flags,
+			const char *mode)
+{
+	int fd = open_at(dir, dirname, filename, flags);
+
+	if (fd < 0)
+		return NULL;
+
+	return fdopen(fd, mode);
+}
+
+#ifdef HAVE_FSTATAT
+ssize_t readlink_at(int dir, const char *dirname __attribute__ ((__unused__)),
+		    const char *pathname, char *buf, size_t bufsiz)
+{
+	return readlinkat(dir, pathname, buf, bufsiz);
+}
+#else
+ssize_t readlink_at(int dir, const char *dirname, const char *pathname,
+		    char *buf, size_t bufsiz)
+{
+	if (*pathname != '/') {
+		char path[PATH_MAX];
+		int len;
+
+		len = snprintf(path, sizeof(path), "%s/%s", dirname, pathname);
+		if (len < 0 || len + 1 > sizeof(path))
+			return -1;
+
+		return readlink(path, buf, bufsiz);
+	}
+	return readlink(pathname, buf, bufsiz);
+}
+#endif
+
+#ifdef TEST_PROGRAM_AT
+#include <errno.h>
+#include <sys/types.h>
+#include <dirent.h>
+#include <string.h>
+
+int main(int argc, char *argv[])
+{
+	DIR *dir;
+	struct dirent *d;
+	char *dirname;
+
+	if (argc != 2) {
+		fprintf(stderr, "usage: %s <directory>\n", argv[0]);
+		exit(EXIT_FAILURE);
+	}
+	dirname = argv[1];
+
+	dir = opendir(dirname);
+	if (!dir)
+		err(EXIT_FAILURE, "cannot open %s", dirname);
+
+	while ((d = readdir(dir))) {
+		struct stat st;
+		FILE *f;
+
+		printf("%32s ", d->d_name);
+
+		if (fstat_at(dirfd(dir), dirname, d->d_name, &st, 0) == 0)
+			printf("%16jd bytes ", st.st_size);
+		else
+			printf("%16s bytes ", "???");
+
+		f = fopen_at(dirfd(dir), dirname, d->d_name, O_RDONLY, "r");
+		printf("   %s\n", f ? "OK" : strerror(errno));
+		if (f)
+			fclose(f);
+	}
+	closedir(dir);
+	return EXIT_SUCCESS;
+}
+#endif
diff -up util-linux-ng-2.17.2/lib/ismounted.c.base util-linux-ng-2.17.2/lib/ismounted.c
--- util-linux-ng-2.17.2/lib/ismounted.c.base	2010-03-18 23:11:23.000000000 +0100
+++ util-linux-ng-2.17.2/lib/ismounted.c	2012-10-08 12:03:34.859028220 +0200
@@ -11,14 +11,21 @@
 #include <stdlib.h>
 #include <errno.h>
 #include <fcntl.h>
+#ifdef HAVE_MNTENT_H
 #include <mntent.h>
+#endif
 #include <string.h>
 #include <sys/stat.h>
 #include <ctype.h>
 #include <sys/param.h>
+#ifdef __APPLE__
+#include <sys/ucred.h>
+#include <sys/mount.h>
+#endif
 
 #include "pathnames.h"
 #include "ismounted.h"
+#include "c.h"
 
 #ifdef HAVE_MNTENT_H
 /*
@@ -164,6 +171,10 @@ static int check_mntent(const char *file
 				   mtpt, mtlen);
 	if (retval == 0 && (*mount_flags != 0))
 		return 0;
+	if (access("/proc/mounts", R_OK) == 0) {
+		*mount_flags = 0;
+		return retval;
+	}
 #endif /* __linux__ */
 #if defined(MOUNTED) || defined(_PATH_MOUNTED)
 #ifndef MOUNTED
diff -up util-linux-ng-2.17.2/lib/mbsalign.c.base util-linux-ng-2.17.2/lib/mbsalign.c
--- util-linux-ng-2.17.2/lib/mbsalign.c.base	2012-10-08 12:03:34.859028220 +0200
+++ util-linux-ng-2.17.2/lib/mbsalign.c	2012-10-08 12:03:34.859028220 +0200
@@ -0,0 +1,290 @@
+/* Align/Truncate a string in a given screen width
+   Copyright (C) 2009-2010 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Written by Pádraig Brady.  */
+
+#include <config.h>
+
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include <stdbool.h>
+#include <limits.h>
+
+#include "c.h"
+#include "mbsalign.h"
+#include "widechar.h"
+
+
+#ifdef HAVE_WIDECHAR
+/* Replace non printable chars.
+   Note \t and \n etc. are non printable.
+   Return 1 if replacement made, 0 otherwise.  */
+
+static bool
+wc_ensure_printable (wchar_t *wchars)
+{
+  bool replaced = false;
+  wchar_t *wc = wchars;
+  while (*wc)
+    {
+      if (!iswprint ((wint_t) *wc))
+        {
+          *wc = 0xFFFD; /* L'\uFFFD' (replacement char) */
+          replaced = true;
+        }
+      wc++;
+    }
+  return replaced;
+}
+
+/* Truncate wchar string to width cells.
+ * Returns number of cells used.  */
+
+static size_t
+wc_truncate (wchar_t *wc, size_t width)
+{
+  size_t cells = 0;
+  int next_cells = 0;
+
+  while (*wc)
+    {
+      next_cells = wcwidth (*wc);
+      if (next_cells == -1) /* non printable */
+        {
+          *wc = 0xFFFD; /* L'\uFFFD' (replacement char) */
+          next_cells = 1;
+        }
+      if (cells + next_cells > width)
+        break;
+      cells += next_cells;
+      wc++;
+    }
+  *wc = L'\0';
+  return cells;
+}
+
+/* FIXME: move this function to gnulib as it's missing on:
+   OpenBSD 3.8, IRIX 5.3, Solaris 2.5.1, mingw, BeOS  */
+
+static int
+rpl_wcswidth (const wchar_t *s, size_t n)
+{
+  int ret = 0;
+
+  while (n-- > 0 && *s != L'\0')
+    {
+      int nwidth = wcwidth (*s++);
+      if (nwidth == -1)             /* non printable */
+        return -1;
+      if (ret > (INT_MAX - nwidth)) /* overflow */
+        return -1;
+      ret += nwidth;
+    }
+
+  return ret;
+}
+#endif
+
+/* Truncate multi-byte string to @width and returns number of
+ * bytes of the new string @str, and in @width returns number
+ * of cells.
+ */
+size_t
+mbs_truncate(char *str, size_t *width)
+{
+	ssize_t bytes = strlen(str);
+#ifdef HAVE_WIDECHAR
+	ssize_t sz = mbstowcs(NULL, str, 0);
+	wchar_t *wcs = NULL;
+
+	if (sz == (ssize_t) -1)
+		goto done;
+
+	wcs = malloc((sz + 1) * sizeof(wchar_t));
+	if (!wcs)
+		goto done;
+
+	if (!mbstowcs(wcs, str, sz))
+		goto done;
+	*width = wc_truncate(wcs, *width);
+	bytes = wcstombs(str, wcs, bytes);
+done:
+	free(wcs);
+#else
+	if (*width < bytes)
+		bytes = *width;
+#endif
+	if (bytes >= 0)
+		str[bytes] = '\0';
+	return bytes;
+}
+
+/* Write N_SPACES space characters to DEST while ensuring
+   nothing is written beyond DEST_END. A terminating NUL
+   is always added to DEST.
+   A pointer to the terminating NUL is returned.  */
+
+static char*
+mbs_align_pad (char *dest, const char* dest_end, size_t n_spaces)
+{
+  /* FIXME: Should we pad with "figure space" (\u2007)
+     if non ascii data present?  */
+  while (n_spaces-- && (dest < dest_end))
+    *dest++ = ' ';
+  *dest = '\0';
+  return dest;
+}
+
+/* Align a string, SRC, in a field of *WIDTH columns, handling multi-byte
+   characters; write the result into the DEST_SIZE-byte buffer, DEST.
+   ALIGNMENT specifies whether to left- or right-justify or to center.
+   If SRC requires more than *WIDTH columns, truncate it to fit.
+   When centering, the number of trailing spaces may be one less than the
+   number of leading spaces. The FLAGS parameter is unused at present.
+   Return the length in bytes required for the final result, not counting
+   the trailing NUL.  A return value of DEST_SIZE or larger means there
+   wasn't enough space.  DEST will be NUL terminated in any case.
+   Return (size_t) -1 upon error (invalid multi-byte sequence in SRC,
+   or malloc failure), unless MBA_UNIBYTE_FALLBACK is specified.
+   Update *WIDTH to indicate how many columns were used before padding.  */
+
+size_t
+mbsalign (const char *src, char *dest, size_t dest_size,
+          size_t *width, mbs_align_t align, int flags)
+{
+  size_t ret = -1;
+  size_t src_size = strlen (src) + 1;
+  char *newstr = NULL;
+  wchar_t *str_wc = NULL;
+  const char *str_to_print = src;
+  size_t n_cols = src_size - 1;
+  size_t n_used_bytes = n_cols; /* Not including NUL */
+  size_t n_spaces = 0;
+  bool conversion = false;
+  bool wc_enabled = false;
+
+#ifdef HAVE_WIDECHAR
+  /* In multi-byte locales convert to wide characters
+     to allow easy truncation. Also determine number
+     of screen columns used.  */
+  if (MB_CUR_MAX > 1)
+    {
+      size_t src_chars = mbstowcs (NULL, src, 0);
+      if (src_chars == (size_t) -1)
+        {
+          if (flags & MBA_UNIBYTE_FALLBACK)
+            goto mbsalign_unibyte;
+          else
+            goto mbsalign_cleanup;
+        }
+      src_chars += 1; /* make space for NUL */
+      str_wc = malloc (src_chars * sizeof (wchar_t));
+      if (str_wc == NULL)
+        {
+          if (flags & MBA_UNIBYTE_FALLBACK)
+            goto mbsalign_unibyte;
+          else
+            goto mbsalign_cleanup;
+        }
+      if (mbstowcs (str_wc, src, src_chars) != 0)
+        {
+          str_wc[src_chars - 1] = L'\0';
+          wc_enabled = true;
+          conversion = wc_ensure_printable (str_wc);
+          n_cols = rpl_wcswidth (str_wc, src_chars);
+        }
+    }
+
+  /* If we transformed or need to truncate the source string
+     then create a modified copy of it.  */
+  if (wc_enabled && (conversion || (n_cols > *width)))
+    {
+        if (conversion)
+          {
+             /* May have increased the size by converting
+                \t to \uFFFD for example.  */
+            src_size = wcstombs(NULL, str_wc, 0) + 1;
+          }
+        newstr = malloc (src_size);
+        if (newstr == NULL)
+        {
+          if (flags & MBA_UNIBYTE_FALLBACK)
+            goto mbsalign_unibyte;
+          else
+            goto mbsalign_cleanup;
+        }
+        str_to_print = newstr;
+        n_cols = wc_truncate (str_wc, *width);
+        n_used_bytes = wcstombs (newstr, str_wc, src_size);
+    }
+#endif
+
+mbsalign_unibyte:
+
+  if (n_cols > *width) /* Unibyte truncation required.  */
+    {
+      n_cols = *width;
+      n_used_bytes = n_cols;
+    }
+
+  if (*width > n_cols) /* Padding required.  */
+    n_spaces = *width - n_cols;
+
+  /* indicate to caller how many cells needed (not including padding).  */
+  *width = n_cols;
+
+  /* indicate to caller how many bytes needed (not including NUL).  */
+  ret = n_used_bytes + (n_spaces * 1);
+
+  /* Write as much NUL terminated output to DEST as possible.  */
+  if (dest_size != 0)
+    {
+      char *dest_end = dest + dest_size - 1;
+      size_t start_spaces = n_spaces / 2 + n_spaces % 2;
+      size_t end_spaces = n_spaces / 2;
+
+      switch (align)
+        {
+        case MBS_ALIGN_CENTER:
+          start_spaces = n_spaces / 2 + n_spaces % 2;
+          end_spaces = n_spaces / 2;
+          break;
+        case MBS_ALIGN_LEFT:
+          start_spaces = 0;
+          end_spaces = n_spaces;
+          break;
+        case MBS_ALIGN_RIGHT:
+          start_spaces = n_spaces;
+          end_spaces = 0;
+          break;
+	default:
+	  abort();
+        }
+
+      dest = mbs_align_pad (dest, dest_end, start_spaces);
+      size_t space_left = dest_end - dest;
+      dest = mempcpy (dest, str_to_print, min (n_used_bytes, space_left));
+      mbs_align_pad (dest, dest_end, end_spaces);
+    }
+
+mbsalign_cleanup:
+
+  free (str_wc);
+  free (newstr);
+
+  return ret;
+}
diff -up util-linux-ng-2.17.2/lib/path.c.base util-linux-ng-2.17.2/lib/path.c
--- util-linux-ng-2.17.2/lib/path.c.base	2012-10-08 12:03:34.859028220 +0200
+++ util-linux-ng-2.17.2/lib/path.c	2012-10-08 12:03:34.859028220 +0200
@@ -0,0 +1,223 @@
+/*
+ * Simple functions to access files.
+ *
+ * Taken from lscpu.c
+ *
+ * Copyright (C) 2008 Cai Qian <qcai@redhat.com>
+ * Copyright (C) 2008 Karel Zak <kzak@redhat.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it would be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <stdarg.h>
+#include <string.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <errno.h>
+#include <err.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+
+#include "all-io.h"
+#include "cpuset.h"
+#include "path.h"
+#include "nls.h"
+#include "c.h"
+
+static size_t prefixlen;
+static char pathbuf[PATH_MAX];
+
+static const char *
+path_vcreate(const char *path, va_list ap)
+{
+	if (prefixlen)
+		vsnprintf(pathbuf + prefixlen,
+			  sizeof(pathbuf) - prefixlen, path, ap);
+	else
+		vsnprintf(pathbuf, sizeof(pathbuf), path, ap);
+	return pathbuf;
+}
+
+static FILE *
+path_vfopen(const char *mode, int exit_on_error, const char *path, va_list ap)
+{
+	FILE *f;
+	const char *p = path_vcreate(path, ap);
+
+	f = fopen(p, mode);
+	if (!f && exit_on_error)
+		err(EXIT_FAILURE, _("cannot open %s"), p);
+	return f;
+}
+
+static int
+path_vopen(int flags, const char *path, va_list ap)
+{
+	int fd;
+	const char *p = path_vcreate(path, ap);
+
+	fd = open(p, flags);
+	if (fd == -1)
+		err(EXIT_FAILURE, _("cannot open %s"), p);
+	return fd;
+}
+
+FILE *
+path_fopen(const char *mode, int exit_on_error, const char *path, ...)
+{
+	FILE *fd;
+	va_list ap;
+
+	va_start(ap, path);
+	fd = path_vfopen(mode, exit_on_error, path, ap);
+	va_end(ap);
+
+	return fd;
+}
+
+void
+path_getstr(char *result, size_t len, const char *path, ...)
+{
+	FILE *fd;
+	va_list ap;
+
+	va_start(ap, path);
+	fd = path_vfopen("r", 1, path, ap);
+	va_end(ap);
+
+	if (!fgets(result, len, fd))
+		err(EXIT_FAILURE, _("failed to read: %s"), pathbuf);
+	fclose(fd);
+
+	len = strlen(result);
+	if (result[len - 1] == '\n')
+		result[len - 1] = '\0';
+}
+
+int
+path_getnum(const char *path, ...)
+{
+	FILE *fd;
+	va_list ap;
+	int result;
+
+	va_start(ap, path);
+	fd = path_vfopen("r", 1, path, ap);
+	va_end(ap);
+
+	if (fscanf(fd, "%d", &result) != 1) {
+		if (ferror(fd))
+			err(EXIT_FAILURE, _("failed to read: %s"), pathbuf);
+		else
+			errx(EXIT_FAILURE, _("parse error: %s"), pathbuf);
+	}
+	fclose(fd);
+	return result;
+}
+
+int
+path_writestr(const char *str, const char *path, ...)
+{
+	int fd, result;
+	va_list ap;
+
+	va_start(ap, path);
+	fd = path_vopen(O_WRONLY, path, ap);
+	va_end(ap);
+	result = write_all(fd, str, strlen(str));
+	close(fd);
+	return result;
+}
+
+int
+path_exist(const char *path, ...)
+{
+	va_list ap;
+	const char *p;
+
+	va_start(ap, path);
+	p = path_vcreate(path, ap);
+	va_end(ap);
+
+	return access(p, F_OK) == 0;
+}
+
+static cpu_set_t *
+path_cpuparse(int maxcpus, int islist, const char *path, va_list ap)
+{
+	FILE *fd;
+	cpu_set_t *set;
+	size_t setsize, len = maxcpus * 7;
+	char buf[len];
+
+	fd = path_vfopen("r", 1, path, ap);
+
+	if (!fgets(buf, len, fd))
+		err(EXIT_FAILURE, _("failed to read: %s"), pathbuf);
+	fclose(fd);
+
+	len = strlen(buf);
+	if (buf[len - 1] == '\n')
+		buf[len - 1] = '\0';
+
+	set = cpuset_alloc(maxcpus, &setsize, NULL);
+	if (!set)
+		err(EXIT_FAILURE, _("failed to callocate cpu set"));
+
+	if (islist) {
+		if (cpulist_parse(buf, set, setsize, 0))
+			errx(EXIT_FAILURE, _("failed to parse CPU list %s"), buf);
+	} else {
+		if (cpumask_parse(buf, set, setsize))
+			errx(EXIT_FAILURE, _("failed to parse CPU mask %s"), buf);
+	}
+	return set;
+}
+
+cpu_set_t *
+path_cpuset(int maxcpus, const char *path, ...)
+{
+	va_list ap;
+	cpu_set_t *set;
+
+	va_start(ap, path);
+	set = path_cpuparse(maxcpus, 0, path, ap);
+	va_end(ap);
+
+	return set;
+}
+
+cpu_set_t *
+path_cpulist(int maxcpus, const char *path, ...)
+{
+	va_list ap;
+	cpu_set_t *set;
+
+	va_start(ap, path);
+	set = path_cpuparse(maxcpus, 1, path, ap);
+	va_end(ap);
+
+	return set;
+}
+
+void
+path_setprefix(const char *prefix)
+{
+	prefixlen = strlen(prefix);
+	strncpy(pathbuf, prefix, sizeof(pathbuf));
+	pathbuf[sizeof(pathbuf) - 1] = '\0';
+}
diff -up util-linux-ng-2.17.2/lib/strutils.c.base util-linux-ng-2.17.2/lib/strutils.c
--- util-linux-ng-2.17.2/lib/strutils.c.base	2012-10-08 12:03:34.860028226 +0200
+++ util-linux-ng-2.17.2/lib/strutils.c	2012-10-08 12:03:34.860028226 +0200
@@ -0,0 +1,698 @@
+/*
+ * Copyright (C) 2010 Karel Zak <kzak@redhat.com>
+ * Copyright (C) 2010 Davidlohr Bueso <dave@gnu.org>
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <inttypes.h>
+#include <ctype.h>
+#include <errno.h>
+#include <sys/stat.h>
+#include <string.h>
+#include <err.h>
+
+#include "c.h"
+#include "nls.h"
+#include "strutils.h"
+#include "bitops.h"
+
+
+static int do_scale_by_power (uintmax_t *x, int base, int power)
+{
+	while (power--) {
+		if (UINTMAX_MAX / base < *x)
+			return -2;
+		*x *= base;
+	}
+	return 0;
+}
+
+/*
+ * strtosize() - convert string to size (uintmax_t).
+ *
+ * Supported suffixes:
+ *
+ * XiB or X for 2^N
+ *     where X = {K,M,G,T,P,E,Y,Z}
+ *        or X = {k,m,g,t,p,e}  (undocumented for backward compatibility only)
+ * for example:
+ *		10KiB	= 10240
+ *		10K	= 10240
+ *
+ * XB for 10^N
+ *     where X = {K,M,G,T,P,E,Y,Z}
+ * for example:
+ *		10KB	= 10000
+ *
+ * Note that the function does not accept numbers with '-' (negative sign)
+ * prefix.
+ */
+int strtosize(const char *str, uintmax_t *res)
+{
+	char *p;
+	uintmax_t x;
+	int base = 1024, rc = 0;
+
+	*res = 0;
+
+	if (!str || !*str)
+		goto err;
+
+	/* Only positive numbers are acceptable
+	 *
+	 * Note that this check is not perfect, it would be better to
+	 * use lconv->negative_sign. But coreutils use the same solution,
+	 * so it's probably good enough...
+	 */
+	p = (char *) str;
+	while (isspace((unsigned char) *p))
+		p++;
+	if (*p == '-')
+		goto err;
+	p = NULL;
+
+	errno = 0;
+	x = strtoumax(str, &p, 0);
+
+	if (p == str ||
+	    (errno != 0 && (x == UINTMAX_MAX || x == 0)))
+		goto err;
+
+	if (!p || !*p)
+		goto done;			/* without suffix */
+
+	/*
+	 * Check size suffixes
+	 */
+	if (*(p + 1) == 'i' && *(p + 2) == 'B' && !*(p + 3))
+		base = 1024;			/* XiB, 2^N */
+	else if (*(p + 1) == 'B' && !*(p + 2))
+		base = 1000;			/* XB, 10^N */
+	else if (*(p + 1))
+		goto err;			/* unexpected suffix */
+
+	switch(*p) {
+	case 'K':
+	case 'k':
+		rc = do_scale_by_power(&x, base, 1);
+		break;
+	case 'M':
+	case 'm':
+		rc = do_scale_by_power(&x, base, 2);
+		break;
+	case 'G':
+	case 'g':
+		rc = do_scale_by_power(&x, base, 3);
+		break;
+	case 'T':
+	case 't':
+		rc = do_scale_by_power(&x, base, 4);
+		break;
+	case 'P':
+	case 'p':
+		rc = do_scale_by_power(&x, base, 5);
+		break;
+	case 'E':
+	case 'e':
+		rc = do_scale_by_power(&x, base, 6);
+		break;
+	case 'Z':
+		rc = do_scale_by_power(&x, base, 7);
+		break;
+	case 'Y':
+		rc = do_scale_by_power(&x, base, 8);
+		break;
+	default:
+		goto err;
+	}
+
+done:
+	*res = x;
+	return rc;
+err:
+	return -1;
+}
+
+#ifndef HAVE_STRNLEN
+size_t strnlen(const char *s, size_t maxlen)
+{
+        int i;
+
+        for (i = 0; i < maxlen; i++) {
+                if (s[i] == '\0')
+                        return i + 1;
+        }
+        return maxlen;
+}
+#endif
+
+#ifndef HAVE_STRNCHR
+char *strnchr(const char *s, size_t maxlen, int c)
+{
+	for (; maxlen-- && *s != '\0'; ++s)
+		if (*s == (char)c)
+			return (char *)s;
+	return NULL;
+}
+#endif
+
+#ifndef HAVE_STRNDUP
+char *strndup(const char *s, size_t n)
+{
+	size_t len = strnlen(s, n);
+	char *new = (char *) malloc((len + 1) * sizeof(char));
+	if (!new)
+		return NULL;
+	new[len] = '\0';
+	return (char *) memcpy(new, s, len);
+}
+#endif
+
+int16_t strtos16_or_err(const char *str, const char *errmesg)
+{
+	int32_t num = strtos32_or_err(str, errmesg);
+
+	if (num < INT16_MIN || num > INT16_MAX)
+		errx(STRTOXX_EXIT_CODE, "%s: '%s'", errmesg, str);
+
+	return num;
+}
+
+uint16_t strtou16_or_err(const char *str, const char *errmesg)
+{
+	uint32_t num = strtou32_or_err(str, errmesg);
+
+	if (num > UINT16_MAX)
+		errx(STRTOXX_EXIT_CODE, "%s: '%s'", errmesg, str);
+
+	return num;
+}
+
+int32_t strtos32_or_err(const char *str, const char *errmesg)
+{
+	int64_t num = strtos64_or_err(str, errmesg);
+
+	if (num < INT32_MIN || num > INT32_MAX)
+		errx(STRTOXX_EXIT_CODE, "%s: '%s'", errmesg, str);
+
+	return num;
+}
+
+uint32_t strtou32_or_err(const char *str, const char *errmesg)
+{
+	uint64_t num = strtou64_or_err(str, errmesg);
+
+	if (num > UINT32_MAX)
+		errx(STRTOXX_EXIT_CODE, "%s: '%s'", errmesg, str);
+
+	return num;
+}
+
+int64_t strtos64_or_err(const char *str, const char *errmesg)
+{
+	int64_t num;
+	char *end = NULL;
+
+	if (str == NULL || *str == '\0')
+		goto err;
+	errno = 0;
+	num = strtoimax(str, &end, 10);
+
+	if (errno || str == end || (end && *end))
+		goto err;
+
+	return num;
+err:
+	if (errno)
+		err(STRTOXX_EXIT_CODE, "%s: '%s'", errmesg, str);
+
+	errx(STRTOXX_EXIT_CODE, "%s: '%s'", errmesg, str);
+}
+
+uint64_t strtou64_or_err(const char *str, const char *errmesg)
+{
+	uintmax_t num;
+	char *end = NULL;
+
+	if (str == NULL || *str == '\0')
+		goto err;
+	errno = 0;
+	num = strtoumax(str, &end, 10);
+
+	if (errno || str == end || (end && *end))
+		goto err;
+
+	return num;
+err:
+	if (errno)
+		err(STRTOXX_EXIT_CODE, "%s: '%s'", errmesg, str);
+
+	errx(STRTOXX_EXIT_CODE, "%s: '%s'", errmesg, str);
+}
+
+
+double strtod_or_err(const char *str, const char *errmesg)
+{
+	double num;
+	char *end = NULL;
+
+	if (str == NULL || *str == '\0')
+		goto err;
+	errno = 0;
+	num = strtod(str, &end);
+
+	if (errno || str == end || (end && *end))
+		goto err;
+
+	return num;
+err:
+	if (errno)
+		err(STRTOXX_EXIT_CODE, "%s: '%s'", errmesg, str);
+
+	errx(STRTOXX_EXIT_CODE, "%s: '%s'", errmesg, str);
+}
+
+long strtol_or_err(const char *str, const char *errmesg)
+{
+	long num;
+	char *end = NULL;
+
+	if (str == NULL || *str == '\0')
+		goto err;
+	errno = 0;
+	num = strtol(str, &end, 10);
+
+	if (errno || str == end || (end && *end))
+		goto err;
+
+	return num;
+err:
+	if (errno)
+		err(STRTOXX_EXIT_CODE, "%s: '%s'", errmesg, str);
+	errx(STRTOXX_EXIT_CODE, "%s: '%s'", errmesg, str);
+}
+
+unsigned long strtoul_or_err(const char *str, const char *errmesg)
+{
+	unsigned long num;
+	char *end = NULL;
+
+	if (str == NULL || *str == '\0')
+		goto err;
+	errno = 0;
+	num = strtoul(str, &end, 10);
+
+	if (errno || str == end || (end && *end))
+		goto err;
+
+	return num;
+err:
+	if (errno)
+		err(STRTOXX_EXIT_CODE, "%s: '%s'", errmesg, str);
+
+	errx(STRTOXX_EXIT_CODE, "%s: '%s'", errmesg, str);
+}
+
+uintmax_t strtosize_or_err(const char *str, const char *errmesg)
+{
+	uintmax_t num;
+
+	if (strtosize(str, &num) == 0)
+		return num;
+
+	if (errno)
+		err(STRTOXX_EXIT_CODE, "%s: '%s'", errmesg, str);
+
+	errx(STRTOXX_EXIT_CODE, "%s: '%s'", errmesg, str);
+}
+
+/*
+ * Converts stat->st_mode to ls(1)-like mode string. The size of "str" must
+ * be 10 bytes.
+ */
+void strmode(mode_t mode, char *str)
+{
+	if (S_ISDIR(mode))
+		str[0] = 'd';
+	else if (S_ISLNK(mode))
+		str[0] = 'l';
+	else if (S_ISCHR(mode))
+		str[0] = 'c';
+	else if (S_ISBLK(mode))
+		str[0] = 'b';
+	else if (S_ISSOCK(mode))
+		str[0] = 's';
+	else if (S_ISFIFO(mode))
+		str[0] = 'p';
+	else if (S_ISREG(mode))
+		str[0] = '-';
+
+	str[1] = mode & S_IRUSR ? 'r' : '-';
+	str[2] = mode & S_IWUSR ? 'w' : '-';
+	str[3] = (mode & S_ISUID
+		? (mode & S_IXUSR ? 's' : 'S')
+		: (mode & S_IXUSR ? 'x' : '-'));
+	str[4] = mode & S_IRGRP ? 'r' : '-';
+	str[5] = mode & S_IWGRP ? 'w' : '-';
+	str[6] = (mode & S_ISGID
+		? (mode & S_IXGRP ? 's' : 'S')
+		: (mode & S_IXGRP ? 'x' : '-'));
+	str[7] = mode & S_IROTH ? 'r' : '-';
+	str[8] = mode & S_IWOTH ? 'w' : '-';
+	str[9] = (mode & S_ISVTX
+		? (mode & S_IXOTH ? 't' : 'T')
+		: (mode & S_IXOTH ? 'x' : '-'));
+	str[10] = '\0';
+}
+
+/*
+ * returns exponent (2^x=n) in range KiB..PiB
+ */
+static int get_exp(uint64_t n)
+{
+	int shft;
+
+	for (shft = 10; shft <= 60; shft += 10) {
+		if (n < (1ULL << shft))
+			break;
+	}
+	return shft - 10;
+}
+
+char *size_to_human_string(int options, uint64_t bytes)
+{
+	char buf[32];
+	int dec, exp;
+	uint64_t frac;
+	const char *letters = "BKMGTPE";
+	char suffix[sizeof(" KiB")], *psuf = suffix;
+	char c;
+
+	if (options & SIZE_SUFFIX_SPACE)
+		*psuf++ = ' ';
+
+	exp  = get_exp(bytes);
+	c    = *(letters + (exp ? exp / 10 : 0));
+	dec  = exp ? bytes / (1ULL << exp) : bytes;
+	frac = exp ? bytes % (1ULL << exp) : 0;
+
+	*psuf++ = c;
+
+	if ((options & SIZE_SUFFIX_3LETTER) && (c != 'B')) {
+		*psuf++ = 'i';
+		*psuf++ = 'B';
+	}
+
+	*psuf = '\0';
+
+	/* fprintf(stderr, "exp: %d, unit: %c, dec: %d, frac: %jd\n",
+	 *                 exp, suffix[0], dec, frac);
+	 */
+
+	if (frac) {
+		/* round */
+		frac = (frac / (1ULL << (exp - 10)) + 50) / 100;
+		if (frac == 10)
+			dec++, frac = 0;
+	}
+
+	if (frac) {
+		struct lconv const *l = localeconv();
+		char *dp = l ? l->decimal_point : NULL;
+
+		if (!dp || !*dp)
+			dp = ".";
+		snprintf(buf, sizeof(buf), "%d%s%jd%s", dec, dp, frac, suffix);
+	} else
+		snprintf(buf, sizeof(buf), "%d%s", dec, suffix);
+
+	return strdup(buf);
+}
+
+/*
+ * Parses comma delimited list to array with IDs, for example:
+ *
+ * "aaa,bbb,ccc" --> ary[0] = FOO_AAA;
+ *                   ary[1] = FOO_BBB;
+ *                   ary[3] = FOO_CCC;
+ *
+ * The function name2id() provides conversion from string to ID.
+ *
+ * Returns: >= 0  : number of items added to ary[]
+ *            -1  : parse error or unknown item
+ *            -2  : arysz reached
+ */
+int string_to_idarray(const char *list, int ary[], size_t arysz,
+			int (name2id)(const char *, size_t))
+{
+	const char *begin = NULL, *p;
+	size_t n = 0;
+
+	if (!list || !*list || !ary || !arysz || !name2id)
+		return -1;
+
+	for (p = list; p && *p; p++) {
+		const char *end = NULL;
+		int id;
+
+		if (n >= arysz)
+			return -2;
+		if (!begin)
+			begin = p;		/* begin of the column name */
+		if (*p == ',')
+			end = p;		/* terminate the name */
+		if (*(p + 1) == '\0')
+			end = p + 1;		/* end of string */
+		if (!begin || !end)
+			continue;
+		if (end <= begin)
+			return -1;
+
+		id = name2id(begin, end - begin);
+		if (id == -1)
+			return -1;
+		ary[ n++ ] = id;
+		begin = NULL;
+		if (end && !*end)
+			break;
+	}
+	return n;
+}
+
+/*
+ * Parses the array like string_to_idarray but if format is "+aaa,bbb"
+ * it adds fields to array instead of replacing them.
+ */
+int string_add_to_idarray(const char *list, int ary[], size_t arysz,
+			int *ary_pos, int (name2id)(const char *, size_t))
+{
+	const char *list_add;
+	int r;
+
+	if (!list || !*list || !ary_pos ||
+	    *ary_pos < 0 || (size_t) *ary_pos > arysz)
+		return -1;
+
+	if (list[0] == '+')
+		list_add = &list[1];
+	else {
+		list_add = list;
+		*ary_pos = 0;
+	}
+
+	r = string_to_idarray(list_add, &ary[*ary_pos], arysz - *ary_pos, name2id);
+	if (r > 0)
+		*ary_pos += r;
+	return r;
+}
+
+/*
+ * LIST ::= <item> [, <item>]
+ *
+ * The <item> is translated to 'id' by name2id() function and the 'id' is used
+ * as a position in the 'ary' bit array. It means that the 'id' has to be in
+ * range <0..N> where N < sizeof(ary) * NBBY.
+ *
+ * Returns: 0 on success, <0 on error.
+ */
+int string_to_bitarray(const char *list,
+		     char *ary,
+		     int (*name2bit)(const char *, size_t))
+{
+	const char *begin = NULL, *p;
+
+	if (!list || !name2bit || !ary)
+		return -EINVAL;
+
+	for (p = list; p && *p; p++) {
+		const char *end = NULL;
+		int bit;
+
+		if (!begin)
+			begin = p;		/* begin of the level name */
+		if (*p == ',')
+			end = p;		/* terminate the name */
+		if (*(p + 1) == '\0')
+			end = p + 1;		/* end of string */
+		if (!begin || !end)
+			continue;
+		if (end <= begin)
+			return -1;
+
+		bit = name2bit(begin, end - begin);
+		if (bit < 0)
+			return bit;
+		setbit(ary, bit);
+		begin = NULL;
+		if (end && !*end)
+			break;
+	}
+	return 0;
+}
+
+/*
+ * LIST ::= <item> [, <item>]
+ *
+ * The <item> is translated to 'id' by name2flag() function and the flags is
+ * set to the 'mask'
+*
+ * Returns: 0 on success, <0 on error.
+ */
+int string_to_bitmask(const char *list,
+		     unsigned long *mask,
+		     long (*name2flag)(const char *, size_t))
+{
+	const char *begin = NULL, *p;
+
+	if (!list || !name2flag || !mask)
+		return -EINVAL;
+
+	for (p = list; p && *p; p++) {
+		const char *end = NULL;
+		long flag;
+
+		if (!begin)
+			begin = p;		/* begin of the level name */
+		if (*p == ',')
+			end = p;		/* terminate the name */
+		if (*(p + 1) == '\0')
+			end = p + 1;		/* end of string */
+		if (!begin || !end)
+			continue;
+		if (end <= begin)
+			return -1;
+
+		flag = name2flag(begin, end - begin);
+		if (flag < 0)
+			return flag;	/* error */
+		*mask |= flag;
+		begin = NULL;
+		if (end && !*end)
+			break;
+	}
+	return 0;
+}
+
+/*
+ * Parse the lower and higher values in a string containing
+ * "lower:higher" or "lower-higher" format. Note that either
+ * the lower or the higher values may be missing, and the def
+ * value will be assigned to it by default.
+ *
+ * Returns: 0 on success, <0 on error.
+ */
+int parse_range(const char *str, int *lower, int *upper, int def)
+{
+	char *end = NULL;
+
+	if (!str)
+		return 0;
+
+	*upper = *lower = def;
+	errno = 0;
+
+	if (*str == ':') {				/* <:N> */
+		str++;
+		*upper = strtol(str, &end, 10);
+		if (errno || !end || *end || end == str)
+			return -1;
+	} else {
+		*upper = *lower = strtol(str, &end, 10);
+		if (errno || !end || end == str)
+			return -1;
+
+		if (*end == ':' && !*(end + 1))		/* <M:> */
+			*upper = 0;
+		else if (*end == '-' || *end == ':') {	/* <M:N> <M-N> */
+			str = end + 1;
+			end = NULL;
+			errno = 0;
+			*upper = strtol(str, &end, 10);
+
+			if (errno || !end || *end || end == str)
+				return -1;
+		}
+	}
+	return 0;
+}
+
+/*
+ * Compare two strings for equality, ignoring at most one trailing
+ * slash.
+ */
+int streq_except_trailing_slash(const char *s1, const char *s2)
+{
+	int equal;
+
+	if (!s1 && !s2)
+		return 1;
+	if (!s1 || !s2)
+		return 0;
+
+	equal = !strcmp(s1, s2);
+
+	if (!equal) {
+		size_t len1 = strlen(s1);
+		size_t len2 = strlen(s2);
+
+		if (len1 && *(s1 + len1 - 1) == '/')
+			len1--;
+		if (len2 && *(s2 + len2 - 1) == '/')
+			len2--;
+		if (len1 != len2)
+			return 0;
+
+		equal = !strncmp(s1, s2, len1);
+	}
+
+	return equal;
+}
+
+
+#ifdef TEST_PROGRAM
+
+int main(int argc, char *argv[])
+{
+	uintmax_t size = 0;
+	char *hum, *hum2;
+
+	if (argc < 2) {
+		fprintf(stderr, "usage: %s <number>[suffix]\n",	argv[0]);
+		exit(EXIT_FAILURE);
+	}
+
+	if (strtosize(argv[1], &size))
+		errx(EXIT_FAILURE, "invalid size '%s' value", argv[1]);
+
+	hum = size_to_human_string(SIZE_SUFFIX_1LETTER, size);
+	hum2 = size_to_human_string(SIZE_SUFFIX_3LETTER |
+				    SIZE_SUFFIX_SPACE, size);
+
+	printf("%25s : %20ju : %8s : %12s\n", argv[1], size, hum, hum2);
+	free(hum);
+	free(hum2);
+
+	return EXIT_SUCCESS;
+}
+#endif /* TEST_PROGRAM */
diff -up util-linux-ng-2.17.2/lib/sysfs.c.base util-linux-ng-2.17.2/lib/sysfs.c
--- util-linux-ng-2.17.2/lib/sysfs.c.base	2012-10-08 12:03:34.860028226 +0200
+++ util-linux-ng-2.17.2/lib/sysfs.c	2012-10-08 12:03:34.860028226 +0200
@@ -0,0 +1,708 @@
+/*
+ * Copyright (C) 2011 Karel Zak <kzak@redhat.com>
+ */
+
+#include <ctype.h>
+#include <errno.h>
+#include <stdarg.h>
+
+#include "c.h"
+#include "at.h"
+#include "pathnames.h"
+#include "sysfs.h"
+
+char *sysfs_devno_attribute_path(dev_t devno, char *buf,
+				 size_t bufsiz, const char *attr)
+{
+	int len;
+
+	if (attr)
+		len = snprintf(buf, bufsiz, _PATH_SYS_DEVBLOCK "/%d:%d/%s",
+			major(devno), minor(devno), attr);
+	else
+		len = snprintf(buf, bufsiz, _PATH_SYS_DEVBLOCK "/%d:%d",
+			major(devno), minor(devno));
+
+	return (len < 0 || (size_t) len + 1 > bufsiz) ? NULL : buf;
+}
+
+int sysfs_devno_has_attribute(dev_t devno, const char *attr)
+{
+	char path[PATH_MAX];
+	struct stat info;
+
+	if (!sysfs_devno_attribute_path(devno, path, sizeof(path), attr))
+		return 0;
+	if (stat(path, &info) == 0)
+		return 1;
+	return 0;
+}
+
+char *sysfs_devno_path(dev_t devno, char *buf, size_t bufsiz)
+{
+	return sysfs_devno_attribute_path(devno, buf, bufsiz, NULL);
+}
+
+dev_t sysfs_devname_to_devno(const char *name, const char *parent)
+{
+	char buf[PATH_MAX], *path = NULL;
+	dev_t dev = 0;
+
+	if (strncmp("/dev/", name, 5) == 0) {
+		/*
+		 * Read from /dev
+		 */
+		struct stat st;
+
+		if (stat(name, &st) == 0)
+			dev = st.st_rdev;
+		else
+			name += 5;	/* unaccesible, or not node in /dev */
+	}
+
+	if (!dev && parent && strncmp("dm-", name, 3)) {
+		/*
+		 * Create path to /sys/block/<parent>/<name>/dev
+		 */
+		int len = snprintf(buf, sizeof(buf),
+				_PATH_SYS_BLOCK "/%s/%s/dev", parent, name);
+		if (len < 0 || (size_t) len + 1 > sizeof(buf))
+			return 0;
+		path = buf;
+
+	} else if (!dev) {
+		/*
+		 * Create path to /sys/block/<name>/dev
+		 */
+		int len = snprintf(buf, sizeof(buf),
+				_PATH_SYS_BLOCK "/%s/dev", name);
+		if (len < 0 || (size_t) len + 1 > sizeof(buf))
+			return 0;
+		path = buf;
+	}
+
+	if (path) {
+		/*
+		 * read devno from sysfs
+		 */
+		FILE *f;
+		int maj = 0, min = 0;
+
+		f = fopen(path, "r");
+		if (!f)
+			return 0;
+
+		if (fscanf(f, "%d:%d", &maj, &min) == 2)
+			dev = makedev(maj, min);
+		fclose(f);
+	}
+	return dev;
+}
+
+/*
+ * Returns devname (e.g. "/dev/sda1") for the given devno.
+ *
+ * Note that the @buf has to be large enough to store /sys/dev/block/<maj:min>
+ * symlinks.
+ *
+ * Please, use more robust blkid_devno_to_devname() in your applications.
+ */
+char *sysfs_devno_to_devpath(dev_t devno, char *buf, size_t bufsiz)
+{
+	struct sysfs_cxt cxt;
+	char *name;
+	size_t sz;
+	struct stat st;
+
+	if (sysfs_init(&cxt, devno, NULL))
+		return NULL;
+
+	name = sysfs_get_devname(&cxt, buf, bufsiz);
+	sysfs_deinit(&cxt);
+
+	if (!name)
+		return NULL;
+
+	sz = strlen(name);
+
+	if (sz + sizeof("/dev/") > bufsiz)
+		return NULL;
+
+	/* create the final "/dev/<name>" string */
+	memmove(buf + 5, name, sz + 1);
+	memcpy(buf, "/dev/", 5);
+
+	if (!stat(buf, &st) && S_ISBLK(st.st_mode) && st.st_rdev == devno)
+		return buf;
+
+	return NULL;
+}
+
+int sysfs_init(struct sysfs_cxt *cxt, dev_t devno, struct sysfs_cxt *parent)
+{
+	char path[PATH_MAX];
+	int fd, rc;
+
+	memset(cxt, 0, sizeof(*cxt));
+	cxt->dir_fd = -1;
+
+	if (!sysfs_devno_path(devno, path, sizeof(path)))
+		goto err;
+
+	fd = open(path, O_RDONLY);
+	if (fd < 0)
+		goto err;
+	cxt->dir_fd = fd;
+
+	cxt->dir_path = strdup(path);
+	if (!cxt->dir_path)
+		goto err;
+	cxt->devno = devno;
+	cxt->parent = parent;
+	return 0;
+err:
+	rc = errno > 0 ? -errno : -1;
+	sysfs_deinit(cxt);
+	return rc;
+}
+
+void sysfs_deinit(struct sysfs_cxt *cxt)
+{
+	if (!cxt)
+		return;
+
+	if (cxt->dir_fd >= 0)
+	       close(cxt->dir_fd);
+	free(cxt->dir_path);
+
+	cxt->devno = 0;
+	cxt->dir_fd = -1;
+	cxt->parent = NULL;
+	cxt->dir_path = NULL;
+}
+
+int sysfs_stat(struct sysfs_cxt *cxt, const char *attr, struct stat *st)
+{
+	int rc = fstat_at(cxt->dir_fd, cxt->dir_path, attr, st, 0);
+
+	if (rc != 0 && errno == ENOENT &&
+	    strncmp(attr, "queue/", 6) == 0 && cxt->parent) {
+
+		/* Exception for "queue/<attr>". These attributes are available
+		 * for parental devices only
+		 */
+		return fstat_at(cxt->parent->dir_fd,
+				cxt->parent->dir_path, attr, st, 0);
+	}
+	return rc;
+}
+
+int sysfs_has_attribute(struct sysfs_cxt *cxt, const char *attr)
+{
+	struct stat st;
+
+	return sysfs_stat(cxt, attr, &st) == 0;
+}
+
+static int sysfs_open(struct sysfs_cxt *cxt, const char *attr)
+{
+	int fd = open_at(cxt->dir_fd, cxt->dir_path, attr, O_RDONLY);
+
+	if (fd == -1 && errno == ENOENT &&
+	    strncmp(attr, "queue/", 6) == 0 && cxt->parent) {
+
+		/* Exception for "queue/<attr>". These attributes are available
+		 * for parental devices only
+		 */
+		fd = open_at(cxt->parent->dir_fd, cxt->dir_path, attr, O_RDONLY);
+	}
+	return fd;
+}
+
+ssize_t sysfs_readlink(struct sysfs_cxt *cxt, const char *attr,
+		   char *buf, size_t bufsiz)
+{
+	if (!cxt->dir_path)
+		return -1;
+
+	if (attr)
+		return readlink_at(cxt->dir_fd, cxt->dir_path, attr, buf, bufsiz);
+
+	/* read /sys/dev/block/<maj:min> link */
+	return readlink(cxt->dir_path, buf, bufsiz);
+}
+
+DIR *sysfs_opendir(struct sysfs_cxt *cxt, const char *attr)
+{
+	DIR *dir;
+	int fd = -1;
+
+	if (attr)
+		fd = sysfs_open(cxt, attr);
+
+	else if (cxt->dir_fd >= 0)
+		/* request to open root of device in sysfs (/sys/block/<dev>)
+		 * -- we cannot use cxt->sysfs_fd directly, because closedir()
+		 * will close this our persistent file descriptor.
+		 */
+		fd = dup(cxt->dir_fd);
+
+	if (fd < 0)
+		return NULL;
+
+	dir = fdopendir(fd);
+	if (!dir) {
+		close(fd);
+		return NULL;
+	}
+	if (!attr)
+		 rewinddir(dir);
+	return dir;
+}
+
+
+static FILE *sysfs_fopen(struct sysfs_cxt *cxt, const char *attr)
+{
+	int fd = sysfs_open(cxt, attr);
+
+	return fd < 0 ? NULL : fdopen(fd, "r");
+}
+
+
+static struct dirent *xreaddir(DIR *dp)
+{
+	struct dirent *d;
+
+	while ((d = readdir(dp))) {
+		if (!strcmp(d->d_name, ".") ||
+		    !strcmp(d->d_name, ".."))
+			continue;
+
+		/* blacklist here? */
+		break;
+	}
+	return d;
+}
+
+int sysfs_is_partition_dirent(DIR *dir, struct dirent *d, const char *parent_name)
+{
+	char path[256];
+
+#ifdef _DIRENT_HAVE_D_TYPE
+	if (d->d_type != DT_DIR &&
+	    d->d_type != DT_LNK)
+		return 0;
+#endif
+	if (parent_name) {
+		const char *p = parent_name;
+		size_t len;
+
+		/* /dev/sda --> "sda" */
+		if (*parent_name == '/') {
+			p = strrchr(parent_name, '/');
+			if (!p)
+				return 0;
+			p++;
+		}
+
+		len = strlen(p);
+		if (strlen(d->d_name) <= len)
+			return 0;
+
+		/* partitions subdir name is
+		 *	"<parent>[:digit:]" or "<parent>p[:digit:]"
+		 */
+		return strncmp(p, d->d_name, len) == 0 &&
+		       ((*(d->d_name + len) == 'p' && isdigit(*(d->d_name + len + 1)))
+			|| isdigit(*(d->d_name + len)));
+	}
+
+	/* Cannot use /partition file, not supported on old sysfs */
+	snprintf(path, sizeof(path), "%s/start", d->d_name);
+
+	return faccessat(dirfd(dir), path, R_OK, 0) == 0;
+}
+
+/*
+ * Converts @partno (partition number) to devno of the partition.
+ * The @cxt handles wholedisk device.
+ *
+ * Note that this code does not expect any special format of the
+ * partitions devnames.
+ */
+dev_t sysfs_partno_to_devno(struct sysfs_cxt *cxt, int partno)
+{
+	DIR *dir;
+	struct dirent *d;
+	char path[256];
+	dev_t devno = 0;
+
+	dir = sysfs_opendir(cxt, NULL);
+	if (!dir)
+		return 0;
+
+	while ((d = xreaddir(dir))) {
+		int n, maj, min;
+
+		if (!sysfs_is_partition_dirent(dir, d, NULL))
+			continue;
+
+		snprintf(path, sizeof(path), "%s/partition", d->d_name);
+		if (sysfs_read_int(cxt, path, &n))
+			continue;
+
+		if (n == partno) {
+			snprintf(path, sizeof(path), "%s/dev", d->d_name);
+			if (sysfs_scanf(cxt, path, "%d:%d", &maj, &min) == 2)
+				devno = makedev(maj, min);
+			break;
+		}
+	}
+
+	closedir(dir);
+	return devno;
+}
+
+
+int sysfs_scanf(struct sysfs_cxt *cxt,  const char *attr, const char *fmt, ...)
+{
+	FILE *f = sysfs_fopen(cxt, attr);
+	va_list ap;
+	int rc;
+
+	if (!f)
+		return -EINVAL;
+	va_start(ap, fmt);
+	rc = vfscanf(f, fmt, ap);
+	va_end(ap);
+
+	fclose(f);
+	return rc;
+}
+
+
+int sysfs_read_s64(struct sysfs_cxt *cxt, const char *attr, int64_t *res)
+{
+	int64_t x = 0;
+
+	if (sysfs_scanf(cxt, attr, "%"SCNd64, &x) == 1) {
+		if (res)
+			*res = x;
+		return 0;
+	}
+	return -1;
+}
+
+int sysfs_read_u64(struct sysfs_cxt *cxt, const char *attr, uint64_t *res)
+{
+	uint64_t x = 0;
+
+	if (sysfs_scanf(cxt, attr, "%"SCNu64, &x) == 1) {
+		if (res)
+			*res = x;
+		return 0;
+	}
+	return -1;
+}
+
+int sysfs_read_int(struct sysfs_cxt *cxt, const char *attr, int *res)
+{
+	int x = 0;
+
+	if (sysfs_scanf(cxt, attr, "%d", &x) == 1) {
+		if (res)
+			*res = x;
+		return 0;
+	}
+	return -1;
+}
+
+char *sysfs_strdup(struct sysfs_cxt *cxt, const char *attr)
+{
+	char buf[1024];
+	return sysfs_scanf(cxt, attr, "%1023[^\n]", buf) == 1 ?
+						strdup(buf) : NULL;
+}
+
+int sysfs_count_dirents(struct sysfs_cxt *cxt, const char *attr)
+{
+	DIR *dir;
+	int r = 0;
+
+	if (!(dir = sysfs_opendir(cxt, attr)))
+		return 0;
+
+	while (xreaddir(dir)) r++;
+
+	closedir(dir);
+	return r;
+}
+
+int sysfs_count_partitions(struct sysfs_cxt *cxt, const char *devname)
+{
+	DIR *dir;
+	struct dirent *d;
+	int r = 0;
+
+	if (!(dir = sysfs_opendir(cxt, NULL)))
+		return 0;
+
+	while ((d = xreaddir(dir))) {
+		if (sysfs_is_partition_dirent(dir, d, devname))
+			r++;
+	}
+
+	closedir(dir);
+	return r;
+}
+
+/*
+ * Returns slave name if there is only one slave, otherwise returns NULL.
+ * The result should be deallocated by free().
+ */
+char *sysfs_get_slave(struct sysfs_cxt *cxt)
+{
+	DIR *dir;
+	struct dirent *d;
+	char *name = NULL;
+
+	if (!(dir = sysfs_opendir(cxt, "slaves")))
+		return NULL;
+
+	while ((d = xreaddir(dir))) {
+		if (name)
+			goto err;	/* more slaves */
+
+		name = strdup(d->d_name);
+	}
+
+	closedir(dir);
+	return name;
+err:
+	free(name);
+	closedir(dir);
+	return NULL;
+}
+
+/*
+ * Note that the @buf has to be large enough to store /sys/dev/block/<maj:min>
+ * symlinks.
+ */
+char *sysfs_get_devname(struct sysfs_cxt *cxt, char *buf, size_t bufsiz)
+{
+	char *name = NULL;
+	ssize_t sz;
+
+	sz = sysfs_readlink(cxt, NULL, buf, bufsiz - 1);
+	if (sz < 0)
+		return NULL;
+
+	buf[sz] = '\0';
+	name = strrchr(buf, '/');
+	if (!name)
+		return NULL;
+
+	name++;
+	sz = strlen(name);
+
+	memmove(buf, name, sz + 1);
+	return buf;
+}
+
+/* returns basename and keeps dirname in the @path */
+static char *stripoff_last_component(char *path)
+{
+    char *p = strrchr(path, '/');
+
+    if (!p)
+        return NULL;
+    *p = '\0';
+    return ++p;
+}
+
+static int get_dm_wholedisk(struct sysfs_cxt *cxt, char *diskname,
+                size_t len, dev_t *diskdevno)
+{
+    int rc = 0;
+    char *name;
+
+    /* Note, sysfs_get_slave() returns the first slave only,
+     * if there is more slaves, then return NULL
+     */
+    name = sysfs_get_slave(cxt);
+    if (!name)
+        return -1;
+
+    if (diskname && len) {
+        strncpy(diskname, name, len);
+        diskname[len - 1] = '\0';
+    }
+
+    if (diskdevno) {
+        *diskdevno = sysfs_devname_to_devno(name, NULL);
+        if (!*diskdevno)
+            rc = -1;
+    }
+
+    free(name);
+    return rc;
+}
+
+int sysfs_devno_to_wholedisk(dev_t dev, char *diskname,
+            size_t len, dev_t *diskdevno)
+{
+    struct sysfs_cxt cxt;
+    int is_part = 0;
+
+    if (!dev || sysfs_init(&cxt, dev, NULL) != 0)
+        return -1;
+
+    is_part = sysfs_has_attribute(&cxt, "partition");
+    if (!is_part) {
+        /*
+         * Extra case for partitions mapped by device-mapper.
+         *
+         * All regualar partitions (added by BLKPG ioctl or kernel PT
+         * parser) have the /sys/.../partition file. The partitions
+         * mapped by DM don't have such file, but they have "part"
+         * prefix in DM UUID.
+         */
+        char *uuid = sysfs_strdup(&cxt, "dm/uuid");
+        char *tmp = uuid;
+        char *prefix = uuid ? strsep(&tmp, "-") : NULL;
+
+        if (prefix && strncasecmp(prefix, "part", 4) == 0)
+            is_part = 1;
+        free(uuid);
+
+        if (is_part &&
+            get_dm_wholedisk(&cxt, diskname, len, diskdevno) == 0)
+            /*
+             * partitioned device, mapped by DM
+             */
+            goto done;
+
+        is_part = 0;
+    }
+
+    if (!is_part) {
+        /*
+         * unpartitioned device
+         */
+        if (diskname && len) {
+            if (!sysfs_get_devname(&cxt, diskname, len))
+                goto err;
+        }
+        if (diskdevno)
+            *diskdevno = dev;
+
+    } else {
+        /*
+         * partitioned device
+         *  - readlink /sys/dev/block/8:1   = ../../block/sda/sda1
+         *  - dirname  ../../block/sda/sda1 = ../../block/sda
+         *  - basename ../../block/sda      = sda
+         */
+        char linkpath[PATH_MAX];
+        char *name;
+        int linklen;
+
+        linklen = sysfs_readlink(&cxt, NULL,
+                linkpath, sizeof(linkpath) - 1);
+        if (linklen < 0)
+            goto err;
+        linkpath[linklen] = '\0';
+
+        stripoff_last_component(linkpath);      /* dirname */
+        name = stripoff_last_component(linkpath);   /* basename */
+        if (!name)
+            goto err;
+
+        if (diskname && len) {
+            strncpy(diskname, name, len);
+            diskname[len - 1] = '\0';
+        }
+
+        if (diskdevno) {
+            *diskdevno = sysfs_devname_to_devno(name, NULL);
+            if (!*diskdevno)
+                goto err;
+        }
+    }
+
+done:
+    sysfs_deinit(&cxt);
+    return 0;
+err:
+    sysfs_deinit(&cxt);
+    return -1;
+}
+
+#ifdef TEST_PROGRAM_SYSFS
+#include <errno.h>
+#include <err.h>
+#include <stdlib.h>
+
+int main(int argc, char *argv[])
+{
+	struct sysfs_cxt cxt = UL_SYSFSCXT_EMPTY;
+	char *devname;
+	dev_t devno;
+	char path[PATH_MAX];
+	int i, is_part;
+	uint64_t u64;
+	ssize_t len;
+
+	if (argc != 2)
+		errx(EXIT_FAILURE, "usage: %s <devname>", argv[0]);
+
+	devname = argv[1];
+	devno = sysfs_devname_to_devno(devname, NULL);
+
+	if (!devno)
+		err(EXIT_FAILURE, "failed to read devno");
+
+	is_part = sysfs_devno_has_attribute(devno, "partition");
+
+	printf("NAME: %s\n", devname);
+	printf("DEVNO: %u (%d:%d)\n", (unsigned int) devno, major(devno), minor(devno));
+	printf("DEVNOPATH: %s\n", sysfs_devno_path(devno, path, sizeof(path)));
+	printf("DEVPATH: %s\n", sysfs_devno_to_devpath(devno, path, sizeof(path)));
+	printf("PARTITION: %s\n", is_part ? "YES" : "NOT");
+
+	if (sysfs_init(&cxt, devno, NULL))
+		return EXIT_FAILURE;
+
+	len = sysfs_readlink(&cxt, NULL, path, sizeof(path) - 1);
+	if (len > 0) {
+		path[len] = '\0';
+		printf("DEVNOLINK: %s\n", path);
+	}
+
+	if (!is_part) {
+		printf("First 5 partitions:\n");
+		for (i = 1; i <= 5; i++) {
+			dev_t dev = sysfs_partno_to_devno(&cxt, i);
+			if (dev)
+				printf("\t#%d %d:%d\n", i, major(dev), minor(dev));
+		}
+	}
+
+	printf("SLAVES: %d\n", sysfs_count_dirents(&cxt, "slaves"));
+
+	if (sysfs_read_u64(&cxt, "size", &u64))
+		printf("read SIZE failed\n");
+	else
+		printf("SIZE: %jd\n", u64);
+
+	if (sysfs_read_int(&cxt, "queue/hw_sector_size", &i))
+		printf("read SECTOR failed\n");
+	else
+		printf("SECTOR: %d\n", i);
+
+	printf("DEVNAME: %s\n", sysfs_get_devname(&cxt, path, sizeof(path)));
+
+	sysfs_deinit(&cxt);
+	return EXIT_SUCCESS;
+}
+#endif
diff -up util-linux-ng-2.17.2/lib/tt.c.base util-linux-ng-2.17.2/lib/tt.c
--- util-linux-ng-2.17.2/lib/tt.c.base	2012-10-08 12:03:34.861028231 +0200
+++ util-linux-ng-2.17.2/lib/tt.c	2012-10-08 12:03:34.861028231 +0200
@@ -0,0 +1,999 @@
+/*
+ * TT - Table or Tree, features:
+ * - column width could be defined as absolute or relative to the terminal width
+ * - allows to truncate or wrap data in columns
+ * - prints tree if parent->child relation is defined
+ * - draws the tree by ASCII or UTF8 lines (depends on terminal setting)
+ *
+ * Copyright (C) 2010 Karel Zak <kzak@redhat.com>
+ *
+ * This file may be redistributed under the terms of the
+ * GNU Lesser General Public License.
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <termios.h>
+#include <ctype.h>
+#include <langinfo.h>
+
+#include "c.h"
+#include "nls.h"
+#include "widechar.h"
+#include "tt.h"
+#include "mbsalign.h"
+#include "ttyutils.h"
+
+struct tt_symbols {
+	const char *branch;
+	const char *vert;
+	const char *right;
+};
+
+static const struct tt_symbols ascii_tt_symbols = {
+	.branch = "|-",
+	.vert	= "| ",
+	.right	= "`-",
+};
+
+#ifdef HAVE_WIDECHAR
+#define UTF_V	"\342\224\202"	/* U+2502, Vertical line drawing char */
+#define UTF_VR	"\342\224\234"	/* U+251C, Vertical and right */
+#define UTF_H	"\342\224\200"	/* U+2500, Horizontal */
+#define UTF_UR	"\342\224\224"	/* U+2514, Up and right */
+
+static const struct tt_symbols utf8_tt_symbols = {
+	.branch = UTF_VR UTF_H,
+	.vert   = UTF_V " ",
+	.right	= UTF_UR UTF_H,
+};
+#endif /* !HAVE_WIDECHAR */
+
+#define is_last_column(_tb, _cl) \
+		list_last_entry(&(_cl)->cl_columns, &(_tb)->tb_columns)
+
+/*
+ * Counts number of cells in multibyte string. For all control and
+ * non-printable chars is the result width enlarged to store \x?? hex
+ * sequence. See mbs_safe_encode().
+ */
+static size_t mbs_safe_width(const char *s)
+{
+	mbstate_t st;
+	const char *p = s;
+	size_t width = 0;
+
+	memset(&st, 0, sizeof(st));
+
+	while (p && *p) {
+		if (iscntrl((unsigned char) *p)) {
+			width += 4;			/* *p encoded to \x?? */
+			p++;
+		}
+#ifdef HAVE_WIDECHAR
+		else {
+			wchar_t wc;
+			size_t len = mbrtowc(&wc, p, MB_CUR_MAX, &st);
+
+			if (len == 0)
+				break;
+
+			if (len == (size_t) -1 || len == (size_t) -2) {
+				len = 1;
+				width += (isprint((unsigned char) *p) ? 1 : 4);
+
+			} if (!iswprint(wc))
+				width += len * 4;	/* hex encode whole sequence */
+			else
+				width += wcwidth(wc);	/* number of cells */
+			p += len;
+		}
+#else
+		else if (!isprint((unsigned char) *p)) {
+			width += 4;			/* *p encoded to \x?? */
+			p++;
+		} else {
+			width++;
+			p++;
+		}
+#endif
+	}
+
+	return width;
+}
+
+/*
+ * Returns allocated string where all control and non-printable chars are
+ * replaced with \x?? hex sequence.
+ */
+static char *mbs_safe_encode(const char *s, size_t *width)
+{
+	mbstate_t st;
+	const char *p = s;
+	char *res, *r;
+	size_t sz = s ? strlen(s) : 0;
+
+
+	if (!sz)
+		return NULL;
+
+	memset(&st, 0, sizeof(st));
+
+	res = malloc((sz * 4) + 1);
+	if (!res)
+		return NULL;
+
+	r = res;
+	*width = 0;
+
+	while (p && *p) {
+		if (iscntrl((unsigned char) *p)) {
+			sprintf(r, "\\x%02x", (unsigned char) *p);
+			r += 4;
+			*width += 4;
+			p++;
+		}
+#ifdef HAVE_WIDECHAR
+		else {
+			wchar_t wc;
+			size_t len = mbrtowc(&wc, p, MB_CUR_MAX, &st);
+
+			if (len == 0)
+				break;		/* end of string */
+
+			if (len == (size_t) -1 || len == (size_t) -2) {
+				len = 1;
+				/*
+				 * Not valid multibyte sequence -- maybe it's
+				 * printable char according to the current locales.
+				 */
+				if (!isprint((unsigned char) *p)) {
+					sprintf(r, "\\x%02x", (unsigned char) *p);
+					r += 4;
+					*width += 4;
+				} else {
+					width++;
+					*r++ = *p;
+				}
+			} else if (!iswprint(wc)) {
+				size_t i;
+				for (i = 0; i < len; i++) {
+					sprintf(r, "\\x%02x", (unsigned char) *p);
+					r += 4;
+					*width += 4;
+				}
+			} else {
+				memcpy(r, p, len);
+				r += len;
+				*width += wcwidth(wc);
+			}
+			p += len;
+		}
+#else
+		else if (!isprint((unsigned char) *p)) {
+			sprintf(r, "\\x%02x", (unsigned char) *p);
+			p++;
+			r += 4;
+			*width += 4;
+		} else {
+			*r++ = *p++;
+			*width++;
+		}
+#endif
+	}
+
+	*r = '\0';
+
+	return res;
+}
+
+/*
+ * @flags: TT_FL_* flags (usually TT_FL_{ASCII,RAW})
+ *
+ * Returns: newly allocated table
+ */
+struct tt *tt_new_table(int flags)
+{
+	struct tt *tb;
+
+	tb = calloc(1, sizeof(struct tt));
+	if (!tb)
+		return NULL;
+
+	tb->flags = flags;
+	INIT_LIST_HEAD(&tb->tb_lines);
+	INIT_LIST_HEAD(&tb->tb_columns);
+
+#if defined(HAVE_WIDECHAR)
+	if (!(flags & TT_FL_ASCII) && !strcmp(nl_langinfo(CODESET), "UTF-8"))
+		tb->symbols = &utf8_tt_symbols;
+	else
+#endif
+		tb->symbols = &ascii_tt_symbols;
+
+	tb->first_run = TRUE;
+	return tb;
+}
+
+void tt_remove_lines(struct tt *tb)
+{
+	if (!tb)
+		return;
+
+	while (!list_empty(&tb->tb_lines)) {
+		struct tt_line *ln = list_entry(tb->tb_lines.next,
+						struct tt_line, ln_lines);
+		list_del(&ln->ln_lines);
+		free(ln->data);
+		free(ln);
+	}
+}
+
+void tt_free_table(struct tt *tb)
+{
+	if (!tb)
+		return;
+
+	tt_remove_lines(tb);
+
+	while (!list_empty(&tb->tb_columns)) {
+		struct tt_column *cl = list_entry(tb->tb_columns.next,
+						struct tt_column, cl_columns);
+		list_del(&cl->cl_columns);
+		free(cl);
+	}
+	free(tb);
+}
+
+
+/*
+ * @tb: table
+ * @name: column header
+ * @whint: column width hint (absolute width: N > 1; relative width: N < 1)
+ * @flags: usually TT_FL_{TREE,TRUNCATE}
+ *
+ * The column width is possible to define by three ways:
+ *
+ *  @whint = 0..1    : relative width, percent of terminal width
+ *
+ *  @whint = 1..N    : absolute width, empty colum will be truncated to
+ *                     the column header width
+ *
+ *  @whint = 1..N
+ *  @flags = TT_FL_STRICTWIDTH
+ *                   : absolute width, empty colum won't be truncated
+ *
+ * The column is necessary to address (for example for tt_line_set_data()) by
+ * sequential number. The first defined column has the colnum = 0. For example:
+ *
+ *	tt_define_column(tab, "FOO", 0.5, 0);		// colnum = 0
+ *	tt_define_column(tab, "BAR", 0.5, 0);		// colnum = 1
+ *      .
+ *      .
+ *	tt_line_set_data(line, 0, "foo-data");		// FOO column
+ *	tt_line_set_data(line, 1, "bar-data");		// BAR column
+ *
+ * Returns: newly allocated column definition
+ */
+struct tt_column *tt_define_column(struct tt *tb, const char *name,
+					double whint, int flags)
+{
+	struct tt_column *cl;
+
+	if (!tb)
+		return NULL;
+	cl = calloc(1, sizeof(*cl));
+	if (!cl)
+		return NULL;
+
+	cl->name = name;
+	cl->width_hint = whint;
+	cl->flags = flags;
+	cl->seqnum = tb->ncols++;
+
+	if (flags & TT_FL_TREE)
+		tb->flags |= TT_FL_TREE;
+
+	INIT_LIST_HEAD(&cl->cl_columns);
+	list_add_tail(&cl->cl_columns, &tb->tb_columns);
+	return cl;
+}
+
+/*
+ * @tb: table
+ * @parent: parental line or NULL
+ *
+ * Returns: newly allocate line
+ */
+struct tt_line *tt_add_line(struct tt *tb, struct tt_line *parent)
+{
+	struct tt_line *ln = NULL;
+
+	if (!tb || !tb->ncols)
+		goto err;
+	ln = calloc(1, sizeof(*ln));
+	if (!ln)
+		goto err;
+	ln->data = calloc(tb->ncols, sizeof(char *));
+	if (!ln->data)
+		goto err;
+
+	ln->table = tb;
+	ln->parent = parent;
+	INIT_LIST_HEAD(&ln->ln_lines);
+	INIT_LIST_HEAD(&ln->ln_children);
+	INIT_LIST_HEAD(&ln->ln_branch);
+
+	list_add_tail(&ln->ln_lines, &tb->tb_lines);
+
+	if (parent)
+		list_add_tail(&ln->ln_children, &parent->ln_branch);
+	return ln;
+err:
+	free(ln);
+	return NULL;
+}
+
+/*
+ * @tb: table
+ * @colnum: number of column (0..N)
+ *
+ * Returns: pointer to column or NULL
+ */
+struct tt_column *tt_get_column(struct tt *tb, size_t colnum)
+{
+	struct list_head *p;
+
+	list_for_each(p, &tb->tb_columns) {
+		struct tt_column *cl =
+				list_entry(p, struct tt_column, cl_columns);
+		if (cl->seqnum == colnum)
+			return cl;
+	}
+	return NULL;
+}
+
+/*
+ * @ln: line
+ * @colnum: number of column (0..N)
+ * @data: printable data
+ *
+ * Stores data that will be printed to the table cell.
+ */
+int tt_line_set_data(struct tt_line *ln, int colnum, const char *data)
+{
+	struct tt_column *cl;
+
+	if (!ln)
+		return -1;
+	cl = tt_get_column(ln->table, colnum);
+	if (!cl)
+		return -1;
+
+	if (ln->data[cl->seqnum]) {
+		size_t sz = strlen(ln->data[cl->seqnum]);;
+		ln->data_sz = ln->data_sz > sz ? ln->data_sz - sz : 0;
+	}
+
+	ln->data[cl->seqnum] = data;
+	if (data)
+		ln->data_sz += strlen(data);
+	return 0;
+}
+
+int tt_line_set_userdata(struct tt_line *ln, void *data)
+{
+	if (!ln)
+		return -1;
+	ln->userdata = data;
+	return 0;
+}
+
+static char *line_get_ascii_art(struct tt_line *ln, char *buf, size_t *bufsz)
+{
+	const char *art;
+	size_t len;
+
+	if (!ln->parent)
+		return buf;
+
+	buf = line_get_ascii_art(ln->parent, buf, bufsz);
+	if (!buf)
+		return NULL;
+
+	if (list_last_entry(&ln->ln_children, &ln->parent->ln_branch))
+		art = "  ";
+	else
+		art = ln->table->symbols->vert;
+
+	len = strlen(art);
+	if (*bufsz < len)
+		return NULL;	/* no space, internal error */
+
+	memcpy(buf, art, len);
+	*bufsz -= len;
+	return buf + len;
+}
+
+static char *line_get_data(struct tt_line *ln, struct tt_column *cl,
+				char *buf, size_t bufsz)
+{
+	const char *data = ln->data[cl->seqnum];
+	const struct tt_symbols *sym;
+	char *p = buf;
+
+	memset(buf, 0, bufsz);
+
+	if (!data)
+		return NULL;
+	if (!(cl->flags & TT_FL_TREE)) {
+		strncpy(buf, data, bufsz);
+		buf[bufsz - 1] = '\0';
+		return buf;
+	}
+
+	/*
+	 * Tree stuff
+	 */
+	if (ln->parent) {
+		p = line_get_ascii_art(ln->parent, buf, &bufsz);
+		if (!p)
+			return NULL;
+	}
+
+	sym = ln->table->symbols;
+
+	if (!ln->parent)
+		snprintf(p, bufsz, "%s", data);			/* root node */
+	else if (list_last_entry(&ln->ln_children, &ln->parent->ln_branch))
+		snprintf(p, bufsz, "%s%s", sym->right, data);	/* last chaild */
+	else
+		snprintf(p, bufsz, "%s%s", sym->branch, data);	/* any child */
+
+	return buf;
+}
+
+/*
+ * This function counts column width.
+ *
+ * For the TT_FL_NOEXTREMES columns is possible to call this function two
+ * times.  The first pass counts width and average width. If the column
+ * contains too large fields (width greater than 2 * average) then the column
+ * is marked as "extreme". In the second pass all extreme fields are ignored
+ * and column width is counted from non-extreme fields only.
+ */
+static void count_column_width(struct tt *tb, struct tt_column *cl,
+				 char *buf, size_t bufsz)
+{
+	struct list_head *lp;
+	int count = 0;
+	size_t sum = 0;
+
+	cl->width = 0;
+
+	list_for_each(lp, &tb->tb_lines) {
+		struct tt_line *ln = list_entry(lp, struct tt_line, ln_lines);
+		char *data = line_get_data(ln, cl, buf, bufsz);
+		size_t len = data ? mbs_safe_width(data) : 0;
+
+		if (len == (size_t) -1)		/* ignore broken multibyte strings */
+			len = 0;
+
+		if (len > cl->width_max)
+			cl->width_max = len;
+
+		if (cl->is_extreme && len > cl->width_avg * 2)
+			continue;
+		else if (cl->flags & TT_FL_NOEXTREMES) {
+			sum += len;
+			count++;
+		}
+		if (len > cl->width)
+			cl->width = len;
+	}
+
+	if (count && cl->width_avg == 0) {
+		cl->width_avg = sum / count;
+
+		if (cl->width_max > cl->width_avg * 2)
+			cl->is_extreme = 1;
+	}
+
+	/* check and set minimal column width */
+	if (cl->name)
+		cl->width_min = mbs_safe_width(cl->name);
+
+	/* enlarge to minimal width */
+	if (cl->width < cl->width_min && !(cl->flags & TT_FL_STRICTWIDTH))
+		cl->width = cl->width_min;
+
+	/* use relative size for large columns */
+	else if (cl->width_hint >= 1 && cl->width < (size_t) cl->width_hint &&
+		 cl->width_min < (size_t) cl->width_hint)
+
+		cl->width = (size_t) cl->width_hint;
+}
+
+/*
+ * This is core of the tt_* voodo...
+ */
+static void recount_widths(struct tt *tb, char *buf, size_t bufsz)
+{
+	struct list_head *p;
+	size_t width = 0;	/* output width */
+	int trunc_only;
+	int extremes = 0;
+
+	/* set basic columns width
+	 */
+	list_for_each(p, &tb->tb_columns) {
+		struct tt_column *cl =
+				list_entry(p, struct tt_column, cl_columns);
+
+		count_column_width(tb, cl, buf, bufsz);
+		width += cl->width + (is_last_column(tb, cl) ? 0 : 1);
+		extremes += cl->is_extreme;
+	}
+
+	/* reduce columns with extreme fields
+	 */
+	if (width > tb->termwidth && extremes) {
+		list_for_each(p, &tb->tb_columns) {
+			struct tt_column *cl = list_entry(p, struct tt_column, cl_columns);
+			size_t org_width;
+
+			if (!cl->is_extreme)
+				continue;
+
+			org_width = cl->width;
+			count_column_width(tb, cl, buf, bufsz);
+
+			if (org_width > cl->width)
+				width -= org_width - cl->width;
+			else
+				extremes--;	/* hmm... nothing reduced */
+		}
+	}
+
+	if (width < tb->termwidth) {
+		/* try to found extreme column which fits into available space
+		 */
+		if (extremes) {
+			/* enlarge the first extreme column */
+			list_for_each(p, &tb->tb_columns) {
+				struct tt_column *cl =
+					list_entry(p, struct tt_column, cl_columns);
+				size_t add;
+
+				if (!cl->is_extreme)
+					continue;
+
+				if (cl->width_max - cl->width >
+						(tb->termwidth - width))
+					/* this column is tooo large, ignore */
+					continue;
+
+				add = tb->termwidth - width;
+				if (add && cl->width + add > cl->width_max)
+					add = cl->width_max - cl->width;
+
+				cl->width += add;
+				width += add;
+
+				if (width == tb->termwidth)
+					break;
+			}
+		}
+		if (width < tb->termwidth) {
+			/* enalarge the last column */
+			struct tt_column *cl = list_entry(
+				tb->tb_columns.prev, struct tt_column, cl_columns);
+
+			if (!(cl->flags & TT_FL_RIGHT) && tb->termwidth - width > 0) {
+				cl->width += tb->termwidth - width;
+				width = tb->termwidth;
+			}
+		}
+	}
+
+	/* bad, we have to reduce output width, this is done in two steps:
+	 * 1/ reduce columns with a relative width and with truncate flag
+	 * 2) reduce columns with a relative width without truncate flag
+	 */
+	trunc_only = 1;
+	while (width > tb->termwidth) {
+		size_t org = width;
+
+		list_for_each(p, &tb->tb_columns) {
+			struct tt_column *cl =
+				list_entry(p, struct tt_column, cl_columns);
+
+			if (width <= tb->termwidth)
+				break;
+			if (cl->width_hint > 1 && !(cl->flags & TT_FL_TRUNC))
+				continue;	/* never truncate columns with absolute sizes */
+			if (cl->flags & TT_FL_TREE)
+				continue;	/* never truncate the tree */
+			if (trunc_only && !(cl->flags & TT_FL_TRUNC))
+				continue;
+			if (cl->width == cl->width_min)
+				continue;
+
+			/* truncate column with relative sizes */
+			if (cl->width_hint < 1 && cl->width > 0 && width > 0 &&
+			    cl->width > cl->width_hint * tb->termwidth) {
+				cl->width--;
+				width--;
+			}
+			/* truncate column with absolute size */
+			if (cl->width_hint > 1 && cl->width > 0 && width > 0 &&
+			    !trunc_only) {
+				cl->width--;
+				width--;
+			}
+
+		}
+		if (org == width) {
+			if (trunc_only)
+				trunc_only = 0;
+			else
+				break;
+		}
+	}
+
+/*
+	fprintf(stderr, "terminal: %d, output: %d\n", tb->termwidth, width);
+
+	list_for_each(p, &tb->tb_columns) {
+		struct tt_column *cl =
+			list_entry(p, struct tt_column, cl_columns);
+
+		fprintf(stderr, "width: %s=%zd [hint=%d, avg=%zd, max=%zd, extreme=%s]\n",
+			cl->name, cl->width,
+			cl->width_hint > 1 ? (int) cl->width_hint :
+					     (int) (cl->width_hint * tb->termwidth),
+			cl->width_avg,
+			cl->width_max,
+			cl->is_extreme ? "yes" : "not");
+	}
+*/
+	return;
+}
+
+void tt_fputs_quoted(const char *data, FILE *out)
+{
+	const char *p;
+
+	fputc('"', out);
+	for (p = data; p && *p; p++) {
+		if ((unsigned char) *p == 0x22 ||		/* " */
+		    (unsigned char) *p == 0x5c ||		/* \ */
+		    !isprint((unsigned char) *p) ||
+		    iscntrl((unsigned char) *p)) {
+
+			fprintf(out, "\\x%02x", (unsigned char) *p);
+		} else
+			fputc(*p, out);
+	}
+	fputc('"', out);
+}
+
+void tt_fputs_nonblank(const char *data, FILE *out)
+{
+	const char *p;
+
+	for (p = data; p && *p; p++) {
+		if (isblank((unsigned char) *p) ||
+		    (unsigned char) *p == 0x5c ||		/* \ */
+		    !isprint((unsigned char) *p) ||
+		    iscntrl((unsigned char) *p)) {
+
+			fprintf(out, "\\x%02x", (unsigned char) *p);
+
+		} else
+			fputc(*p, out);
+	}
+}
+
+/*
+ * Prints data, data maybe be printed in more formats (raw, NAME=xxx pairs) and
+ * control and non-printable chars maybe encoded in \x?? hex encoding.
+ */
+static void print_data(struct tt *tb, struct tt_column *cl, char *data)
+{
+	size_t len = 0, i, width;
+	char *buf;
+
+	if (!data)
+		data = "";
+
+	/* raw mode */
+	if (tb->flags & TT_FL_RAW) {
+		tt_fputs_nonblank(data, stdout);
+		if (!is_last_column(tb, cl))
+			fputc(' ', stdout);
+		return;
+	}
+
+	/* NAME=value mode */
+	if (tb->flags & TT_FL_EXPORT) {
+		fprintf(stdout, "%s=", cl->name);
+		tt_fputs_quoted(data, stdout);
+		if (!is_last_column(tb, cl))
+			fputc(' ', stdout);
+		return;
+	}
+
+	/* note that 'len' and 'width' are number of cells, not bytes */
+	buf = mbs_safe_encode(data, &len);
+	data = buf;
+	if (!data)
+		data = "";
+
+	if (!len || len == (size_t) -1) {
+		len = 0;
+		data = NULL;
+	}
+	width = cl->width;
+
+	if (is_last_column(tb, cl) && len < width)
+		width = len;
+
+	/* truncate data */
+	if (len > width && (cl->flags & TT_FL_TRUNC)) {
+		if (data)
+			len = mbs_truncate(data, &width);
+		if (!data || len == (size_t) -1) {
+			len = 0;
+			data = NULL;
+		}
+	}
+	if (data) {
+		if (!(tb->flags & TT_FL_RAW) && (cl->flags & TT_FL_RIGHT)) {
+			size_t xw = cl->width;
+			fprintf(stdout, "%*s", (int) xw, data);
+			if (len < xw)
+				len = xw;
+		}
+		else
+			fputs(data, stdout);
+	}
+	for (i = len; i < width; i++)
+		fputc(' ', stdout);		/* padding */
+
+	if (!is_last_column(tb, cl)) {
+		if (len > width && !(cl->flags & TT_FL_TRUNC)) {
+			fputc('\n', stdout);
+			for (i = 0; i <= (size_t) cl->seqnum; i++) {
+				struct tt_column *x = tt_get_column(tb, i);
+				printf("%*s ", -((int)x->width), " ");
+			}
+		} else
+			fputc(' ', stdout);	/* columns separator */
+	}
+
+	free(buf);
+}
+
+static void print_line(struct tt_line *ln, char *buf, size_t bufsz)
+{
+	struct list_head *p;
+
+	/* set width according to the size of data
+	 */
+	list_for_each(p, &ln->table->tb_columns) {
+		struct tt_column *cl =
+				list_entry(p, struct tt_column, cl_columns);
+
+		print_data(ln->table, cl, line_get_data(ln, cl, buf, bufsz));
+	}
+	fputc('\n', stdout);
+}
+
+static void print_header(struct tt *tb, char *buf, size_t bufsz)
+{
+	struct list_head *p;
+
+	if (!tb->first_run ||
+	    (tb->flags & TT_FL_NOHEADINGS) ||
+	    (tb->flags & TT_FL_EXPORT) ||
+	    list_empty(&tb->tb_lines))
+		return;
+
+	/* set width according to the size of data
+	 */
+	list_for_each(p, &tb->tb_columns) {
+		struct tt_column *cl =
+				list_entry(p, struct tt_column, cl_columns);
+
+		strncpy(buf, cl->name, bufsz);
+		buf[bufsz - 1] = '\0';
+		print_data(tb, cl, buf);
+	}
+	fputc('\n', stdout);
+}
+
+static void print_table(struct tt *tb, char *buf, size_t bufsz)
+{
+	struct list_head *p;
+
+	print_header(tb, buf, bufsz);
+
+	list_for_each(p, &tb->tb_lines) {
+		struct tt_line *ln = list_entry(p, struct tt_line, ln_lines);
+
+		print_line(ln, buf, bufsz);
+	}
+}
+
+static void print_tree_line(struct tt_line *ln, char *buf, size_t bufsz)
+{
+	struct list_head *p;
+
+	print_line(ln, buf, bufsz);
+
+	if (list_empty(&ln->ln_branch))
+		return;
+
+	/* print all children */
+	list_for_each(p, &ln->ln_branch) {
+		struct tt_line *chld =
+				list_entry(p, struct tt_line, ln_children);
+		print_tree_line(chld, buf, bufsz);
+	}
+}
+
+static void print_tree(struct tt *tb, char *buf, size_t bufsz)
+{
+	struct list_head *p;
+
+	print_header(tb, buf, bufsz);
+
+	list_for_each(p, &tb->tb_lines) {
+		struct tt_line *ln = list_entry(p, struct tt_line, ln_lines);
+
+		if (ln->parent)
+			continue;
+
+		print_tree_line(ln, buf, bufsz);
+	}
+}
+
+/*
+ * @tb: table
+ *
+ * Prints the table to stdout
+ */
+int tt_print_table(struct tt *tb)
+{
+	char *line;
+	size_t line_sz;
+	struct list_head *p;
+
+	if (!tb)
+		return -1;
+
+	if (tb->first_run && !tb->termwidth) {
+		tb->termwidth = get_terminal_width();
+		if (tb->termwidth <= 0)
+			tb->termwidth = 80;
+	}
+
+	line_sz = tb->termwidth;
+
+	list_for_each(p, &tb->tb_lines) {
+		struct tt_line *ln = list_entry(p, struct tt_line, ln_lines);
+		if (ln->data_sz > line_sz)
+			line_sz = ln->data_sz;
+	}
+
+	line_sz++;			/* make a space for \0 */
+	line = malloc(line_sz);
+	if (!line)
+		return -1;
+
+	if (tb->first_run &&
+	    !((tb->flags & TT_FL_RAW) || (tb->flags & TT_FL_EXPORT)))
+		recount_widths(tb, line, line_sz);
+
+	if (tb->flags & TT_FL_TREE)
+		print_tree(tb, line, line_sz);
+	else
+		print_table(tb, line, line_sz);
+
+	free(line);
+
+	tb->first_run = FALSE;
+	return 0;
+}
+
+#ifdef TEST_PROGRAM
+#include <errno.h>
+
+enum { MYCOL_NAME, MYCOL_FOO, MYCOL_BAR, MYCOL_PATH };
+
+int main(int argc, char *argv[])
+{
+	struct tt *tb;
+	struct tt_line *ln, *pr, *root;
+	int flags = 0, notree = 0, i;
+
+	if (argc == 2 && !strcmp(argv[1], "--help")) {
+		printf("%s [--ascii | --raw | --list]\n",
+				program_invocation_short_name);
+		return EXIT_SUCCESS;
+	} else if (argc == 2 && !strcmp(argv[1], "--ascii")) {
+		flags |= TT_FL_ASCII;
+	} else if (argc == 2 && !strcmp(argv[1], "--raw")) {
+		flags |= TT_FL_RAW;
+		notree = 1;
+	} else if (argc == 2 && !strcmp(argv[1], "--export")) {
+		flags |= TT_FL_EXPORT;
+		notree = 1;
+	} else if (argc == 2 && !strcmp(argv[1], "--list"))
+		notree = 1;
+
+	setlocale(LC_ALL, "");
+	bindtextdomain(PACKAGE, LOCALEDIR);
+	textdomain(PACKAGE);
+
+	tb = tt_new_table(flags);
+	if (!tb)
+		err(EXIT_FAILURE, "table initialization failed");
+
+	tt_define_column(tb, "NAME", 0.3, notree ? 0 : TT_FL_TREE);
+	tt_define_column(tb, "FOO", 0.3, TT_FL_TRUNC);
+	tt_define_column(tb, "BAR", 0.3, 0);
+	tt_define_column(tb, "PATH", 0.3, 0);
+
+	for (i = 0; i < 2; i++) {
+		root = ln = tt_add_line(tb, NULL);
+		tt_line_set_data(ln, MYCOL_NAME, "AAA");
+		tt_line_set_data(ln, MYCOL_FOO, "a-foo-foo");
+		tt_line_set_data(ln, MYCOL_BAR, "barBar-A");
+		tt_line_set_data(ln, MYCOL_PATH, "/mnt/AAA");
+
+		pr = ln = tt_add_line(tb, ln);
+		tt_line_set_data(ln, MYCOL_NAME, "AAA.A");
+		tt_line_set_data(ln, MYCOL_FOO, "a.a-foo-foo");
+		tt_line_set_data(ln, MYCOL_BAR, "barBar-A.A");
+		tt_line_set_data(ln, MYCOL_PATH, "/mnt/AAA/A");
+
+		ln = tt_add_line(tb, pr);
+		tt_line_set_data(ln, MYCOL_NAME, "AAA.A.AAA");
+		tt_line_set_data(ln, MYCOL_FOO, "a.a.a-foo-foo");
+		tt_line_set_data(ln, MYCOL_BAR, "barBar-A.A.A");
+		tt_line_set_data(ln, MYCOL_PATH, "/mnt/AAA/A/AAA");
+
+		ln = tt_add_line(tb, root);
+		tt_line_set_data(ln, MYCOL_NAME, "AAA.B");
+		tt_line_set_data(ln, MYCOL_FOO, "a.b-foo-foo");
+		tt_line_set_data(ln, MYCOL_BAR, "barBar-A.B");
+		tt_line_set_data(ln, MYCOL_PATH, "/mnt/AAA/B");
+
+		ln = tt_add_line(tb, pr);
+		tt_line_set_data(ln, MYCOL_NAME, "AAA.A.BBB");
+		tt_line_set_data(ln, MYCOL_FOO, "a.a.b-foo-foo");
+		tt_line_set_data(ln, MYCOL_BAR, "barBar-A.A.BBB");
+		tt_line_set_data(ln, MYCOL_PATH, "/mnt/AAA/A/BBB");
+
+		ln = tt_add_line(tb, pr);
+		tt_line_set_data(ln, MYCOL_NAME, "AAA.A.CCC");
+		tt_line_set_data(ln, MYCOL_FOO, "a.a.c-foo-foo");
+		tt_line_set_data(ln, MYCOL_BAR, "barBar-A.A.CCC");
+		tt_line_set_data(ln, MYCOL_PATH, "/mnt/AAA/A/CCC");
+
+		ln = tt_add_line(tb, root);
+		tt_line_set_data(ln, MYCOL_NAME, "AAA.C");
+		tt_line_set_data(ln, MYCOL_FOO, "a.c-foo-foo");
+		tt_line_set_data(ln, MYCOL_BAR, "barBar-A.C");
+		tt_line_set_data(ln, MYCOL_PATH, "/mnt/AAA/C");
+	}
+
+	tt_print_table(tb);
+	tt_free_table(tb);
+
+	return EXIT_SUCCESS;
+}
+#endif
