From 11f322e9c62ff18b72bc94aac9e3de10782ed3e5 Mon Sep 17 00:00:00 2001
From: Karel Zak <kzak@redhat.com>
Date: Fri, 13 Jun 2014 11:44:56 +0200
Subject: [PATCH] unshare: backport PID namespaces

---
 include/exec_shell.h  |    1 +
 include/namespace.h   |   44 +++++++++++++++++
 include/xalloc.h      |    2 +
 lib/exec_shell.c      |   46 ++++++++++++++++++
 sys-utils/Makefile.am |    2 +
 sys-utils/unshare.1   |   76 ++++++++++++++++++++---------
 sys-utils/unshare.c   |  126 ++++++++++++++++++++++++++++++++-----------------
 7 files changed, 229 insertions(+), 68 deletions(-)
 create mode 100644 include/exec_shell.h
 create mode 100644 include/namespace.h
 create mode 100644 lib/exec_shell.c

diff --git a/include/exec_shell.h b/include/exec_shell.h
new file mode 100644
index 0000000..a2aa757
--- /dev/null
+++ b/include/exec_shell.h
@@ -0,0 +1 @@
+extern void __attribute__((__noreturn__)) exec_shell(void);
diff --git a/include/namespace.h b/include/namespace.h
new file mode 100644
index 0000000..ea231ca
--- /dev/null
+++ b/include/namespace.h
@@ -0,0 +1,44 @@
+/* Compat code so unshare and setns can be used with older libcs */
+#ifndef UTIL_LINUX_NAMESPACE_H
+# define UTIL_LINUX_NAMESPACE_H
+
+# include <sched.h>
+
+# ifndef CLONE_NEWNS
+#  define CLONE_NEWNS 0x00020000
+# endif
+# ifndef CLONE_NEWUTS
+#  define CLONE_NEWUTS 0x04000000
+# endif
+# ifndef CLONE_NEWIPC
+#  define CLONE_NEWIPC 0x08000000
+# endif
+# ifndef CLONE_NEWNET
+#  define CLONE_NEWNET 0x40000000
+# endif
+# ifndef CLONE_NEWUSER
+#  define CLONE_NEWUSER 0x10000000
+# endif
+# ifndef CLONE_NEWPID
+#  define CLONE_NEWPID 0x20000000
+# endif
+
+# if !defined(HAVE_UNSHARE) || !defined(HAVE_SETNS)
+#  include <sys/syscall.h>
+# endif
+
+# if !defined(HAVE_UNSHARE) && defined(SYS_unshare)
+static inline int unshare(int flags)
+{
+	return syscall(SYS_unshare, flags);
+}
+# endif
+
+# if !defined(HAVE_SETNS) && defined(SYS_setns)
+static inline int setns(int fd, int nstype)
+{
+	return syscall(SYS_setns, fd, nstype);
+}
+# endif
+
+#endif	/* UTIL_LINUX_NAMESPACE_H */
diff --git a/include/xalloc.h b/include/xalloc.h
index f317e05..d449c73 100644
--- a/include/xalloc.h
+++ b/include/xalloc.h
@@ -10,8 +10,10 @@
 #ifndef UTIL_LINUX_XALLOC_H
 #define UTIL_LINUX_XALLOC_H
 
+#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <stdarg.h>
 
 #include "c.h"
 
diff --git a/lib/exec_shell.c b/lib/exec_shell.c
new file mode 100644
index 0000000..2b26364
--- /dev/null
+++ b/lib/exec_shell.c
@@ -0,0 +1,46 @@
+/*
+ * exec_shell() - launch a shell, else exit!
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/types.h>
+
+#include "nls.h"
+#include "c.h"
+#include "xalloc.h"
+
+#include "exec_shell.h"
+
+#define DEFAULT_SHELL "/bin/sh"
+
+void exec_shell(void)
+{
+	const char *shell = getenv("SHELL"), *shell_basename;
+	char *arg0;
+	if (!shell)
+		shell = DEFAULT_SHELL;
+
+	shell_basename = basename(shell);
+	arg0 = xmalloc(strlen(shell_basename) + 2);
+	arg0[0] = '-';
+	strcpy(arg0 + 1, shell_basename);
+
+	execl(shell, arg0, NULL);
+	err(EXIT_FAILURE, _("failed to execute %s"), shell);
+}
diff --git a/sys-utils/Makefile.am b/sys-utils/Makefile.am
index b4e21bc..8ce9235 100644
--- a/sys-utils/Makefile.am
+++ b/sys-utils/Makefile.am
@@ -59,6 +59,8 @@ endif
 
 if BUILD_UNSHARE
 usrbin_exec_PROGRAMS += unshare
+unshare_SOURCES = unshare.c \
+	$(top_srcdir)/lib/exec_shell.c
 dist_man_MANS += unshare.1
 endif
 
diff --git a/sys-utils/unshare.1 b/sys-utils/unshare.1
index 31fcfde..6dd13b8 100644
--- a/sys-utils/unshare.1
+++ b/sys-utils/unshare.1
@@ -1,58 +1,86 @@
 .\" Process this file with
 .\" groff -man -Tascii lscpu.1
 .\"
-.TH UNSHARE 1 "OCTOBER 2008" Linux "User Manuals"
+.TH UNSHARE 1 "July 2013" "util-linux" "User Commands"
 .SH NAME
 unshare \- run program with some namespaces unshared from parent
 .SH SYNOPSIS
 .B unshare
 .RI [ options ]
-program
+.I program
 .RI [ arguments ]
 .SH DESCRIPTION
-Unshares specified namespaces from parent process and then executes specified
-program. Unshareable namespaces are:
+Unshares the indicated namespaces from the parent process and then executes
+the specified program.  The namespaces to be unshared are indicated via
+options.  Unshareable namespaces are:
 .TP
 .BR "mount namespace"
-mounting and unmounting filesystems will not affect rest of the system
-(\fBCLONE_NEWNS\fP flag),
+Mounting and unmounting filesystems will not affect the rest of the system
+(\fBCLONE_NEWNS\fP flag), except for filesystems which are explicitly marked as
+shared (with \fBmount --make-shared\fP; see \fI/proc/self/mountinfo\fP for the
+\fBshared\fP flags).
+
+It's recommended to use \fBmount --make-rprivate\fP or \fBmount --make-rslave\fP
+after \fBunshare --mount\fP to make sure that mountpoints in the new namespace
+are really unshared from parental namespace.
 .TP
 .BR "UTS namespace"
-setting hostname, domainname will not affect rest of the system
-(\fBCLONE_NEWUTS\fP flag),
+Setting hostname or domainname will not affect the rest of the system.
+(\fBCLONE_NEWUTS\fP flag)
 .TP
 .BR "IPC namespace"
-process will have indpendent namespace for System V message queues, semaphore
-sets and shared memory segments (\fBCLONE_NEWIPC\fP flag),
+The process will have an independent namespace for System V message queues,
+semaphore sets and shared memory segments.  (\fBCLONE_NEWIPC\fP flag)
 .TP
 .BR "network namespace"
-process will have independent IPv4 and IPv6 stacks, IP routing tables, firewall
-rules, the \fI/proc/net\fP and \fI/sys/class/net\fP directory trees, sockets
-etc. (\fBCLONE_NEWNET\fP flag).
+The process will have independent IPv4 and IPv6 stacks, IP routing tables,
+firewall rules, the \fI/proc/net\fP and \fI/sys/class/net\fP directory trees,
+sockets, etc.  (\fBCLONE_NEWNET\fP flag)
 .TP
-See the clone(2) for exact semantics of the flags.
+.BR "pid namespace"
+Children will have a distinct set of PID to process mappings from their parent.
+(\fBCLONE_NEWPID\fP flag)
+.PP
+See \fBclone\fR(2) for the exact semantics of the flags.
 .SH OPTIONS
 .TP
 .BR \-h , " \-\-help"
-Print a help message,
+Display help text and exit.
+.TP
+.BR \-i , " \-\-ipc"
+Unshare the IPC namespace.
 .TP
 .BR \-m , " \-\-mount"
-Unshare the mount namespace,
+Unshare the mount namespace.
+.TP
+.BR \-n , " \-\-net"
+Unshare the network namespace.
+.TP
+.BR \-p , " \-\-pid"
+Unshare the pid namespace.
+See also the \fB--fork\fP and \fB--mount-proc\fP options.
 .TP
 .BR \-u , " \-\-uts"
-Unshare the UTC namespace,
+Unshare the UTS namespace.
 .TP
-.BR \-i , " \-\-ipc"
-Unshare the IPC namespace,
+.BR \-f , " \-\-fork"
+Fork the specified \fIprogram\fR as a child process of \fBunshare\fR rather than
+running it directly.  This is useful when creating a new pid namespace.
 .TP
-.BR \-n , " \-\-net"
-Unshare the network namespace.
+.BR \-\-mount-proc "[=\fImountpoint\fP]"
+Just before running the program, mount the proc filesystem at the \fImountpoint\fP
+(default is /proc).  This is useful when creating a new pid namespace.  It also
+implies creating a new mount namespace since the /proc mount would otherwise
+mess up existing programs on the system. The new proc filesystem is explicitly
+mounted as private (by MS_PRIVATE|MS_REC).
 .SH SEE ALSO
-unshare(2), clone(2)
+.BR unshare (2),
+.BR clone (2),
+.BR mount (8)
 .SH BUGS
 None known so far.
 .SH AUTHOR
 Mikhail Gusarov <dottedmag@dottedmag.net>
 .SH AVAILABILITY
-The unshare command is part of the util-linux-ng package and is available from
-ftp://ftp.kernel.org/pub/linux/utils/util-linux-ng/.
+The unshare command is part of the util-linux package and is available from
+ftp://ftp.kernel.org/pub/linux/utils/util-linux/.
diff --git a/sys-utils/unshare.c b/sys-utils/unshare.c
index df75d17..bb0d694 100644
--- a/sys-utils/unshare.c
+++ b/sys-utils/unshare.c
@@ -15,81 +15,88 @@
  *
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, write to the Free Software Foundation, Inc.,
- * 675 Mass Ave, Cambridge, MA 02139, USA.
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  */
 
-#include <err.h>
 #include <errno.h>
 #include <getopt.h>
 #include <sched.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>
+#include <sys/wait.h>
+#include <sys/mount.h>
 
 #include "nls.h"
+#include "c.h"
+#include "namespace.h"
+#include "exec_shell.h"
+#include "xalloc.h"
+#include "pathnames.h"
 
-#ifndef CLONE_NEWSNS
-# define CLONE_NEWNS 0x00020000
-#endif
-#ifndef CLONE_NEWUTS
-# define CLONE_NEWUTS 0x04000000
-#endif
-#ifndef CLONE_NEWIPC
-# define CLONE_NEWIPC 0x08000000
-#endif
-#ifndef CLONE_NEWNET
-# define CLONE_NEWNET 0x40000000
-#endif
-
-#ifndef HAVE_UNSHARE
-# include <sys/syscall.h>
-
-static int unshare(int flags)
-{
-	return syscall(SYS_unshare, flags);
-}
-#endif
+#include "mount/mount_constants.h"
 
 static void usage(int status)
 {
 	FILE *out = status == EXIT_SUCCESS ? stdout : stderr;
 
-	fprintf(out, _("Usage: %s [options] <program> [args...]\n"),
-		program_invocation_short_name);
+	fputs(USAGE_HEADER, out);
+	fprintf(out,
+	      _(" %s [options] <program> [args...]\n"),	program_invocation_short_name);
 
-	fputs(_("Run program with some namespaces unshared from parent\n\n"
-		"  -h, --help        usage information (this)\n"
-		"  -m, --mount       unshare mounts namespace\n"
-		"  -u, --uts         unshare UTS namespace (hostname etc)\n"
-		"  -i, --ipc         unshare System V IPC namespace\n"
-		"  -n, --net         unshare network namespace\n"), out);
+	fputs(USAGE_OPTIONS, out);
+	fputs(_(" -m, --mount               unshare mounts namespace\n"), out);
+	fputs(_(" -u, --uts                 unshare UTS namespace (hostname etc)\n"), out);
+	fputs(_(" -i, --ipc                 unshare System V IPC namespace\n"), out);
+	fputs(_(" -n, --net                 unshare network namespace\n"), out);
+	fputs(_(" -p, --pid                 unshare pid namespace\n"), out);
+	fputs(_(" -f, --fork                fork before launching <program>\n"), out);
+	fputs(_("     --mount-proc[=<dir>]  mount proc filesystem first (implies --mount)\n"), out);
+
+	fputs(USAGE_SEPARATOR, out);
+	fputs(USAGE_HELP, out);
+	fputs(USAGE_VERSION, out);
+	fprintf(out, USAGE_MAN_TAIL("unshare(1)"));
 
-	fprintf(out, _("\nFor more information see unshare(1).\n"));
 	exit(status);
 }
 
 int main(int argc, char *argv[])
 {
-	struct option longopts[] = {
+	enum {
+		OPT_MOUNTPROC = CHAR_MAX + 1
+	};
+	static const struct option longopts[] = {
 		{ "help", no_argument, 0, 'h' },
+		{ "version", no_argument, 0, 'V'},
 		{ "mount", no_argument, 0, 'm' },
 		{ "uts", no_argument, 0, 'u' },
 		{ "ipc", no_argument, 0, 'i' },
 		{ "net", no_argument, 0, 'n' },
+		{ "pid", no_argument, 0, 'p' },
+		{ "fork", no_argument, 0, 'f' },
+		{ "mount-proc", optional_argument, 0, OPT_MOUNTPROC },
+		{ NULL, 0, 0, 0 }
 	};
 
 	int unshare_flags = 0;
+	int c, forkit = 0, maproot = 0;
+	const char *procmnt = NULL;
 
-	int c;
-
-	setlocale(LC_MESSAGES, "");
+	setlocale(LC_ALL, "");
 	bindtextdomain(PACKAGE, LOCALEDIR);
 	textdomain(PACKAGE);
 
-	while((c = getopt_long(argc, argv, "hmuin", longopts, NULL)) != -1) {
-		switch(c) {
+	while ((c = getopt_long(argc, argv, "+fhVmuinp", longopts, NULL)) != -1) {
+		switch (c) {
+		case 'f':
+			forkit = 1;
+			break;
 		case 'h':
 			usage(EXIT_SUCCESS);
+		case 'V':
+			printf(UTIL_LINUX_VERSION);
+			return EXIT_SUCCESS;
 		case 'm':
 			unshare_flags |= CLONE_NEWNS;
 			break;
@@ -102,18 +109,49 @@ int main(int argc, char *argv[])
 		case 'n':
 			unshare_flags |= CLONE_NEWNET;
 			break;
+		case 'p':
+			unshare_flags |= CLONE_NEWPID;
+			break;
+		case OPT_MOUNTPROC:
+			unshare_flags |= CLONE_NEWNS;
+			procmnt = optarg ? optarg : "/proc";
+			break;
 		default:
 			usage(EXIT_FAILURE);
 		}
 	}
 
-	if(optind >= argc)
-		usage(EXIT_FAILURE);
-
-	if(-1 == unshare(unshare_flags))
+	if (-1 == unshare(unshare_flags))
 		err(EXIT_FAILURE, _("unshare failed"));
 
-	execvp(argv[optind], argv + optind);
+	if (forkit) {
+		int status;
+		pid_t pid = fork();
+
+		switch(pid) {
+		case -1:
+			err(EXIT_FAILURE, _("fork failed"));
+		case 0:	/* child */
+			break;
+		default: /* parent */
+			if (waitpid(pid, &status, 0) == -1)
+				err(EXIT_FAILURE, _("waitpid failed"));
+			if (WIFEXITED(status))
+				return WEXITSTATUS(status);
+			else if (WIFSIGNALED(status))
+				kill(getpid(), WTERMSIG(status));
+			err(EXIT_FAILURE, _("child exit failed"));
+		}
+	}
+
+	if (procmnt &&
+	    (mount("none", procmnt, NULL, MS_PRIVATE|MS_REC, NULL) != 0 ||
+	     mount("proc", procmnt, "proc", MS_NOSUID|MS_NOEXEC|MS_NODEV, NULL) != 0))
+			err(EXIT_FAILURE, _("mount %s failed"), procmnt);
 
-	err(EXIT_FAILURE, _("exec %s failed"), argv[optind]);
+	if (optind < argc) {
+		execvp(argv[optind], argv + optind);
+		err(EXIT_FAILURE, _("failed to execute %s"), argv[optind]);
+	}
+	exec_shell();
 }
-- 
1.7.1

