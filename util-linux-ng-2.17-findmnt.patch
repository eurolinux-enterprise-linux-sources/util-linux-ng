diff -up util-linux-ng-2.17.2/config/include-Makefile.am.kzak util-linux-ng-2.17.2/config/include-Makefile.am
--- util-linux-ng-2.17.2/config/include-Makefile.am.kzak	2010-03-18 23:11:23.000000000 +0100
+++ util-linux-ng-2.17.2/config/include-Makefile.am	2012-10-08 12:51:49.127688833 +0200
@@ -30,3 +30,13 @@ ul_libuuid_la = $(top_builddir)/shlibs/u
 $(ul_libuuid_la):
 	$(MAKE) -C $(ul_libuuid_builddir)
 
+# mount
+ul_libmount_srcdir = $(top_srcdir)/shlibs/mount/src
+ul_libmount_builddir = $(top_builddir)/shlibs/mount/src
+ul_libmount_la = $(top_builddir)/shlibs/mount/src/libmount.la
+
+# mount.h is generated by ./configure script and stored in build directory
+ul_libmount_incdir = $(ul_libmount_builddir)
+
+$(ul_libmount_la):
+	$(MAKE) -C $(ul_libmount_builddir)
diff -up util-linux-ng-2.17.2/configure.ac.kzak util-linux-ng-2.17.2/configure.ac
--- util-linux-ng-2.17.2/configure.ac.kzak	2012-10-08 12:51:48.983687943 +0200
+++ util-linux-ng-2.17.2/configure.ac	2012-10-08 12:51:49.128688839 +0200
@@ -35,6 +35,13 @@ LIBUUID_LT_MINOR=3
 LIBUUID_LT_MICRO=0
 LIBUUID_VERSION_INFO=`expr $LIBUUID_LT_MAJOR + $LIBUUID_LT_MINOR`:$LIBUUID_LT_MICRO:$LIBUUID_LT_MINOR
 
+dnl partial libmount backport to RHEL6
+LIBMOUNT_VERSION="$PACKAGE_VERSION_MAJOR.$PACKAGE_VERSION_MINOR.$PACKAGE_VERSION_RELEASE"
+LIBMOUNT_LT_MAJOR=1
+LIBMOUNT_LT_MINOR=1
+LIBMOUNT_LT_MICRO=0
+LIBMOUNT_VERSION_INFO=`expr $LIBMOUNT_LT_MAJOR + $LIBMOUNT_LT_MINOR`:$LIBMOUNT_LT_MICRO:$LIBMOUNT_LT_MINOR
+
 # Check whether exec_prefix=/usr:
 case $exec_prefix:$prefix in
 NONE:NONE | NONE:/usr | /usr:*)
@@ -390,6 +397,22 @@ AM_CONDITIONAL(HAVE_BLKID, test "x$have_
 
 AC_ARG_VAR([BLKID_LIBS_STATIC], [-l options for linking statically with blkid])
 
+AC_ARG_ENABLE([libmount],
+  AS_HELP_STRING([--disable-libmount], [do not build libmount]),
+  [], enable_libmount=yes
+)
+
+case "$enable_libblkid:$enable_libmount" in
+no:yes)
+  AC_MSG_ERROR([cannot enable libmount when libblkid is disabled]) ;;
+esac
+
+AC_SUBST([LIBMOUNT_VERSION])
+AC_SUBST([LIBMOUNT_VERSION_INFO])
+AC_DEFINE_UNQUOTED(LIBMOUNT_VERSION, "$LIBMOUNT_VERSION", [libmount version string])
+AM_CONDITIONAL(BUILD_LIBMOUNT, test "x$enable_libmount" = xyes)
+
+
 UTIL_CHECK_LIB(util, openpty)
 UTIL_CHECK_LIB(termcap, tgetnum)
 
@@ -1054,6 +1077,9 @@ shlibs/blkid/src/superblocks/Makefile
 shlibs/blkid/src/topology/Makefile
 shlibs/blkid/src/partitions/Makefile
 shlibs/blkid/samples/Makefile
+shlibs/mount/Makefile
+shlibs/mount/src/Makefile
+shlibs/mount/src/mount.h
 shlibs/uuid/uuid.pc
 shlibs/uuid/Makefile
 shlibs/uuid/man/Makefile
diff -up util-linux-ng-2.17.2/include/env.h.kzak util-linux-ng-2.17.2/include/env.h
--- util-linux-ng-2.17.2/include/env.h.kzak	2010-01-28 15:57:59.000000000 +0100
+++ util-linux-ng-2.17.2/include/env.h	2012-10-08 12:51:49.129688845 +0200
@@ -1,2 +1,2 @@
 extern void sanitize_env (void);
-
+extern char *safe_getenv(const char *arg);
diff -up util-linux-ng-2.17.2/include/pathnames.h.kzak util-linux-ng-2.17.2/include/pathnames.h
--- util-linux-ng-2.17.2/include/pathnames.h.kzak	2012-10-08 12:51:49.013688128 +0200
+++ util-linux-ng-2.17.2/include/pathnames.h	2012-10-08 12:51:49.129688845 +0200
@@ -75,6 +75,7 @@
 #define _PATH_PROC_MOUNTS	"/proc/mounts"
 #define _PATH_PROC_PARTITIONS	"/proc/partitions"
 #define _PATH_PROC_DEVICES	"/proc/devices"
+#define _PATH_PROC_MOUNTINFO	"/proc/self/mountinfo"
 
 #define _PATH_SYS_BLOCK		"/sys/block"
 #define _PATH_SYS_DEVBLOCK	"/sys/dev/block"
diff -up util-linux-ng-2.17.2/lib/env.c.kzak util-linux-ng-2.17.2/lib/env.c
--- util-linux-ng-2.17.2/lib/env.c.kzak	2010-01-28 15:57:59.000000000 +0100
+++ util-linux-ng-2.17.2/lib/env.c	2012-10-08 12:51:49.129688845 +0200
@@ -8,6 +8,17 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#ifdef HAVE_SYS_PRCTL_H
+#include <sys/prctl.h>
+#else
+#define PR_GET_DUMPABLE 3
+#endif
+#if (!defined(HAVE_PRCTL) && defined(linux))
+#include <sys/syscall.h>
+#endif
+#include <unistd.h>
+#include <sys/types.h>
+
 #include "env.h"
 
 extern char **environ;
@@ -71,3 +82,25 @@ sanitize_env(void)
         }
 }
 
+char *safe_getenv(const char *arg)
+{
+	uid_t ruid = getuid();
+
+	if (ruid != 0 || (ruid != geteuid()) || (getgid() != getegid()))
+		return NULL;
+#if HAVE_PRCTL
+	if (prctl(PR_GET_DUMPABLE, 0, 0, 0, 0) == 0)
+		return NULL;
+#else
+#if (defined(linux) && defined(SYS_prctl))
+	if (syscall(SYS_prctl, PR_GET_DUMPABLE, 0, 0, 0, 0) == 0)
+		return NULL;
+#endif
+#endif
+
+#ifdef HAVE___SECURE_GETENV
+	return __secure_getenv(arg);
+#else
+	return getenv(arg);
+#endif
+}
diff -up util-linux-ng-2.17.2/misc-utils/findmnt.8.kzak util-linux-ng-2.17.2/misc-utils/findmnt.8
--- util-linux-ng-2.17.2/misc-utils/findmnt.8.kzak	2012-10-08 12:51:49.130688851 +0200
+++ util-linux-ng-2.17.2/misc-utils/findmnt.8	2012-10-08 12:51:49.130688851 +0200
@@ -0,0 +1,163 @@
+.\" -*- nroff -*-
+.TH FINDMNT 8 "Apr 2010" "Version 1.0"
+.SH NAME
+findmnt \- find a filesystem
+.SH SYNOPSIS
+.B findmnt
+.RB [ options ]
+.sp
+.B findmnt
+.RB [ options ]
+.IR device | mountpoint
+.sp
+.B findmnt
+.RB [ options ]
+.RB [ \--source ]
+.IR device
+.RB [ \--target ]
+.IR mountpoint
+.SH DESCRIPTION
+.B findmnt
+will list all mounted filesytems or search for a filesystem.  The
+.B findmnt
+command is able to search in
+.IR /etc/fstab ,
+.IR /etc/fstab.d ,
+.IR /etc/mtab
+or
+.IR /proc/self/mountinfo .
+If
+.IR device
+or
+.IR mountpoint
+is not given, all filesystems are shown.
+.PP
+The command prints all mounted filesystems in the tree-like format by default.
+.SH OPTIONS
+.IP "\fB\-h, \-\-help\fP"
+Print help and exit.
+.IP "\fB\-s, \-\-fstab\fP"
+Search in
+.IR /etc/fstab
+and
+.IR /etc/fstab.d .
+The output is in the list format (see --list).
+.IP "\fB\-m, \-\-mtab\fP"
+Search in
+.IR /etc/mtab .
+The output is in the list format (see --list).
+.IP "\fB\-k, \-\-kernel\fP"
+Search in
+.IR /proc/self/mountinfo .
+The output is in the tree-like format.  This is the default.
+.IP "\fB\-c, \-\-canonicalize\fP"
+Canonicalize all printed paths.
+.IP "\fB\-d, \-\-direction \fIword\fP"
+The search direction -
+.IR forward
+or
+.IR backward .
+.IP "\fB\-e, \-\-evaluate\fP"
+Convert all tags (LABEL or UUID) to the device names.
+.IP "\fB\-f, \-\-first-only\fP"
+Print the first matching filesystem only.
+.IP "\fB\-i, \-\-invert\fP"
+Invert the sense of matching.
+.IP "\fB\-l, \-\-list\fP"
+Use the list output format. This output format is automatically enabled if the
+output is restricted by \fB\-t\fP, \fB\-O\fP, \fB\-S\fP or \fB\-T\fP
+option and the option \fB\-\-submounts\fP is not used.
+.IP "\fB\-v, \-\-nofsroot\fP"
+Do not print a [/dir] in the SOURCE column for bind-mounts or btrfs subvolumes.
+.IP "\fB\-n, \-\-noheadings\fP"
+Do not print a header line.
+.IP "\fB\-u, \-\-notruncate\fP"
+Do not truncate text in columns.  The default is to not truncate the
+.BR TARGET ,
+.BR SOURCE ,
+.BR UUID
+and
+.BR LABEL
+columns.  This option disables text truncation also in all other columns.
+.IP "\fB\-O, \-\-options \fIlist\fP"
+Used to limit the set of printed filesystems.  More than one option
+may be specified in a comma-separated list.  The
+.B \-t
+and
+.B \-O
+options are cumulative in effect.  It is different from
+.B \-t
+in that each option is matched exactly; a leading
+.I no
+at the beginning
+of one option does not negate the rest.  For more details see
+.BR mount (8).
+.IP "\fB\-o, \-\-output \fIlist\fP"
+Define output columns.  Currently supported are
+.BR SOURCE ,
+.BR TARGET ,
+.BR FSTYPE ,
+.BR OPTIONS ,
+.BR VFS-OPTIONS ,
+.BR FS-OPTIONS ,
+.BR LABEL
+and
+.BR UUID .
+The
+.BR TARGET
+column contains tree formatting if the
+.B \-\-list
+or
+.B \-\-raw
+options are not specified.
+.IP "\fB\-r, \-\-raw\fP"
+Use raw output format.
+.IP "\fB\-a, \-\-ascii\fP"
+Use ascii characters for tree formatting.
+.IP "\fB\-t, \-\-types \fIlist\fP"
+Used to limit the set of printed filesystems.  More than one type may be
+specified in a comma-separated list.  The list of filesystem types can be
+prefixed with
+.I no
+to specify the filesystem types on which no action should be taken.  For
+more details see
+.BR mount (8).
+.IP "\fB\-R, \-\-submounts\fP"
+Print recursively all submounts for the selected filesystems. The restrictions
+defined by options \fB\-t\fP, \fB\-O\fP, \fB\-S\fP, \fB\-T\fP and
+\fB\--direction\fP are not applied to submounts. All submounts are always
+printed in tree-like order. The option enables the tree-like output format by
+default. This option has no effect for \fB\-\-mtab\fP or \fB\-\-fstab\fP.
+.IP "\fB\-S, \-\-source \fIspec\fP"
+Explicitly define the mount source.  Supported are device, LABEL= or UUID=.
+.IP "\fB\-T, \-\-target \fIdir\fP"
+Explicitly define the mount target (mountpoint directory).
+.SH EXAMPLES
+.IP "\fBfindmnt \-\-fstab \-t nfs\fP"
+Prints all nfs filesystems defined in
+.IR /etc/fstab .
+.IP "\fBfindmnt \-\-fstab /mnt/foo\fP"
+Prints all
+.IR /etc/fstab
+filesystems where the mountpoint directory is /mnt/foo.  It also prints bind mounts where /mnt/foo
+is a source.
+.IP "\fBfindmnt \-\-fstab --target /mnt/foo\fP"
+Prints all
+.IR /etc/fstab
+filesystems where the mountpoint directory is /mnt/foo.
+.IP "\fBfindmnt --fstab --evaluate\fP"
+Prints all
+.IR /etc/fstab
+filesystems and converts LABEL= and UUID= tags to the real device names.
+.IP "\fBfindmnt -n --raw --evaluate --output=target LABEL=/boot
+Prints only the mountpoint where the filesystem with label "/boot" is mounted.
+.SH AUTHORS
+.nf
+Karel Zak <kzak@redhat.com>
+.fi
+.SH SEE ALSO
+.BR mount (8),
+.BR fstab (5)
+.SH AVAILABILITY
+The findmnt command is part of the util-linux package and is available from
+ftp://ftp.kernel.org/pub/linux/utils/util-linux/.
diff -up util-linux-ng-2.17.2/misc-utils/findmnt.c.kzak util-linux-ng-2.17.2/misc-utils/findmnt.c
--- util-linux-ng-2.17.2/misc-utils/findmnt.c.kzak	2012-10-08 12:51:49.131688857 +0200
+++ util-linux-ng-2.17.2/misc-utils/findmnt.c	2012-10-08 12:52:54.420092668 +0200
@@ -0,0 +1,806 @@
+/*
+ * findmnt(8)
+ *
+ * Copyright (C) 2010 Red Hat, Inc. All rights reserved.
+ * Written by Karel Zak <kzak@redhat.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it would be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <err.h>
+#include <unistd.h>
+#include <getopt.h>
+#include <string.h>
+#include <termios.h>
+#ifdef HAVE_SYS_IOCTL_H
+#include <sys/ioctl.h>
+#endif
+#include <assert.h>
+
+#define USE_UNSTABLE_LIBMOUNT_API
+#include <mount.h>
+
+#include "pathnames.h"
+#include "nls.h"
+#include "c.h"
+#include "tt.h"
+#include "strutils.h"
+
+/* flags */
+enum {
+	FL_EVALUATE	= (1 << 1),
+	FL_CANONICALIZE = (1 << 2),
+	FL_FIRSTONLY	= (1 << 3),
+	FL_INVERT	= (1 << 4),
+	FL_NOSWAPMATCH	= (1 << 6),
+	FL_NOFSROOT	= (1 << 7),
+	FL_SUBMOUNTS	= (1 << 8),
+};
+
+/* column IDs */
+enum {
+	COL_SOURCE,
+	COL_TARGET,
+	COL_FSTYPE,
+	COL_OPTIONS,
+	COL_VFS_OPTIONS,
+	COL_FS_OPTIONS,
+	COL_LABEL,
+	COL_UUID,
+	COL_MAJMIN,
+
+	__NCOLUMNS
+};
+
+/* column names */
+struct colinfo {
+	const char	*name;		/* header */
+	double		whint;		/* width hint (N < 1 is in percent of termwidth) */
+	int		truncate;	/* boolean */
+	const char	*match;		/* pattern for match_func() */
+};
+
+/* columns descriptions */
+struct colinfo infos[__NCOLUMNS] = {
+	[COL_SOURCE]  = { "SOURCE",     0.25, FALSE },
+	[COL_TARGET]  = { "TARGET",     0.30, FALSE },
+	[COL_FSTYPE]  = { "FSTYPE",     0.10, TRUE },
+	[COL_OPTIONS] = { "OPTIONS",    0.10, TRUE },
+	[COL_VFS_OPTIONS] = { "VFS-OPTIONS", 0.20, TRUE },
+	[COL_FS_OPTIONS] = { "FS-OPTIONS", 0.10, TRUE },
+	[COL_LABEL]   = { "LABEL",      0.10, FALSE },
+	[COL_UUID]    = { "UUID",         36, FALSE },
+	[COL_MAJMIN] = { "MAJ:MIN",        6, FALSE },
+};
+
+/* global flags */
+int flags;
+int tt_flags = 0;
+
+/* array with IDs of enabled columns */
+int columns[__NCOLUMNS];
+int ncolumns;
+
+/* libmount cache */
+mnt_cache *cache;
+
+static int get_column_id(int num)
+{
+	assert(num < ncolumns);
+	assert(columns[num] < __NCOLUMNS);
+	return columns[num];
+}
+
+static struct colinfo *get_column_info(int num)
+{
+	return &infos[ get_column_id(num) ];
+}
+
+static const char *column_id_to_name(int id)
+{
+	assert(id < __NCOLUMNS);
+	return infos[id].name;
+}
+
+static const char *get_column_name(int num)
+{
+	return get_column_info(num)->name;
+}
+
+static float get_column_whint(int num)
+{
+	return get_column_info(num)->whint;
+}
+
+static int get_column_truncate(int num)
+{
+	return get_column_info(num)->truncate;
+}
+
+static const char *get_match(int id)
+{
+	assert(id < __NCOLUMNS);
+	return infos[id].match;
+}
+
+static void set_match(int id, const char *match)
+{
+	assert(id < __NCOLUMNS);
+	infos[id].match = match;
+}
+
+/*
+ * "findmnt" without any filter
+ */
+static int is_listall_mode(void)
+{
+	return (!get_match(COL_SOURCE) &&
+		!get_match(COL_TARGET) &&
+		!get_match(COL_FSTYPE) &&
+		!get_match(COL_OPTIONS));
+}
+
+/*
+ * findmnt --first-only <devname|TAG=|mountpoint>
+ *
+ * ... it works like "mount <devname|TAG=|mountpoint>"
+ */
+static int is_mount_compatible_mode(void)
+{
+	if (!get_match(COL_SOURCE))
+	       return 0;		/* <devname|TAG=|mountpoint> is required */
+	if (get_match(COL_FSTYPE) || get_match(COL_OPTIONS))
+		return 0;		/* cannot be restricted by -t or -O */
+	if (!(flags & FL_FIRSTONLY))
+		return 0;		/* we have to return the first entry only */
+
+	return 1;			/* ok */
+}
+
+static void set_all_columns_truncate(int set)
+{
+	int i;
+
+	for (i = 0; i < __NCOLUMNS; i++)
+		infos[i].truncate = set;
+}
+
+/*
+ * converts @name to column ID
+ */
+static int column_name_to_id(const char *name, size_t namesz)
+{
+	int i;
+
+	for (i = 0; i < __NCOLUMNS; i++) {
+		const char *cn = column_id_to_name(i);
+
+		if (!strncasecmp(name, cn, namesz) && !*(cn + namesz))
+			return i;
+	}
+	warnx(_("unknown column: %s"), name);
+	return -1;
+}
+
+/* Returns LABEL or UUID */
+static const char *get_tag(mnt_fs *fs, const char *tagname)
+{
+	const char *t, *v, *res;
+
+	if (!mnt_fs_get_tag(fs, &t, &v) && !strcmp(t, tagname))
+		res = v;
+	else {
+		res = mnt_fs_get_source(fs);
+		if (res)
+			res = mnt_resolve_spec(res, cache);
+		if (res)
+			res = mnt_cache_find_tag_value(cache, res, tagname);
+	}
+
+	return res;
+}
+
+/* reads FS data from libmount
+ * TODO: add function that will deallocate data allocated by get_data()
+ */
+static const char *get_data(mnt_fs *fs, int num)
+{
+	const char *str = NULL;
+
+	switch(get_column_id(num)) {
+	case COL_SOURCE:
+	{
+		const char *root = mnt_fs_get_root(fs);
+
+		str = mnt_fs_get_srcpath(fs);
+
+		if (str && (flags & FL_CANONICALIZE))
+			str = mnt_resolve_path(str, cache);
+		if (!str) {
+			str = mnt_fs_get_source(fs);
+
+			if (str && (flags & FL_EVALUATE))
+				str = mnt_resolve_spec(str, cache);
+		}
+		if (root && str && !(flags & FL_NOFSROOT) && strcmp(root, "/")) {
+			char *tmp;
+
+			if (asprintf(&tmp, "%s[%s]", str, root) > 0)
+				str = tmp;
+		}
+		break;
+	}
+	case COL_TARGET:
+		str = mnt_fs_get_target(fs);
+		break;
+	case COL_FSTYPE:
+		str = mnt_fs_get_fstype(fs);
+		break;
+	case COL_OPTIONS:
+		str = mnt_fs_strdup_options(fs);
+		break;
+	case COL_VFS_OPTIONS:
+		str = mnt_fs_get_vfs_options(fs);
+		break;
+	case COL_FS_OPTIONS:
+		str = mnt_fs_get_fs_options(fs);
+		break;
+	case COL_UUID:
+		str = get_tag(fs, "UUID");
+		break;
+	case COL_LABEL:
+		str = get_tag(fs, "LABEL");
+		break;
+	case COL_MAJMIN:
+	{
+		dev_t devno = mnt_fs_get_devno(fs);
+		if (devno) {
+			char *tmp;
+			int rc = 0;
+			if (tt_flags & TT_FL_RAW)
+				rc = asprintf(&tmp, "%u:%u", major(devno), minor(devno));
+			else
+				rc = asprintf(&tmp, "%3u:%-3u", major(devno), minor(devno));
+			if (rc)
+				str = tmp;
+		}
+	}
+	default:
+		break;
+	}
+	return str;
+}
+
+/* adds one line to the output @tab */
+static struct tt_line *add_line(struct tt *tt, mnt_fs *fs,
+					struct tt_line *parent)
+{
+	int i;
+	struct tt_line *line = tt_add_line(tt, parent);
+
+	if (!line) {
+		warn(_("failed to add line to output"));
+		return NULL;
+	}
+	for (i = 0; i < ncolumns; i++)
+		tt_line_set_data(line, i, get_data(fs, i));
+
+	tt_line_set_userdata(line, fs);
+	return line;
+}
+
+static int has_line(struct tt *tt, mnt_fs *fs)
+{
+	struct list_head *p;
+
+	list_for_each(p, &tt->tb_lines) {
+		struct tt_line *ln = list_entry(p, struct tt_line, ln_lines);
+		if ((mnt_fs *) ln->userdata == fs)
+			return 1;
+	}
+	return 0;
+}
+
+/* reads filesystems from @tb (libmount) and fillin @tt (output table) */
+static int create_treenode(struct tt *tt, mnt_tab *tb,
+				mnt_fs *fs, struct tt_line *parent_line)
+{
+	mnt_fs *chld = NULL;
+	mnt_iter *itr = NULL;
+	struct tt_line *line;
+	int rc = -1;
+
+	if (!fs) {
+		/* first call, get root FS */
+		if (mnt_tab_get_root_fs(tb, &fs))
+			goto leave;
+		parent_line = NULL;
+
+	} else if ((flags & FL_SUBMOUNTS) && has_line(tt, fs))
+		return 0;
+
+	itr = mnt_new_iter(MNT_ITER_FORWARD);
+	if (!itr)
+		goto leave;
+
+	line = add_line(tt, fs, parent_line);
+	if (!line)
+		goto leave;
+
+	/*
+	 * add all children to the output table
+	 */
+	while(mnt_tab_next_child_fs(tb, itr, fs, &chld) == 0) {
+		if (create_treenode(tt, tb, chld, line))
+			goto leave;
+	}
+	rc = 0;
+leave:
+	mnt_free_iter(itr);
+	return rc;
+}
+
+/* error callback */
+static int parser_errcb(mnt_tab *tb, const char *filename, int line)
+{
+	warn(_("%s: parse error at line %d"), filename, line);
+	return 0;
+}
+
+/* calls libmount fstab/mtab/mountinfo parser */
+static mnt_tab *parse_tabfile(const char *path)
+{
+	int rc;
+	mnt_tab *tb = mnt_new_tab();
+
+	if (!tb) {
+		warn(_("failed to initialize libmount tab"));
+		return NULL;
+	}
+
+	mnt_tab_set_parser_errcb(tb, parser_errcb);
+
+	if (!strcmp(path, _PATH_MNTTAB))
+		rc = mnt_tab_parse_fstab(tb, NULL);
+	else if (!strcmp(path, _PATH_MOUNTED))
+		rc = mnt_tab_parse_mtab(tb, NULL);
+	else
+		rc = mnt_tab_parse_file(tb, path);
+
+	if (rc) {
+		mnt_free_tab(tb);
+		warn(_("can't read: %s"), path);
+		return NULL;
+	}
+	return tb;
+}
+
+/* filter function for libmount (mnt_tab_find_next_fs()) */
+static int match_func(mnt_fs *fs, void *data)
+{
+	int rc = flags & FL_INVERT ? 1 : 0;
+	const char *m;
+
+	m = get_match(COL_TARGET);
+	if (m && !mnt_fs_match_target(fs, m, cache))
+		return rc;
+
+	m = get_match(COL_SOURCE);
+	if (m && !mnt_fs_match_source(fs, m, cache))
+		return rc;
+
+	m = get_match(COL_FSTYPE);
+	if (m && !mnt_fs_match_fstype(fs, m))
+		return rc;
+
+	m = get_match(COL_OPTIONS);
+	if (m && !mnt_fs_match_options(fs, m))
+		return rc;
+
+	return !rc;
+}
+
+/* iterate over filesystems in @tb */
+static mnt_fs *get_next_fs(mnt_tab *tb, mnt_iter *itr)
+{
+	mnt_fs *fs = NULL;
+
+	if (is_listall_mode()) {
+		/*
+		 * Print whole file
+		 */
+		mnt_tab_next_fs(tb, itr, &fs);
+
+	} else if (is_mount_compatible_mode()) {
+		/*
+		 * Look up for FS in the same way how mount(8) searchs in fstab
+		 *
+		 *   findmnt -f <spec>
+		 */
+		fs = mnt_tab_find_source(tb, get_match(COL_SOURCE),
+					mnt_iter_get_direction(itr));
+
+		if (!fs && !(flags & FL_NOSWAPMATCH))
+			fs = mnt_tab_find_target(tb, get_match(COL_SOURCE),
+					mnt_iter_get_direction(itr));
+	} else {
+		/*
+		 * Look up for all matching entries
+		 *
+		 *    findmnt [-l] <source> <target> [-O <options>] [-t <types>]
+		 *    findmnt [-l] <spec> [-O <options>] [-t <types>]
+		 */
+again:
+		mnt_tab_find_next_fs(tb, itr, match_func,  NULL, &fs);
+
+		if (!fs &&
+		    !(flags & FL_NOSWAPMATCH) &&
+		    !get_match(COL_TARGET) && get_match(COL_SOURCE)) {
+
+			/* swap 'spec' and target. */
+			set_match(COL_TARGET, get_match(COL_SOURCE));
+			set_match(COL_SOURCE, NULL);
+			mnt_reset_iter(itr, -1);
+
+			goto again;
+		}
+	}
+
+	return fs;
+}
+
+static int add_matching_lines(mnt_tab *tb, struct tt *tt, int direction)
+{
+	mnt_iter *itr = NULL;
+	mnt_fs *fs;
+	int nlines = 0, rc = -1;
+
+	itr = mnt_new_iter(direction);
+	if (!itr) {
+		warn(_("failed to initialize libmount iterator"));
+		goto done;
+	}
+
+	while((fs = get_next_fs(tb, itr))) {
+		if ((tt_flags & TT_FL_TREE) || (flags & FL_SUBMOUNTS))
+			rc = create_treenode(tt, tb, fs, NULL);
+		else
+			rc = !add_line(tt, fs, NULL);
+		if (rc)
+			goto done;
+		nlines++;
+		if (flags & FL_FIRSTONLY)
+			break;
+		flags |= FL_NOSWAPMATCH;
+	}
+
+	if (nlines)
+		rc = 0;
+done:
+	mnt_free_iter(itr);
+	return rc;
+}
+
+static void __attribute__((__noreturn__)) usage(FILE *out)
+{
+	int i;
+
+	fprintf(out, _(
+	"\nUsage:\n"
+	" %1$s [options]\n"
+	" %1$s [options] <device> | <mountpoint>\n"
+	" %1$s [options] <device> <mountpoint>\n"
+	" %1$s [options] [--source <device>] [--target <mountpoint>]\n"),
+		program_invocation_short_name);
+
+	fprintf(out, _(
+	"\nOptions:\n"
+	" -s, --fstab            search in static table of filesystems\n"
+	" -m, --mtab             search in table of mounted filesystems\n"
+	" -k, --kernel           search in kernel table of mounted \n"
+        "                        filesystems (default)\n\n"
+
+	" -c, --canonicalize     canonicalize printed paths\n"
+	" -d, --direction <word> search direction - 'forward' or 'backward'\n"
+	" -e, --evaluate         print all TAGs (LABEL/UUID) evaluated\n"
+        " -f, --first-only       print the first found filesystem only\n"
+	" -h, --help             print this help\n"
+	" -i, --invert           invert sense of matching\n"
+	" -l, --list             use list format output\n"
+	" -n, --noheadings       don't print headings\n"
+	" -u, --notruncate       don't truncate text in columns\n"
+	" -O, --options <list>   limit the set of filesystems by mount options\n"
+	" -o, --output <list>    output columns\n"
+	" -r, --raw              use raw format output\n"
+	" -a, --ascii            use ascii chars for tree formatting\n"
+	" -t, --types <list>     limit the set of filesystem by FS types\n"
+	" -v, --nofsroot         don't print [/dir] for bind or btrfs mounts\n"
+	" -R, --submounts        print all submount for the matching filesystems\n"
+	" -S, --source <string>  device, LABEL= or UUID=device\n"
+	" -T, --target <string>  mountpoint\n\n"));
+
+
+	fprintf(out, _("\nAvailable columns:\n"));
+
+	for (i = 0; i < __NCOLUMNS; i++) {
+
+		fprintf(out, "  %-12s", infos[i].name);
+		if (i && !((i+1) % 3))
+			fputc('\n', out);
+	}
+	fputc('\n', out);
+
+	fprintf(out, _("\nFor more information see findmnt(1).\n"));
+
+	exit(out == stderr ? EXIT_FAILURE : EXIT_SUCCESS);
+}
+
+static void __attribute__((__noreturn__))
+errx_mutually_exclusive(const char *opts)
+{
+	errx(EXIT_FAILURE, "%s %s", opts, _("options are mutually exclusive"));
+}
+
+int main(int argc, char *argv[])
+{
+	/* libmount */
+	mnt_tab *tb = NULL;
+	char *tabfile = NULL;
+	int direction = MNT_ITER_FORWARD;
+	int i, c, rc = -1;
+	char *outarg = NULL;
+
+	/* table.h */
+	struct tt *tt = NULL;
+
+	struct option longopts[] = {
+	    { "ascii",        0, 0, 'a' },
+	    { "canonicalize", 0, 0, 'c' },
+	    { "direction",    1, 0, 'd' },
+	    { "evaluate",     0, 0, 'e' },
+	    { "first-only",   0, 0, 'f' },
+	    { "fstab",        0, 0, 's' },
+	    { "help",         0, 0, 'h' },
+	    { "invert",       0, 0, 'i' },
+	    { "kernel",       0, 0, 'k' },
+	    { "list",         0, 0, 'l' },
+	    { "mtab",         0, 0, 'm' },
+	    { "noheadings",   0, 0, 'n' },
+	    { "notruncate",   0, 0, 'u' },
+	    { "options",      1, 0, 'O' },
+	    { "output",       1, 0, 'o' },
+	    { "raw",          0, 0, 'r' },
+	    { "types",        1, 0, 't' },
+	    { "fsroot",       0, 0, 'v' },
+	    { "submounts",    0, 0, 'R' },
+	    { "source",       1, 0, 'S' },
+	    { "target",       1, 0, 'T' },
+
+	    { NULL,           0, 0, 0 }
+	};
+
+	assert(ARRAY_SIZE(columns) == __NCOLUMNS);
+
+	setlocale(LC_ALL, "");
+	bindtextdomain(PACKAGE, LOCALEDIR);
+	textdomain(PACKAGE);
+
+	/* default enabled columns */
+	columns[ncolumns++] = COL_TARGET;
+	columns[ncolumns++] = COL_SOURCE;
+	columns[ncolumns++] = COL_FSTYPE;
+	columns[ncolumns++] = COL_OPTIONS;
+
+	/* default output format */
+	tt_flags |= TT_FL_TREE;
+
+	while ((c = getopt_long(argc, argv,
+				"acd:ehifo:O:klmnrst:uvRS:T:", longopts, NULL)) != -1) {
+		switch(c) {
+		case 'a':
+			tt_flags |= TT_FL_ASCII;
+			break;
+		case 'c':
+			flags |= FL_CANONICALIZE;
+			break;
+		case 'd':
+			if (!strcmp(optarg, "forward"))
+				direction = MNT_ITER_FORWARD;
+			else if (!strcmp(optarg, "backward"))
+				direction = MNT_ITER_BACKWARD;
+			else
+				errx(EXIT_FAILURE,
+					_("unknown direction '%s'"), optarg);
+			break;
+		case 'e':
+			flags |= FL_EVALUATE;
+			break;
+		case 'h':
+			usage(stdout);
+			break;
+		case 'i':
+			flags |= FL_INVERT;
+			break;
+		case 'f':
+			flags |= FL_FIRSTONLY;
+			break;
+		case 'u':
+			set_all_columns_truncate(FALSE);
+			break;
+		case 'o':
+			outarg = optarg;
+			break;
+		case 'O':
+			set_match(COL_OPTIONS, optarg);
+			break;
+		case 'm':		/* mtab */
+			if (tabfile)
+				errx_mutually_exclusive("--{fstab,mtab,kernel}");
+			tabfile = _PATH_MOUNTED;
+			tt_flags &= ~TT_FL_TREE;
+			break;
+		case 's':		/* fstab */
+			if (tabfile)
+				errx_mutually_exclusive("--{fstab,mtab,kernel}");
+			tabfile = _PATH_MNTTAB;
+			tt_flags &= ~TT_FL_TREE;
+			break;
+		case 'k':		/* kernel (mountinfo) */
+			if (tabfile)
+				 errx_mutually_exclusive("--{fstab,mtab,kernel}");
+			tabfile = _PATH_PROC_MOUNTINFO;
+			break;
+		case 't':
+			set_match(COL_FSTYPE, optarg);
+			break;
+		case 'r':
+			tt_flags &= ~TT_FL_TREE;	/* disable the default */
+			tt_flags |= TT_FL_RAW;		/* enable raw */
+			break;
+		case 'l':
+			if (tt_flags & TT_FL_RAW)
+				errx_mutually_exclusive("--{raw,list}");
+
+			tt_flags &= ~TT_FL_TREE; /* disable the default */
+			break;
+		case 'n':
+			tt_flags |= TT_FL_NOHEADINGS;
+			break;
+		case 'v':
+			flags |= FL_NOFSROOT;
+			break;
+		case 'R':
+			flags |= FL_SUBMOUNTS;
+			break;
+		case 'S':
+			set_match(COL_SOURCE, optarg);
+			flags |= FL_NOSWAPMATCH;
+			break;
+		case 'T':
+			set_match(COL_TARGET, optarg);
+			flags |= FL_NOSWAPMATCH;
+			break;
+		default:
+			usage(stderr);
+			break;
+		}
+	}
+
+	if (outarg && string_add_to_idarray(outarg, columns, ARRAY_SIZE(columns),
+					 &ncolumns, column_name_to_id) < 0)
+		return EXIT_FAILURE;
+
+	if (!tabfile) {
+		tabfile = _PATH_PROC_MOUNTINFO;
+
+		if (access(tabfile, R_OK)) {		/* old kernel? */
+			tabfile = _PATH_PROC_MOUNTS;
+			tt_flags &= ~TT_FL_TREE;
+		}
+	}
+
+	if (optind < argc && (get_match(COL_SOURCE) || get_match(COL_TARGET)))
+		errx(EXIT_FAILURE, _(
+			"options --target and --source can't be used together "
+			"with command line element that is not an option"));
+
+	if (optind < argc)
+		set_match(COL_SOURCE, argv[optind++]);	/* dev/tag/mountpoint */
+	if (optind < argc)
+		set_match(COL_TARGET, argv[optind++]);	/* mountpoint */
+
+	if ((flags & FL_SUBMOUNTS) && is_listall_mode())
+		/* don't care about submounts if list all mounts */
+		flags &= ~FL_SUBMOUNTS;
+
+	if (!(flags & FL_SUBMOUNTS) &&
+	    (!is_listall_mode() || (flags & FL_FIRSTONLY)))
+		tt_flags &= ~TT_FL_TREE;
+
+	if (!(flags & FL_NOSWAPMATCH) &&
+	    !get_match(COL_TARGET) && get_match(COL_SOURCE)) {
+		/*
+		 * Check if we can swap source and target, it's
+		 * not possible if the source is LABEL=/UUID=
+		 */
+		const char *x = get_match(COL_SOURCE);
+
+		if (!strncmp(x, "LABEL=", 6) || !strncmp(x, "UUID=", 5))
+			flags |= FL_NOSWAPMATCH;
+	}
+
+	/*
+	 * initialize libmount
+	 */
+	mnt_init_debug(0);
+
+	tb = parse_tabfile(tabfile);
+	if (!tb)
+		goto leave;
+
+	cache = mnt_new_cache();
+	if (!cache) {
+		warn(_("failed to initialize libmount cache"));
+		goto leave;
+	}
+	mnt_tab_set_cache(tb, cache);
+
+	/*
+	 * initialize output formatting (tt.h)
+	 */
+	tt = tt_new_table(tt_flags);
+	if (!tt) {
+		warn(_("failed to initialize output table"));
+		goto leave;
+	}
+
+	for (i = 0; i < ncolumns; i++) {
+		int fl = get_column_truncate(i) ? TT_FL_TRUNC : 0;
+
+		if (get_column_id(i) == COL_TARGET && (tt_flags & TT_FL_TREE))
+			fl |= TT_FL_TREE;
+
+		if (!tt_define_column(tt, get_column_name(i),
+					get_column_whint(i), fl)) {
+			warn(_("failed to initialize output column"));
+			goto leave;
+		}
+	}
+
+	/*
+	 * Fill in data to the output table
+	 */
+	if ((tt_flags & TT_FL_TREE) && is_listall_mode())
+		/* whole tree */
+		rc = create_treenode(tt, tb, NULL, NULL);
+	else
+		/* whole lits of sub-tree */
+		rc = add_matching_lines(tb, tt, direction);
+
+	/*
+	 * Print the output table
+	 */
+	if (!rc)
+		tt_print_table(tt);
+leave:
+	tt_free_table(tt);
+
+	mnt_free_tab(tb);
+	mnt_free_cache(cache);
+
+	return rc ? EXIT_FAILURE : EXIT_SUCCESS;
+}
diff -up util-linux-ng-2.17.2/misc-utils/Makefile.am.kzak util-linux-ng-2.17.2/misc-utils/Makefile.am
--- util-linux-ng-2.17.2/misc-utils/Makefile.am.kzak	2012-10-08 12:51:49.114688753 +0200
+++ util-linux-ng-2.17.2/misc-utils/Makefile.am	2012-10-08 12:54:57.187851857 +0200
@@ -66,6 +66,17 @@ blkid_static_CFLAGS = $(AM_CFLAGS) -I$(u
 endif
 endif
 
+if BUILD_LIBMOUNT
+bin_PROGRAMS += findmnt
+dist_man_MANS += findmnt.8
+findmnt_LDADD = $(ul_libmount_la)
+findmnt_CFLAGS = $(AM_CFLAGS) -I$(ul_libmount_incdir)
+findmnt_SOURCES = findmnt.c \
+		$(top_srcdir)/lib/tt.c \
+		$(top_srcdir)/lib/strutils.c \
+		$(top_srcdir)/lib/mbsalign.c
+endif
+
 if HAVE_TINFO
 cal_LDADD = -ltinfo @NCURSES_LIBS@
 else
diff -up util-linux-ng-2.17.2/shlibs/Makefile.am.kzak util-linux-ng-2.17.2/shlibs/Makefile.am
--- util-linux-ng-2.17.2/shlibs/Makefile.am.kzak	2010-02-04 12:53:57.000000000 +0100
+++ util-linux-ng-2.17.2/shlibs/Makefile.am	2012-10-08 12:51:49.131688857 +0200
@@ -7,3 +7,6 @@ endif
 if BUILD_LIBBLKID
 SUBDIRS += blkid
 endif
+
+# backported to RHEL6
+SUBDIRS += mount
diff -up util-linux-ng-2.17.2/shlibs/mount/COPYING.libmount.kzak util-linux-ng-2.17.2/shlibs/mount/COPYING.libmount
--- util-linux-ng-2.17.2/shlibs/mount/COPYING.libmount.kzak	2012-10-08 12:51:49.132688863 +0200
+++ util-linux-ng-2.17.2/shlibs/mount/COPYING.libmount	2012-10-08 12:51:49.132688863 +0200
@@ -0,0 +1,508 @@
+
+                  GNU LESSER GENERAL PUBLIC LICENSE
+                       Version 2.1, February 1999
+
+ Copyright (C) 1991, 1999 Free Software Foundation, Inc.
+     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+[This is the first released version of the Lesser GPL.  It also counts
+ as the successor of the GNU Library Public License, version 2, hence
+ the version number 2.1.]
+
+                            Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+Licenses are intended to guarantee your freedom to share and change
+free software--to make sure the software is free for all its users.
+
+  This license, the Lesser General Public License, applies to some
+specially designated software packages--typically libraries--of the
+Free Software Foundation and other authors who decide to use it.  You
+can use it too, but we suggest you first think carefully about whether
+this license or the ordinary General Public License is the better
+strategy to use in any particular case, based on the explanations
+below.
+
+  When we speak of free software, we are referring to freedom of use,
+not price.  Our General Public Licenses are designed to make sure that
+you have the freedom to distribute copies of free software (and charge
+for this service if you wish); that you receive source code or can get
+it if you want it; that you can change the software and use pieces of
+it in new free programs; and that you are informed that you can do
+these things.
+
+  To protect your rights, we need to make restrictions that forbid
+distributors to deny you these rights or to ask you to surrender these
+rights.  These restrictions translate to certain responsibilities for
+you if you distribute copies of the library or if you modify it.
+
+  For example, if you distribute copies of the library, whether gratis
+or for a fee, you must give the recipients all the rights that we gave
+you.  You must make sure that they, too, receive or can get the source
+code.  If you link other code with the library, you must provide
+complete object files to the recipients, so that they can relink them
+with the library after making changes to the library and recompiling
+it.  And you must show them these terms so they know their rights.
+
+  We protect your rights with a two-step method: (1) we copyright the
+library, and (2) we offer you this license, which gives you legal
+permission to copy, distribute and/or modify the library.
+
+  To protect each distributor, we want to make it very clear that
+there is no warranty for the free library.  Also, if the library is
+modified by someone else and passed on, the recipients should know
+that what they have is not the original version, so that the original
+author's reputation will not be affected by problems that might be
+introduced by others.
+^L
+  Finally, software patents pose a constant threat to the existence of
+any free program.  We wish to make sure that a company cannot
+effectively restrict the users of a free program by obtaining a
+restrictive license from a patent holder.  Therefore, we insist that
+any patent license obtained for a version of the library must be
+consistent with the full freedom of use specified in this license.
+
+  Most GNU software, including some libraries, is covered by the
+ordinary GNU General Public License.  This license, the GNU Lesser
+General Public License, applies to certain designated libraries, and
+is quite different from the ordinary General Public License.  We use
+this license for certain libraries in order to permit linking those
+libraries into non-free programs.
+
+  When a program is linked with a library, whether statically or using
+a shared library, the combination of the two is legally speaking a
+combined work, a derivative of the original library.  The ordinary
+General Public License therefore permits such linking only if the
+entire combination fits its criteria of freedom.  The Lesser General
+Public License permits more lax criteria for linking other code with
+the library.
+
+  We call this license the "Lesser" General Public License because it
+does Less to protect the user's freedom than the ordinary General
+Public License.  It also provides other free software developers Less
+of an advantage over competing non-free programs.  These disadvantages
+are the reason we use the ordinary General Public License for many
+libraries.  However, the Lesser license provides advantages in certain
+special circumstances.
+
+  For example, on rare occasions, there may be a special need to
+encourage the widest possible use of a certain library, so that it
+becomes a de-facto standard.  To achieve this, non-free programs must
+be allowed to use the library.  A more frequent case is that a free
+library does the same job as widely used non-free libraries.  In this
+case, there is little to gain by limiting the free library to free
+software only, so we use the Lesser General Public License.
+
+  In other cases, permission to use a particular library in non-free
+programs enables a greater number of people to use a large body of
+free software.  For example, permission to use the GNU C Library in
+non-free programs enables many more people to use the whole GNU
+operating system, as well as its variant, the GNU/Linux operating
+system.
+
+  Although the Lesser General Public License is Less protective of the
+users' freedom, it does ensure that the user of a program that is
+linked with the Library has the freedom and the wherewithal to run
+that program using a modified version of the Library.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.  Pay close attention to the difference between a
+"work based on the library" and a "work that uses the library".  The
+former contains code derived from the library, whereas the latter must
+be combined with the library in order to run.
+^L
+                  GNU LESSER GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License Agreement applies to any software library or other
+program which contains a notice placed by the copyright holder or
+other authorized party saying it may be distributed under the terms of
+this Lesser General Public License (also called "this License").
+Each licensee is addressed as "you".
+
+  A "library" means a collection of software functions and/or data
+prepared so as to be conveniently linked with application programs
+(which use some of those functions and data) to form executables.
+
+  The "Library", below, refers to any such software library or work
+which has been distributed under these terms.  A "work based on the
+Library" means either the Library or any derivative work under
+copyright law: that is to say, a work containing the Library or a
+portion of it, either verbatim or with modifications and/or translated
+straightforwardly into another language.  (Hereinafter, translation is
+included without limitation in the term "modification".)
+
+  "Source code" for a work means the preferred form of the work for
+making modifications to it.  For a library, complete source code means
+all the source code for all modules it contains, plus any associated
+interface definition files, plus the scripts used to control
+compilation and installation of the library.
+
+  Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running a program using the Library is not restricted, and output from
+such a program is covered only if its contents constitute a work based
+on the Library (independent of the use of the Library in a tool for
+writing it).  Whether that is true depends on what the Library does
+and what the program that uses the Library does.
+
+  1. You may copy and distribute verbatim copies of the Library's
+complete source code as you receive it, in any medium, provided that
+you conspicuously and appropriately publish on each copy an
+appropriate copyright notice and disclaimer of warranty; keep intact
+all the notices that refer to this License and to the absence of any
+warranty; and distribute a copy of this License along with the
+Library.
+
+  You may charge a fee for the physical act of transferring a copy,
+and you may at your option offer warranty protection in exchange for a
+fee.
+
+  2. You may modify your copy or copies of the Library or any portion
+of it, thus forming a work based on the Library, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) The modified work must itself be a software library.
+
+    b) You must cause the files modified to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    c) You must cause the whole of the work to be licensed at no
+    charge to all third parties under the terms of this License.
+
+    d) If a facility in the modified Library refers to a function or a
+    table of data to be supplied by an application program that uses
+    the facility, other than as an argument passed when the facility
+    is invoked, then you must make a good faith effort to ensure that,
+    in the event an application does not supply such function or
+    table, the facility still operates, and performs whatever part of
+    its purpose remains meaningful.
+
+    (For example, a function in a library to compute square roots has
+    a purpose that is entirely well-defined independent of the
+    application.  Therefore, Subsection 2d requires that any
+    application-supplied function or table used by this function must
+    be optional: if the application does not supply it, the square
+    root function must still compute square roots.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Library,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Library, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote
+it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Library.
+
+In addition, mere aggregation of another work not based on the Library
+with the Library (or with a work based on the Library) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may opt to apply the terms of the ordinary GNU General Public
+License instead of this License to a given copy of the Library.  To do
+this, you must alter all the notices that refer to this License, so
+that they refer to the ordinary GNU General Public License, version 2,
+instead of to this License.  (If a newer version than version 2 of the
+ordinary GNU General Public License has appeared, then you can specify
+that version instead if you wish.)  Do not make any other change in
+these notices.
+^L
+  Once this change is made in a given copy, it is irreversible for
+that copy, so the ordinary GNU General Public License applies to all
+subsequent copies and derivative works made from that copy.
+
+  This option is useful when you wish to copy part of the code of
+the Library into a program that is not a library.
+
+  4. You may copy and distribute the Library (or a portion or
+derivative of it, under Section 2) in object code or executable form
+under the terms of Sections 1 and 2 above provided that you accompany
+it with the complete corresponding machine-readable source code, which
+must be distributed under the terms of Sections 1 and 2 above on a
+medium customarily used for software interchange.
+
+  If distribution of object code is made by offering access to copy
+from a designated place, then offering equivalent access to copy the
+source code from the same place satisfies the requirement to
+distribute the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  5. A program that contains no derivative of any portion of the
+Library, but is designed to work with the Library by being compiled or
+linked with it, is called a "work that uses the Library".  Such a
+work, in isolation, is not a derivative work of the Library, and
+therefore falls outside the scope of this License.
+
+  However, linking a "work that uses the Library" with the Library
+creates an executable that is a derivative of the Library (because it
+contains portions of the Library), rather than a "work that uses the
+library".  The executable is therefore covered by this License.
+Section 6 states terms for distribution of such executables.
+
+  When a "work that uses the Library" uses material from a header file
+that is part of the Library, the object code for the work may be a
+derivative work of the Library even though the source code is not.
+Whether this is true is especially significant if the work can be
+linked without the Library, or if the work is itself a library.  The
+threshold for this to be true is not precisely defined by law.
+
+  If such an object file uses only numerical parameters, data
+structure layouts and accessors, and small macros and small inline
+functions (ten lines or less in length), then the use of the object
+file is unrestricted, regardless of whether it is legally a derivative
+work.  (Executables containing this object code plus portions of the
+Library will still fall under Section 6.)
+
+  Otherwise, if the work is a derivative of the Library, you may
+distribute the object code for the work under the terms of Section 6.
+Any executables containing that work also fall under Section 6,
+whether or not they are linked directly with the Library itself.
+^L
+  6. As an exception to the Sections above, you may also combine or
+link a "work that uses the Library" with the Library to produce a
+work containing portions of the Library, and distribute that work
+under terms of your choice, provided that the terms permit
+modification of the work for the customer's own use and reverse
+engineering for debugging such modifications.
+
+  You must give prominent notice with each copy of the work that the
+Library is used in it and that the Library and its use are covered by
+this License.  You must supply a copy of this License.  If the work
+during execution displays copyright notices, you must include the
+copyright notice for the Library among them, as well as a reference
+directing the user to the copy of this License.  Also, you must do one
+of these things:
+
+    a) Accompany the work with the complete corresponding
+    machine-readable source code for the Library including whatever
+    changes were used in the work (which must be distributed under
+    Sections 1 and 2 above); and, if the work is an executable linked
+    with the Library, with the complete machine-readable "work that
+    uses the Library", as object code and/or source code, so that the
+    user can modify the Library and then relink to produce a modified
+    executable containing the modified Library.  (It is understood
+    that the user who changes the contents of definitions files in the
+    Library will not necessarily be able to recompile the application
+    to use the modified definitions.)
+
+    b) Use a suitable shared library mechanism for linking with the
+    Library.  A suitable mechanism is one that (1) uses at run time a
+    copy of the library already present on the user's computer system,
+    rather than copying library functions into the executable, and (2)
+    will operate properly with a modified version of the library, if
+    the user installs one, as long as the modified version is
+    interface-compatible with the version that the work was made with.
+
+    c) Accompany the work with a written offer, valid for at least
+    three years, to give the same user the materials specified in
+    Subsection 6a, above, for a charge no more than the cost of
+    performing this distribution.
+
+    d) If distribution of the work is made by offering access to copy
+    from a designated place, offer equivalent access to copy the above
+    specified materials from the same place.
+
+    e) Verify that the user has already received a copy of these
+    materials or that you have already sent this user a copy.
+
+  For an executable, the required form of the "work that uses the
+Library" must include any data and utility programs needed for
+reproducing the executable from it.  However, as a special exception,
+the materials to be distributed need not include anything that is
+normally distributed (in either source or binary form) with the major
+components (compiler, kernel, and so on) of the operating system on
+which the executable runs, unless that component itself accompanies
+the executable.
+
+  It may happen that this requirement contradicts the license
+restrictions of other proprietary libraries that do not normally
+accompany the operating system.  Such a contradiction means you cannot
+use both them and the Library together in an executable that you
+distribute.
+^L
+  7. You may place library facilities that are a work based on the
+Library side-by-side in a single library together with other library
+facilities not covered by this License, and distribute such a combined
+library, provided that the separate distribution of the work based on
+the Library and of the other library facilities is otherwise
+permitted, and provided that you do these two things:
+
+    a) Accompany the combined library with a copy of the same work
+    based on the Library, uncombined with any other library
+    facilities.  This must be distributed under the terms of the
+    Sections above.
+
+    b) Give prominent notice with the combined library of the fact
+    that part of it is a work based on the Library, and explaining
+    where to find the accompanying uncombined form of the same work.
+
+  8. You may not copy, modify, sublicense, link with, or distribute
+the Library except as expressly provided under this License.  Any
+attempt otherwise to copy, modify, sublicense, link with, or
+distribute the Library is void, and will automatically terminate your
+rights under this License.  However, parties who have received copies,
+or rights, from you under this License will not have their licenses
+terminated so long as such parties remain in full compliance.
+
+  9. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Library or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Library (or any work based on the
+Library), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Library or works based on it.
+
+  10. Each time you redistribute the Library (or any work based on the
+Library), the recipient automatically receives a license from the
+original licensor to copy, distribute, link with or modify the Library
+subject to these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties with
+this License.
+^L
+  11. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Library at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Library by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Library.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply, and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  12. If the distribution and/or use of the Library is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Library under this License
+may add an explicit geographical distribution limitation excluding those
+countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  13. The Free Software Foundation may publish revised and/or new
+versions of the Lesser General Public License from time to time.
+Such new versions will be similar in spirit to the present version,
+but may differ in detail to address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Library
+specifies a version number of this License which applies to it and
+"any later version", you have the option of following the terms and
+conditions either of that version or of any later version published by
+the Free Software Foundation.  If the Library does not specify a
+license version number, you may choose any version ever published by
+the Free Software Foundation.
+^L
+  14. If you wish to incorporate parts of the Library into other free
+programs whose distribution conditions are incompatible with these,
+write to the author to ask for permission.  For software which is
+copyrighted by the Free Software Foundation, write to the Free
+Software Foundation; we sometimes make exceptions for this.  Our
+decision will be guided by the two goals of preserving the free status
+of all derivatives of our free software and of promoting the sharing
+and reuse of software generally.
+
+                            NO WARRANTY
+
+  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
+WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
+EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
+OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
+KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
+LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
+THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
+WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
+AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
+FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
+CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
+LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
+RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
+FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
+SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+DAMAGES.
+
+                     END OF TERMS AND CONDITIONS
+^L
+           How to Apply These Terms to Your New Libraries
+
+  If you develop a new library, and you want it to be of the greatest
+possible use to the public, we recommend making it free software that
+everyone can redistribute and change.  You can do so by permitting
+redistribution under these terms (or, alternatively, under the terms
+of the ordinary General Public License).
+
+  To apply these terms, attach the following notices to the library.
+It is safest to attach them to the start of each source file to most
+effectively convey the exclusion of warranty; and each file should
+have at least the "copyright" line and a pointer to where the full
+notice is found.
+
+
+    <one line to give the library's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
+
+Also add information on how to contact you by electronic and paper mail.
+
+You should also get your employer (if you work as a programmer) or
+your school, if any, to sign a "copyright disclaimer" for the library,
+if necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the
+  library `Frob' (a library for tweaking knobs) written by James
+  Random Hacker.
+
+  <signature of Ty Coon>, 1 April 1990
+  Ty Coon, President of Vice
+
+That's all there is to it!
diff -up util-linux-ng-2.17.2/shlibs/mount/Makefile.am.kzak util-linux-ng-2.17.2/shlibs/mount/Makefile.am
--- util-linux-ng-2.17.2/shlibs/mount/Makefile.am.kzak	2012-10-08 12:51:49.132688863 +0200
+++ util-linux-ng-2.17.2/shlibs/mount/Makefile.am	2012-10-08 12:51:49.132688863 +0200
@@ -0,0 +1,5 @@
+include $(top_srcdir)/config/include-Makefile.am
+
+SUBDIRS = src
+
+EXTRA_DIST = COPYING.libmount
diff -up util-linux-ng-2.17.2/shlibs/mount/src/cache.c.kzak util-linux-ng-2.17.2/shlibs/mount/src/cache.c
--- util-linux-ng-2.17.2/shlibs/mount/src/cache.c.kzak	2012-10-08 12:51:49.133688870 +0200
+++ util-linux-ng-2.17.2/shlibs/mount/src/cache.c	2012-10-08 12:51:49.133688870 +0200
@@ -0,0 +1,551 @@
+/*
+ * Copyright (C) 2009 Karel Zak <kzak@redhat.com>
+ *
+ * This file may be redistributed under the terms of the
+ * GNU Lesser General Public License.
+ */
+
+/**
+ * SECTION: cache
+ * @title: Cache
+ * @short_description: paths and tags (UUID/LABEL) caching
+ *
+ * The cache is a very simple API for work with tags (LABEL, UUID, ...) and
+ * paths. The cache uses libblkid as a backend from TAGs resolution.
+ *
+ * All returned paths are always canonicalized.
+ */
+#include <string.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <limits.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <blkid.h>
+
+#include "canonicalize.h"
+#include "mountP.h"
+
+/*
+ * Canonicalized (resolved) paths & tags cache
+ */
+#define MNT_CACHE_CHUNKSZ	128
+
+#define MNT_CACHE_ISTAG		(1 << 1) /* entry is TAG */
+#define MNT_CACHE_ISPATH	(1 << 2) /* entry is path */
+#define MNT_CACHE_TAGREAD	(1 << 3) /* tag read by mnt_cache_read_tags() */
+
+/* path cache entry */
+struct mnt_cache_entry {
+	char			*native;	/* the original path */
+	char			*real;		/* canonicalized path */
+	int			flag;
+};
+
+struct _mnt_cache {
+	struct mnt_cache_entry	*ents;
+	size_t			nents;
+	size_t			nallocs;
+
+	/* blkid_evaluate_tag() works in two ways:
+	 *
+	 * 1/ all tags are evaluated by udev /dev/disk/by-* symlinks,
+	 *    then the blkid_cache is NULL.
+	 *
+	 * 2/ all tags are read from /etc/blkid.tab and verified by /dev
+	 *    scanning, then the blkid_cache is not NULL and then it's
+	 *    better to reuse the blkid_cache.
+	 */
+	blkid_cache		bc;
+	blkid_probe		pr;
+
+	char			*filename;
+};
+
+/**
+ * mnt_new_cache:
+ *
+ * Returns: new mnt_cache instance or NULL in case of ENOMEM error.
+ */
+mnt_cache *mnt_new_cache(void)
+{
+	mnt_cache *cache = calloc(1, sizeof(struct _mnt_cache));
+	if (!cache)
+		return NULL;
+	DBG(CACHE, mnt_debug_h(cache, "alloc"));
+	return cache;
+}
+
+/**
+ * mnt_free_cache:
+ * @cache: pointer to mnt_cache instance
+ *
+ * Deallocates the cache.
+ */
+void mnt_free_cache(mnt_cache *cache)
+{
+	int i;
+
+	if (!cache)
+		return;
+
+	DBG(CACHE, mnt_debug_h(cache, "free"));
+
+	for (i = 0; i < cache->nents; i++) {
+		struct mnt_cache_entry *e = &cache->ents[i];
+		if (e->real != e->native)
+			free(e->real);
+		free(e->native);
+	}
+	free(cache->ents);
+	free(cache->filename);
+	if (cache->bc)
+		blkid_put_cache(cache->bc);
+	blkid_free_probe(cache->pr);
+	free(cache);
+}
+
+/* note that the @native could be tha same pointer as @real */
+static int mnt_cache_add_entry(mnt_cache *cache, char *native,
+					char *real, int flag)
+{
+	struct mnt_cache_entry *e;
+
+	assert(cache);
+	assert(real);
+	assert(native);
+
+	if (cache->nents == cache->nallocs) {
+		size_t sz = cache->nallocs + MNT_CACHE_CHUNKSZ;
+
+		e = realloc(cache->ents, sz * sizeof(struct mnt_cache_entry));
+		if (!e)
+			return -ENOMEM;
+		cache->ents = e;
+		cache->nallocs = sz;
+	}
+
+	e = &cache->ents[cache->nents];
+	e->native = native;
+	e->real = real;
+	e->flag = flag;
+	cache->nents++;
+
+	DBG(CACHE, mnt_debug_h(cache, "add entry [%2zd] (%s): %s: %s",
+			cache->nents,
+			(flag & MNT_CACHE_ISPATH) ? "path" : "tag",
+			real, native));
+	return 0;
+}
+
+/* add tag to the cache, @real has to be allocated string */
+static int mnt_cache_add_tag(mnt_cache *cache, const char *token,
+				const char *value, char *real, int flag)
+{
+	size_t tksz, vlsz;
+	char *native;
+	int rc;
+
+	assert(cache);
+	assert(real);
+	assert(token);
+	assert(value);
+
+	/* add into cache -- cache format for TAGs is
+	 *	native = "NAME\0VALUE\0"
+	 *	real   = "/dev/foo"
+	 */
+	tksz = strlen(token);
+	vlsz = strlen(value);
+
+	native = malloc(tksz + vlsz + 2);
+	if (!native)
+		return -ENOMEM;
+
+	memcpy(native, token, tksz + 1);	   /* include '\0' */
+	memcpy(native + tksz + 1, value, vlsz + 1);
+
+	rc = mnt_cache_add_entry(cache, native, real, flag | MNT_CACHE_ISTAG);
+	if (!rc)
+		return 0;
+
+	free(native);
+	return rc;
+}
+
+
+/*
+ * Returns cached canonicalized path or NULL.
+ */
+static const char *mnt_cache_find_path(mnt_cache *cache, const char *path)
+{
+	int i;
+
+	assert(cache);
+	assert(path);
+
+	if (!cache || !path)
+		return NULL;
+
+	for (i = 0; i < cache->nents; i++) {
+		struct mnt_cache_entry *e = &cache->ents[i];
+		if (!(e->flag & MNT_CACHE_ISPATH))
+			continue;
+		if (strcmp(path, e->native) == 0)
+			return e->real;
+	}
+	return NULL;
+}
+
+/*
+ * Returns cached path or NULL.
+ */
+static const char *mnt_cache_find_tag(mnt_cache *cache,
+			const char *token, const char *value)
+{
+	int i;
+	size_t tksz;
+
+	assert(cache);
+	assert(token);
+	assert(value);
+
+	if (!cache || !token || !value)
+		return NULL;
+
+	tksz = strlen(token);
+
+	for (i = 0; i < cache->nents; i++) {
+		struct mnt_cache_entry *e = &cache->ents[i];
+		if (!(e->flag & MNT_CACHE_ISTAG))
+			continue;
+		if (strcmp(token, e->native) == 0 &&
+		    strcmp(value, e->native + tksz + 1) == 0)
+			return e->real;
+	}
+	return NULL;
+}
+
+/*
+ * returns (in @res) blkid prober, the @cache argument is optional
+ */
+static int mnt_cache_get_probe(mnt_cache *cache, const char *devname,
+			   blkid_probe *res)
+{
+	blkid_probe pr = cache ? cache->pr : NULL;
+
+	assert(devname);
+	assert(res);
+
+	if (cache && cache->pr && (!cache->filename ||
+				   strcmp(devname, cache->filename))) {
+		blkid_free_probe(cache->pr);
+		free(cache->filename);
+		cache->filename = NULL;
+		pr = cache->pr = NULL;
+	}
+
+	if (!pr) {
+		pr = blkid_new_probe_from_filename(devname);
+		if (!pr)
+			return -1;
+		if (cache) {
+			cache->pr = pr;
+			cache->filename = strdup(devname);
+			if (!cache->filename)
+				return -ENOMEM;
+		}
+
+	}
+
+	*res = pr;
+	return 0;
+}
+
+/**
+ * mnt_cache_read_tags
+ * @cache: pointer to mnt_cache instance
+ * @devname: path device
+ *
+ * Reads @devname LABEL and UUID to the @cache.
+ *
+ * Returns: 0 if at least one tag was added, 1 if no tag was added or
+ *          negative number in case of error.
+ */
+int mnt_cache_read_tags(mnt_cache *cache, const char *devname)
+{
+	int i, ntags = 0, rc;
+	blkid_probe pr;
+	const char *tags[] = { "LABEL", "UUID", "TYPE" };
+
+	assert(cache);
+	assert(devname);
+
+	if (!cache || !devname)
+		return -EINVAL;
+
+	DBG(CACHE, mnt_debug_h(cache, "tags for %s requested", devname));
+
+	/* check is device is already cached */
+	for (i = 0; i < cache->nents; i++) {
+		struct mnt_cache_entry *e = &cache->ents[i];
+		if (!(e->flag & MNT_CACHE_TAGREAD))
+			continue;
+		if (strcmp(e->real, devname) == 0)
+			/* tags has been already read */
+			return 0;
+	}
+
+	rc = mnt_cache_get_probe(cache, devname, &pr);
+	if (rc)
+		return rc;
+
+	blkid_probe_enable_superblocks(cache->pr, 1);
+
+	blkid_probe_set_superblocks_flags(cache->pr,
+			BLKID_SUBLKS_LABEL | BLKID_SUBLKS_UUID |
+			BLKID_SUBLKS_TYPE);
+
+	if (blkid_do_safeprobe(cache->pr))
+		goto error;
+
+	DBG(CACHE, mnt_debug_h(cache, "reading tags for: %s", devname));
+
+	for (i = 0; i < ARRAY_SIZE(tags); i++) {
+		const char *data;
+		char *dev;
+
+		if (blkid_probe_lookup_value(cache->pr, tags[i], &data, NULL))
+			continue;
+		if (mnt_cache_find_tag(cache, tags[i], data))
+			continue; /* already cached */
+
+		dev = strdup(devname);
+		if (!dev)
+			goto error;
+		if (mnt_cache_add_tag(cache, tags[i], data, dev,
+					MNT_CACHE_TAGREAD)) {
+			free(dev);
+			goto error;
+		}
+		ntags++;
+	}
+
+	return ntags ? 0 : 1;
+error:
+	return -1;
+}
+
+/**
+ * mnt_cache_device_has_tag:
+ * @cache: paths cache
+ * @devname: path to the device
+ * @token: tag name (e.g "LABEL")
+ * @value: tag value
+ *
+ * Look up @cache to check it @tag+@value are associated with @devname.
+ *
+ * Returns: 1 on success or 0.
+ */
+int mnt_cache_device_has_tag(mnt_cache *cache, const char *devname,
+				const char *token, const char *value)
+{
+	const char *path = mnt_cache_find_tag(cache, token, value);
+
+	if (path && strcmp(path, devname) == 0)
+		return 1;
+	return 0;
+}
+
+/**
+ * mnt_cache_find_tag_value:
+ * @cache: cache for results
+ * @devname: device name
+ * @token: tag name ("LABEL" or "UUID")
+ *
+ * Returns: LABEL or UUID for the @devname or NULL in case of error.
+ */
+char *mnt_cache_find_tag_value(mnt_cache *cache,
+		const char *devname, const char *token)
+{
+	int i;
+
+	if (!cache || !devname || !token)
+		return NULL;
+
+	if (mnt_cache_read_tags(cache, devname) != 0)
+		return NULL;
+
+	for (i = 0; i < cache->nents; i++) {
+		struct mnt_cache_entry *e = &cache->ents[i];
+		if (!(e->flag & MNT_CACHE_ISTAG))
+			continue;
+		if (strcmp(e->real, devname) == 0 &&	/* dev name */
+		    strcmp(token, e->native) == 0)	/* tag name */
+			return e->native + strlen(token) + 1;	/* tag value */
+	}
+
+	return NULL;
+}
+
+/**
+ * mnt_get_fstype:
+ * @devname: device name
+ * @ambi: returns TRUE if probing result is ambivalent (optional argument)
+ * @cache: cache for results or NULL
+ *
+ * Returns: filesystem type or NULL in case of error. The result has to be
+ * deallocated by free() if @cache is NULL.
+ */
+char *mnt_get_fstype(const char *devname, int *ambi, mnt_cache *cache)
+{
+	blkid_probe pr;
+	const char *data;
+	char *type = NULL;
+	int rc;
+
+	DBG(CACHE, mnt_debug_h(cache, "get %s FS type", devname));
+
+	if (cache)
+		return mnt_cache_find_tag_value(cache, devname, "TYPE");
+
+	if (mnt_cache_get_probe(NULL, devname, &pr))
+		return NULL;
+
+	blkid_probe_enable_superblocks(pr, 1);
+
+	blkid_probe_set_superblocks_flags(pr, BLKID_SUBLKS_TYPE);
+
+	rc = blkid_do_safeprobe(pr);
+
+	if (!rc && !blkid_probe_lookup_value(pr, "TYPE", &data, NULL))
+		type = strdup(data);
+
+	if (ambi)
+		*ambi = rc == -2 ? TRUE : FALSE;
+
+	blkid_free_probe(pr);
+	return type;
+}
+
+/**
+ * mnt_resolve_path:
+ * @path: "native" path
+ * @cache: cache for results or NULL
+ *
+ * Returns: absolute path or NULL in case of error. The result has to be
+ * deallocated by free() if @cache is NULL.
+ */
+char *mnt_resolve_path(const char *path, mnt_cache *cache)
+{
+	char *p = NULL;
+	char *native = NULL;
+	char *real = NULL;
+
+	assert(path);
+
+	DBG(CACHE, mnt_debug_h(cache, "resolving path %s", path));
+
+	if (!path)
+		return NULL;
+	if (cache)
+		p = (char *) mnt_cache_find_path(cache, path);
+
+	if (!p) {
+		p = canonicalize_path(path);
+
+		if (p && cache) {
+			native = strdup(path);
+			real = strcmp(path, p) == 0 ? native : p;
+
+			if (!native || !real)
+				goto error;
+
+			if (mnt_cache_add_entry(cache, native, real,
+							MNT_CACHE_ISPATH))
+				goto error;
+		}
+	}
+
+	return p;
+error:
+	if (real != native)
+		free(real);
+	free(native);
+	return NULL;
+}
+
+/**
+ * mnt_resolve_tag:
+ * @token: tag name
+ * @value: tag value
+ * @cache: for results or NULL
+ *
+ * Returns: device name or NULL in case of error. The result has to be
+ * deallocated by free() if @cache is NULL.
+ */
+char *mnt_resolve_tag(const char *token, const char *value, mnt_cache *cache)
+{
+	char *p = NULL;
+
+	assert(token);
+	assert(value);
+
+	DBG(CACHE, mnt_debug_h(cache, "resolving tag token=%s value=%s",
+				token, value));
+
+	if (!token || !value)
+		return NULL;
+
+	if (cache)
+		p = (char *) mnt_cache_find_tag(cache, token, value);
+
+	if (!p) {
+		/* returns newly allocated string */
+		p = blkid_evaluate_tag(token, value, cache ? &cache->bc : NULL);
+
+		if (p && cache &&
+		    mnt_cache_add_tag(cache, token, value, p, 0))
+				goto error;
+	}
+
+	return p;
+error:
+	free(p);
+	return NULL;
+}
+
+
+
+/**
+ * mnt_resolve_spec:
+ * @spec: path or tag
+ * @cache: paths cache
+ *
+ * Returns: canonicalized path or NULL. The result has to be
+ * deallocated by free() if @cache is NULL.
+ */
+char *mnt_resolve_spec(const char *spec, mnt_cache *cache)
+{
+	char *cn = NULL;
+
+	if (!spec)
+		return NULL;
+
+	if (strchr(spec, '=')) {
+		char *tag, *val;
+
+		if (!blkid_parse_tag_string(spec, &tag, &val)) {
+			cn = mnt_resolve_tag(tag, val, cache);
+
+			free(tag);
+			free(val);
+		}
+	} else
+		cn = mnt_resolve_path(spec, cache);
+
+	return cn;
+}
+
diff -up util-linux-ng-2.17.2/shlibs/mount/src/fs.c.kzak util-linux-ng-2.17.2/shlibs/mount/src/fs.c
--- util-linux-ng-2.17.2/shlibs/mount/src/fs.c.kzak	2012-10-08 12:51:49.135688883 +0200
+++ util-linux-ng-2.17.2/shlibs/mount/src/fs.c	2012-10-08 12:51:49.135688883 +0200
@@ -0,0 +1,1244 @@
+/*
+ * Copyright (C) 2008-2009 Karel Zak <kzak@redhat.com>
+ *
+ * This file may be redistributed under the terms of the
+ * GNU Lesser General Public License.
+ */
+
+/**
+ * SECTION: fs
+ * @title: Filesystem
+ * @short_description: mnt_fs represents one entry in fstab/mtab/mountinfo
+ *
+ */
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <errno.h>
+#include <blkid.h>
+#include <stddef.h>
+
+#include "nls.h"
+#include "mountP.h"
+
+/**
+ * mnt_new_fs:
+ *
+ * Returns: newly allocated mnt_file fs.
+ */
+mnt_fs *mnt_new_fs(void)
+{
+	mnt_fs *fs = calloc(1, sizeof(struct _mnt_fs));
+	if (!fs)
+		return NULL;
+
+	INIT_LIST_HEAD(&fs->ents);
+	return fs;
+}
+
+/**
+ * mnt_free_fs:
+ * @fs: fs pointer
+ *
+ * Deallocates the fs.
+ */
+void mnt_free_fs(mnt_fs *fs)
+{
+	if (!fs)
+		return;
+	list_del(&fs->ents);
+
+	free(fs->source);
+	free(fs->bindsrc);
+	free(fs->tagname);
+	free(fs->tagval);
+	free(fs->root);
+	free(fs->target);
+	free(fs->fstype);
+	free(fs->vfs_optstr);
+	free(fs->fs_optstr);
+	free(fs->user_optstr);
+	free(fs->attrs);
+
+	free(fs);
+}
+
+/**
+ * mnt_fs_get_userdata:
+ * @fs: mnt_file instance
+ *
+ * Returns: private data set by mnt_fs_set_userdata() or NULL.
+ */
+void *mnt_fs_get_userdata(mnt_fs *fs)
+{
+	return fs ? fs->userdata : NULL;
+}
+
+/**
+ * mnt_fs_set_userdata:
+ * @fs: mnt_file instance
+ * @data: user data
+ *
+ * The "userdata" are library independent data.
+ *
+ * Returns: 0 or negative number in case of error (if @fs is NULL).
+ */
+int mnt_fs_set_userdata(mnt_fs *fs, void *data)
+{
+	if (!fs)
+		return -EINVAL;
+	fs->userdata = data;
+	return 0;
+}
+
+/**
+ * mnt_fs_get_srcpath:
+ * @fs: mnt_file (fstab/mtab/mountinfo) fs
+ *
+ * The mount "source path" is:
+ * - a directory for 'bind' mounts (in fstab or mtab only)
+ * - a device name for standard mounts
+ *
+ * See also mnt_fs_get_tag() and mnt_fs_get_source().
+ *
+ * Returns: mount source path or NULL in case of error or when the path
+ * is not defined.
+ */
+const char *mnt_fs_get_srcpath(mnt_fs *fs)
+{
+	assert(fs);
+	if (!fs)
+		return NULL;
+
+	/* fstab-like fs */
+	if (fs->tagname)
+		return NULL;	/* the source contains a "NAME=value" */
+	return fs->source;
+}
+
+/**
+ * mnt_fs_get_source:
+ * @fs: mnt_file (fstab/mtab/mountinfo) fs
+ *
+ * Returns: mount source. Note that the source could be unparsed TAG
+ * (LABEL/UUID). See also mnt_fs_get_srcpath() and mnt_fs_get_tag().
+ */
+const char *mnt_fs_get_source(mnt_fs *fs)
+{
+	return fs ? fs->source : NULL;
+}
+
+/* Used by parser mnt_file ONLY (@source has to be allocated) */
+int __mnt_fs_set_source_ptr(mnt_fs *fs, char *source)
+{
+	char *t = NULL, *v = NULL;
+
+	assert(fs);
+
+	if (source && !strcmp(source, "none"))
+		source = NULL;
+
+	if (source && strchr(source, '=')) {
+		if (blkid_parse_tag_string(source, &t, &v) != 0)
+			return -1;
+	}
+
+	if (fs->source != source)
+		free(fs->source);
+
+	free(fs->tagname);
+	free(fs->tagval);
+
+	fs->source = source;
+	fs->tagname = t;
+	fs->tagval = v;
+	return 0;
+}
+
+/**
+ * mnt_fs_set_source:
+ * @fs: fstab/mtab/mountinfo entry
+ * @source: new source
+ *
+ * This function creates a private copy (strdup()) of @source.
+ *
+ * Returns: 0 on success or negative number in case of error.
+ */
+int mnt_fs_set_source(mnt_fs *fs, const char *source)
+{
+	char *p;
+	int rc;
+
+	if (!fs && !source)
+		return -EINVAL;
+	p = strdup(source);
+	if (!p)
+		return -ENOMEM;
+
+	rc = __mnt_fs_set_source_ptr(fs, p);
+	if (rc)
+		free(p);
+	return rc;
+}
+
+/**
+ * mnt_fs_get_tag:
+ * @fs: fs
+ * @name: returns pointer to NAME string
+ * @value: returns pointer to VALUE string
+ *
+ * "TAG" is NAME=VALUE (e.g. LABEL=foo)
+ *
+ * The TAG is the first column in the fstab file. The TAG or "srcpath" has to
+ * be always set for all entries.
+ *
+ * See also mnt_fs_get_source().
+ *
+ * <informalexample>
+ *   <programlisting>
+ *	char *src;
+ *	mnt_fs *fs = mnt_tab_find_target(tb, "/home", MNT_ITER_FORWARD);
+ *
+ *	if (!fs)
+ *		goto err;
+ *
+ *	src = mnt_fs_get_srcpath(fs);
+ *	if (!src) {
+ *		char *tag, *val;
+ *		if (mnt_fs_get_tag(fs, &tag, &val) == 0)
+ *			printf("%s: %s\n", tag, val);	// LABEL or UUID
+ *	} else
+ *		printf("device: %s\n", src);		// device or bind path
+ *   </programlisting>
+ * </informalexample>
+ *
+ * Returns: 0 on success or negative number in case that a TAG is not defined.
+ */
+int mnt_fs_get_tag(mnt_fs *fs, const char **name, const char **value)
+{
+	if (fs == NULL || !fs->tagname)
+		return -EINVAL;
+	if (name)
+		*name = fs->tagname;
+	if (value)
+		*value = fs->tagval;
+	return 0;
+}
+
+/**
+ * mnt_fs_get_target:
+ * @fs: fstab/mtab/mountinfo entry pointer
+ *
+ * Returns: pointer to mountpoint path or NULL
+ */
+const char *mnt_fs_get_target(mnt_fs *fs)
+{
+	assert(fs);
+	return fs ? fs->target : NULL;
+}
+
+/**
+ * mnt_fs_set_target:
+ * @fs: fstab/mtab/mountinfo entry
+ * @target: mountpoint
+ *
+ * This function creates a private copy (strdup()) of @target.
+ *
+ * Returns: 0 on success or negative number in case of error.
+ */
+int mnt_fs_set_target(mnt_fs *fs, const char *target)
+{
+	char *p;
+
+	assert(fs);
+
+	if (!fs || !target)
+		return -EINVAL;
+	p = strdup(target);
+	if (!p)
+		return -ENOMEM;
+	free(fs->target);
+	fs->target = p;
+
+	return 0;
+}
+
+/**
+ * mnt_fs_get_fstype:
+ * @fs: fstab/mtab/mountinfo entry pointer
+ *
+ * Returns: pointer to filesystem type.
+ */
+const char *mnt_fs_get_fstype(mnt_fs *fs)
+{
+	assert(fs);
+	return fs ? fs->fstype : NULL;
+}
+
+/* Used by mnt_file parser only */
+int __mnt_fs_set_fstype_ptr(mnt_fs *fs, char *fstype)
+{
+	assert(fs);
+
+	if (fstype != fs->fstype)
+		free(fs->fstype);
+
+	fs->fstype = fstype;
+	fs->flags &= ~MNT_FS_PSEUDO;
+	fs->flags &= ~MNT_FS_NET;
+
+	/* save info about pseudo filesystems */
+	if (fs->fstype) {
+		if (mnt_fstype_is_pseudofs(fs->fstype))
+			fs->flags |= MNT_FS_PSEUDO;
+		else if (mnt_fstype_is_netfs(fs->fstype))
+			fs->flags |= MNT_FS_NET;
+		else if (!strcmp(fs->fstype, "swap"))
+			fs->flags |= MNT_FS_SWAP;
+	}
+	return 0;
+}
+
+/**
+ * mnt_fs_set_fstype:
+ * @fs: fstab/mtab/mountinfo entry
+ * @fstype: filesystem type
+ *
+ * This function creates a private copy (strdup()) of @fstype.
+ *
+ * Returns: 0 on success or negative number in case of error.
+ */
+int mnt_fs_set_fstype(mnt_fs *fs, const char *fstype)
+{
+	char *p = NULL;
+	int rc;
+
+	if (!fs)
+		return -EINVAL;
+	if (fstype) {
+		p = strdup(fstype);
+		if (!p)
+			return -ENOMEM;
+	}
+	rc =  __mnt_fs_set_fstype_ptr(fs, p);
+	if (rc)
+		free(p);
+	return rc;
+}
+
+/*
+ * Merges @vfs and @fs options strings into a new string.
+ * This function cares about 'ro/rw' options. The 'ro' is
+ * always used if @vfs or @fs is read-only.
+ * For example:
+ *
+ *    mnt_merge_optstr("rw,noexec", "ro,journal=update")
+ *
+ *           returns: "ro,noexec,journal=update"
+ *
+ *    mnt_merge_optstr("rw,noexec", "rw,journal=update")
+ *
+ *           returns: "rw,noexec,journal=update"
+ */
+static char *merge_optstr(const char *vfs, const char *fs)
+{
+	char *res, *p;
+	size_t sz;
+	int ro = 0, rw = 0;
+
+	if (!vfs && !fs)
+		return NULL;
+	if (!vfs || !fs)
+		return strdup(fs ? fs : vfs);
+	if (!strcmp(vfs, fs))
+		return strdup(vfs);		/* e.g. "aaa" and "aaa" */
+
+	/* leave space for leading "r[ow],", "," and trailing zero */
+	sz = strlen(vfs) + strlen(fs) + 5;
+	res = malloc(sz);
+	if (!res)
+		return NULL;
+	p = res + 3;			/* make a room for rw/ro flag */
+
+	snprintf(p, sz - 3, "%s,%s", vfs, fs);
+
+	/* remove 'rw' flags */
+	rw += !mnt_optstr_remove_option(&p, "rw");	/* from vfs */
+	rw += !mnt_optstr_remove_option(&p, "rw");	/* from fs */
+
+	/* remove 'ro' flags if necessary */
+	if (rw != 2) {
+		ro += !mnt_optstr_remove_option(&p, "ro");
+		if (ro + rw < 2)
+			ro += !mnt_optstr_remove_option(&p, "ro");
+	}
+
+	if (!strlen(p))
+		memcpy(res, ro ? "ro" : "rw", 3);
+	else
+		memcpy(res, ro ? "ro," : "rw,", 3);
+	return res;
+}
+
+/**
+ * mnt_fs_strdup_options:
+ * @fs: fstab/mtab/mountinfo entry pointer
+ *
+ * Merges all mount options (VFS, FS and userspace) to the one options string
+ * and returns the result. This function does not modigy @fs.
+ *
+ * Returns: pointer to string (can be freed by free(3)) or NULL in case of error.
+ */
+char *mnt_fs_strdup_options(mnt_fs *fs)
+{
+	char *res;
+
+	assert(fs);
+
+	errno = 0;
+	res = merge_optstr(fs->vfs_optstr, fs->fs_optstr);
+	if (!res && errno)
+		return NULL;
+	if (fs->user_optstr) {
+		if (mnt_optstr_append_option(&res, fs->user_optstr, NULL)) {
+			free(res);
+			res = NULL;
+		}
+	}
+	return res;
+}
+
+/**
+ * mnt_fs_set_options:
+ * @fs: fstab/mtab/mountinfo entry pointer
+ * @optstr: options string
+ *
+ * Splits @optstr to VFS, FS and userspace mount options and update relevat
+ * parts of @fs.
+ *
+ * Returns: 0 on success, or negative number icase of error.
+ */
+int mnt_fs_set_options(mnt_fs *fs, const char *optstr)
+{
+	char *v = NULL, *f = NULL, *u = NULL;
+
+	assert(fs);
+
+	if (!fs)
+		return -EINVAL;
+	if (optstr) {
+		int rc = mnt_split_optstr(optstr, &u, &v, &f, 0, 0);
+		if (rc)
+			return rc;
+	}
+
+	free(fs->fs_optstr);
+	free(fs->vfs_optstr);
+	free(fs->user_optstr);
+
+	fs->fs_optstr = f;
+	fs->vfs_optstr = v;
+	fs->user_optstr = u;
+	return 0;
+}
+
+/**
+ * mnt_fs_append_options:
+ * @fs: fstab/mtab/mountinfo entry
+ * @optstr: mount options
+ *
+ * Parses (splits) @optstr and appends results to VFS, FS and userspace lists
+ * of options.
+ *
+ * If @optstr is NULL then @fs is not modified and 0 is returned.
+ *
+ * Returns: 0 on success or negative number in case of error.
+ */
+int mnt_fs_append_options(mnt_fs *fs, const char *optstr)
+{
+	char *v = NULL, *f = NULL, *u = NULL;
+	int rc;
+
+	assert(fs);
+
+	if (!fs)
+		return -EINVAL;
+	if (!optstr)
+		return 0;
+
+	rc = mnt_split_optstr((char *) optstr, &u, &v, &f, 0, 0);
+	if (!rc && v)
+		rc = mnt_optstr_append_option(&fs->vfs_optstr, v, NULL);
+	if (!rc && f)
+	       rc = mnt_optstr_append_option(&fs->fs_optstr, f, NULL);
+	if (!rc && u)
+	       rc = mnt_optstr_append_option(&fs->user_optstr, u, NULL);
+
+	return rc;
+}
+
+/**
+ * mnt_fs_prepend_options:
+ * @fs: fstab/mtab/mountinfo entry
+ * @optstr: mount options
+ *
+ * Parses (splits) @optstr and prepands results to VFS, FS and userspace lists
+ * of options.
+ *
+ * If @optstr is NULL then @fs is not modified and 0 is returned.
+ *
+ * Returns: 0 on success or negative number in case of error.
+ */
+int mnt_fs_prepend_options(mnt_fs *fs, const char *optstr)
+{
+	char *v = NULL, *f = NULL, *u = NULL;
+	int rc;
+
+	assert(fs);
+
+	if (!fs)
+		return -EINVAL;
+	if (!optstr)
+		return 0;
+
+	rc = mnt_split_optstr((char *) optstr, &u, &v, &f, 0, 0);
+	if (!rc && v)
+		rc = mnt_optstr_prepend_option(&fs->vfs_optstr, v, NULL);
+	if (!rc && f)
+		rc = mnt_optstr_prepend_option(&fs->fs_optstr, f, NULL);
+	if (!rc && u)
+		rc = mnt_optstr_prepend_option(&fs->user_optstr, u, NULL);
+
+	return rc;
+}
+
+/*
+ * mnt_fs_get_fs_options:
+ * @fs: fstab/mtab/mountinfo entry pointer
+ *
+ * Returns: pointer to superblock (fs-depend) mount option string or NULL.
+ */
+const char *mnt_fs_get_fs_options(mnt_fs *fs)
+{
+	assert(fs);
+	return fs ? fs->fs_optstr : NULL;
+}
+
+/**
+ * mnt_fs_set_fs_options:
+ * @fs: fstab/mtab/mountinfo entry
+ * @optstr: options string
+ *
+ * Sets FS specific mount options.
+ *
+ * Returns: 0 on success or negative number in case of error.
+ */
+int mnt_fs_set_fs_options(mnt_fs *fs, const char *optstr)
+{
+	char *p = NULL;
+
+	if (!fs)
+		return -EINVAL;
+	if (optstr) {
+		p = strdup(optstr);
+		if (!p)
+			return -ENOMEM;
+	}
+	free(fs->fs_optstr);
+	fs->fs_optstr = p;
+
+	return 0;
+}
+
+/**
+ * mnt_fs_append_fs_options:
+ * @fs: fstab/mtab/mountinfo entry
+ * @optstr: options string
+ *
+ * Appends FS specific mount options. If @optstr is NULL then @fs is not
+ * modified and 0 is returned.
+ *
+ * Returns: 0 on success or negative number in case of error.
+ */
+int mnt_fs_append_fs_options(mnt_fs *fs, const char *optstr)
+{
+	if (!fs)
+		return -EINVAL;
+	if (!optstr)
+		return 0;
+	return mnt_optstr_append_option(&fs->fs_optstr, optstr, NULL);
+}
+
+/**
+ * mnt_fs_prepend_fs_options:
+ * @fs: fstab/mtab/mountinfo entry
+ * @optstr: options string
+ *
+ * Prepends FS specific mount options. If @optstr is NULL then @fs is not
+ * modified and 0 is returned.
+ *
+ * Returns: 0 on success or negative number in case of error.
+ */
+int mnt_fs_prepend_fs_options(mnt_fs *fs, const char *optstr)
+{
+	if (!fs)
+		return -EINVAL;
+	if (!optstr)
+		return 0;
+	return mnt_optstr_prepend_option(&fs->fs_optstr, optstr, NULL);
+}
+
+
+/**
+ * mnt_fs_get_vfs_options:
+ * @fs: fstab/mtab entry pointer
+ *
+ * Returns: pointer to fs-independent (VFS) mount option string or NULL.
+ */
+const char *mnt_fs_get_vfs_options(mnt_fs *fs)
+{
+	assert(fs);
+	return fs ? fs->vfs_optstr : NULL;
+}
+
+/**
+ * mnt_fs_set_vfs_options:
+ * @fs: fstab/mtab/mountinfo entry
+ * @optstr: options string
+ *
+ * Sets VFS mount options.
+ *
+ * Returns: 0 on success or negative number in case of error.
+ */
+int mnt_fs_set_vfs_options(mnt_fs *fs, const char *optstr)
+{
+	char *p = NULL;
+
+	if (!fs)
+		return -EINVAL;
+	if (optstr) {
+		p = strdup(optstr);
+		if (!p)
+			return -ENOMEM;
+	}
+	free(fs->vfs_optstr);
+	fs->vfs_optstr = p;
+
+	return 0;
+}
+
+/**
+ * mnt_fs_append_vfs_options:
+ * @fs: fstab/mtab/mountinfo entry
+ * @optstr: options string
+ *
+ * Appends VFS mount options. If @optstr is NULL then @fs is not
+ * modified and 0 is returned.
+ *
+ * Returns: 0 on success or negative number in case of error.
+ */
+int mnt_fs_append_vfs_options(mnt_fs *fs, const char *optstr)
+{
+	if (!fs)
+		return -EINVAL;
+	if (!optstr)
+		return 0;
+	return mnt_optstr_append_option(&fs->vfs_optstr, optstr, NULL);
+}
+
+/**
+ * mnt_fs_prepend_vfs_options:
+ * @fs: fstab/mtab/mountinfo entry
+ * @optstr: options string
+ *
+ * Prepends VFS mount options. If @optstr is NULL then @fs is not
+ * modified and 0 is returned.
+ *
+ * Returns: 0 on success or negative number in case of error.
+ */
+int mnt_fs_prepend_vfs_options(mnt_fs *fs, const char *optstr)
+{
+	if (!fs)
+		return -EINVAL;
+	if (!optstr)
+		return 0;
+	return mnt_optstr_prepend_option(&fs->vfs_optstr, optstr, NULL);
+}
+
+/**
+ * mnt_fs_get_userspace_options:
+ * @fs: fstab/mtab entry pointer
+ *
+ * Returns: pointer to userspace mount option string or NULL.
+ */
+const char *mnt_fs_get_userspace_options(mnt_fs *fs)
+{
+	assert(fs);
+	return fs ? fs->user_optstr : NULL;
+}
+
+/**
+ * mnt_fs_set_userspace_options:
+ * @fs: fstab/mtab/mountinfo entry
+ * @optstr: options string
+ *
+ * Sets userspace mount options.
+ *
+ * Returns: 0 on success or negative number in case of error.
+ */
+int mnt_fs_set_userspace_options(mnt_fs *fs, const char *optstr)
+{
+	char *p = NULL;
+
+	if (!fs)
+		return -EINVAL;
+	if (optstr) {
+		p = strdup(optstr);
+		if (!p)
+			return -ENOMEM;
+	}
+	free(fs->user_optstr);
+	fs->user_optstr = p;
+
+	return 0;
+}
+
+/**
+ * mnt_fs_append_userspace_options:
+ * @fs: fstab/mtab/mountinfo entry
+ * @optstr: options string
+ *
+ * Appends userspace mount options. If @optstr is NULL then @fs is not
+ * modified and 0 is returned.
+ *
+ * Returns: 0 on success or negative number in case of error.
+ */
+int mnt_fs_append_userspace_options(mnt_fs *fs, const char *optstr)
+{
+	if (!fs)
+		return -EINVAL;
+	if (!optstr)
+		return 0;
+	return mnt_optstr_append_option(&fs->user_optstr, optstr, NULL);
+}
+
+/**
+ * mnt_fs_prepend_userspace_options:
+ * @fs: fstab/mtab/mountinfo entry
+ * @optstr: options string
+ *
+ * Prepends userspace mount options. If @optstr is NULL then @fs is not
+ * modified and 0 is returned.
+ *
+ * Returns: 0 on success or negative number in case of error.
+ */
+int mnt_fs_prepend_userspace_options(mnt_fs *fs, const char *optstr)
+{
+	if (!fs)
+		return -EINVAL;
+	if (!optstr)
+		return 0;
+
+	return mnt_optstr_prepend_option(&fs->user_optstr, optstr, NULL);
+}
+
+/**
+ * mnt_fs_get_attributes:
+ * @fs: fstab/mtab entry pointer
+ *
+ * Returns: pointer to attributes string or NULL.
+ */
+const char *mnt_fs_get_attributes(mnt_fs *fs)
+{
+	assert(fs);
+	return fs ? fs->attrs : NULL;
+}
+
+/**
+ * mnt_fs_set_attributes:
+ * @fs: fstab/mtab/mountinfo entry
+ * @optstr: options string
+ *
+ * Sets mount attributes. The attributes are mount(2) and mount(8) independent
+ * options, these options are not send to kernel and are not interpreted by
+ * libmount. The attributes are stored in /dev/.mount/utab only.
+ *
+ * The atrtributes are managed by libmount in userspace only. It's possible
+ * that information stored in userspace will not be available for libmount
+ * after CLONE_FS unshare. Be carefull, and don't use attributes if possible.
+ *
+ * Returns: 0 on success or negative number in case of error.
+ */
+int mnt_fs_set_attributes(mnt_fs *fs, const char *optstr)
+{
+	char *p = NULL;
+
+	if (!fs)
+		return -EINVAL;
+	if (optstr) {
+		p = strdup(optstr);
+		if (!p)
+			return -ENOMEM;
+	}
+	free(fs->attrs);
+	fs->attrs = p;
+
+	return 0;
+}
+
+/**
+ * mnt_fs_append_attributes
+ * @fs: fstab/mtab/mountinfo entry
+ * @optstr: options string
+ *
+ * Appends mount attributes. (See mnt_fs_set_attributes()).
+ *
+ * Returns: 0 on success or negative number in case of error.
+ */
+int mnt_fs_append_attributes(mnt_fs *fs, const char *optstr)
+{
+	if (!fs)
+		return -EINVAL;
+	if (!optstr)
+		return 0;
+	return mnt_optstr_append_option(&fs->attrs, optstr, NULL);
+}
+
+/**
+ * mnt_fs_prepend_attributes
+ * @fs: fstab/mtab/mountinfo entry
+ * @optstr: options string
+ *
+ * Prepends mount attributes. (See mnt_fs_set_attributes()).
+ *
+ * Returns: 0 on success or negative number in case of error.
+ */
+int mnt_fs_prepend_attributes(mnt_fs *fs, const char *optstr)
+{
+	if (!fs)
+		return -EINVAL;
+	if (!optstr)
+		return 0;
+	return mnt_optstr_prepend_option(&fs->attrs, optstr, NULL);
+}
+
+
+/**
+ * mnt_fs_get_freq:
+ * @fs: fstab/mtab/mountinfo entry pointer
+ *
+ * Returns: dump frequency in days.
+ */
+int mnt_fs_get_freq(mnt_fs *fs)
+{
+	assert(fs);
+	return fs ? fs->freq : 0;
+}
+
+/**
+ * mnt_fs_set_freq:
+ * @fs: fstab/mtab entry pointer
+ * @freq: dump frequency in days
+ *
+ * Returns: 0 on success or negative number in case of error.
+ */
+int mnt_fs_set_freq(mnt_fs *fs, int freq)
+{
+	assert(fs);
+	if (!fs)
+		return -EINVAL;
+	fs->freq = freq;
+	return 0;
+}
+
+/**
+ * mnt_fs_get_passno:
+ * @fs: fstab/mtab entry pointer
+ *
+ * Returns: "pass number on parallel fsck".
+ */
+int mnt_fs_get_passno(mnt_fs *fs)
+{
+	assert(fs);
+	return fs ? fs->passno: 0;
+}
+
+/**
+ * mnt_fs_set_passno:
+ * @fs: fstab/mtab entry pointer
+ * @passno: pass number
+ *
+ * Returns: 0 on success or negative number in case of error.
+ */
+int mnt_fs_set_passno(mnt_fs *fs, int passno)
+{
+	assert(fs);
+	if (!fs)
+		return -EINVAL;
+	fs->passno = passno;
+	return 0;
+}
+
+/**
+ * mnt_fs_get_root:
+ * @fs: /proc/self/mountinfo entry
+ *
+ * Returns: root of the mount within the filesystem or NULL
+ */
+const char *mnt_fs_get_root(mnt_fs *fs)
+{
+	assert(fs);
+	return fs ? fs->root : NULL;
+}
+
+/**
+ * mnt_fs_set_root:
+ * @fs: mountinfo entry
+ * @root: path
+ *
+ * Returns: 0 on success or negative number in case of error.
+ */
+int mnt_fs_set_root(mnt_fs *fs, const char *root)
+{
+	char *p = NULL;
+
+	assert(fs);
+	if (!fs)
+		return -EINVAL;
+	if (root) {
+		p = strdup(root);
+		if (!p)
+			return -ENOMEM;
+	}
+	free(fs->root);
+	fs->root = p;
+	return 0;
+}
+
+/**
+ * mnt_fs_get_bindsrc:
+ * @fs: /dev/.mount/utab entry
+ *
+ * Returns: full path that was used for mount(2) on MS_BIND
+ */
+const char *mnt_fs_get_bindsrc(mnt_fs *fs)
+{
+	assert(fs);
+	return fs ? fs->bindsrc : NULL;
+}
+
+/**
+ * mnt_fs_set_bindsrc:
+ * @fs: filesystem
+ * @src: path
+ *
+ * Returns: 0 on success or negative number in case of error.
+ */
+int mnt_fs_set_bindsrc(mnt_fs *fs, const char *src)
+{
+	char *p = NULL;
+
+	assert(fs);
+	if (!fs)
+		return -EINVAL;
+	if (src) {
+		p = strdup(src);
+		if (!p)
+			return -ENOMEM;
+	}
+	free(fs->bindsrc);
+	fs->bindsrc = p;
+	return 0;
+}
+
+/**
+ * mnt_fs_get_id:
+ * @fs: /proc/self/mountinfo entry
+ *
+ * Returns: mount ID (unique identifier of the mount) or negative number in case of error.
+ */
+int mnt_fs_get_id(mnt_fs *fs)
+{
+	assert(fs);
+	return fs ? fs->id : -EINVAL;
+}
+
+/**
+ * mnt_fs_get_parent_id:
+ * @fs: /proc/self/mountinfo entry
+ *
+ * Returns: parent mount ID or negative number in case of error.
+ */
+int mnt_fs_get_parent_id(mnt_fs *fs)
+{
+	assert(fs);
+	return fs ? fs->parent : -EINVAL;
+}
+
+/**
+ * mnt_fs_get_devno:
+ * @fs: /proc/self/mountinfo entry
+ *
+ * Returns: value of st_dev for files on filesystem or 0 in case of error.
+ */
+dev_t mnt_fs_get_devno(mnt_fs *fs)
+{
+	assert(fs);
+	return fs ? fs->devno : 0;
+}
+
+/**
+ * mnt_fs_get_option:
+ * @fs: fstab/mtab/mountinfo entry pointer
+ * @name: option name
+ * @value: returns pointer to the begin of the value (e.g. name=VALUE) or NULL
+ * @valsz: returns size of options value or 0
+ *
+ * Returns: 0 on success, 1 when not found the @name or negative number in case of error.
+ */
+int mnt_fs_get_option(mnt_fs *fs, const char *name,
+		char **value, size_t *valsz)
+{
+	char rc = 1;
+
+	if (fs->fs_optstr)
+		rc = mnt_optstr_get_option(fs->fs_optstr, name, value, valsz);
+	if (rc == 1 && fs->vfs_optstr)
+		rc = mnt_optstr_get_option(fs->vfs_optstr, name, value, valsz);
+	if (rc == 1 && fs->user_optstr)
+		rc = mnt_optstr_get_option(fs->user_optstr, name, value, valsz);
+	return rc;
+}
+
+/**
+ * mnt_fs_get_attribute:
+ * @fs: fstab/mtab/mountinfo entry pointer
+ * @name: option name
+ * @value: returns pointer to the begin of the value (e.g. name=VALUE) or NULL
+ * @valsz: returns size of options value or 0
+ *
+ * Returns: 0 on success, 1 when not found the @name or negative number in case of error.
+ */
+int mnt_fs_get_attribute(mnt_fs *fs, const char *name,
+		char **value, size_t *valsz)
+{
+	char rc = 1;
+
+	if (fs->attrs)
+		rc = mnt_optstr_get_option(fs->attrs, name, value, valsz);
+	return rc;
+}
+
+/**
+ * mnt_fs_match_target:
+ * @fs: filesystem
+ * @target: mountpoint path
+ * @cache: tags/paths cache or NULL
+ *
+ * Possible are three attempts:
+ *	1) compare @target with @fs->target
+ *	2) realpath(@target) with @fs->target
+ *	3) realpath(@target) with realpath(@fs->target).
+ *
+ * The 2nd and 3rd attempts are not performed when @cache is NULL.
+ *
+ * Returns: 1 if @fs target is equal to @target else 0.
+ */
+int mnt_fs_match_target(mnt_fs *fs, const char *target, mnt_cache *cache)
+{
+	int rc = 0;
+
+	if (!fs || !target || !fs->target)
+		return 0;
+
+	/* 1) native paths */
+	rc = !strcmp(target, fs->target);
+
+	if (!rc && cache) {
+		/* 2) - canonicalized and non-canonicalized */
+		char *cn = mnt_resolve_path(target, cache);
+		rc = (cn && strcmp(cn, fs->target) == 0);
+
+		/* 3) - canonicalized and canonicalized */
+		if (!rc && cn) {
+			char *tcn = mnt_resolve_path(fs->target, cache);
+			rc = (tcn && strcmp(cn, tcn) == 0);
+		}
+	}
+
+	return rc;
+}
+
+/**
+ * mnt_fs_match_source:
+ * @fs: filesystem
+ * @source: tag or path (device or so)
+ * @cache: tags/paths cache or NULL
+ *
+ * Possible are four attempts:
+ *	1) compare @source with @fs->source
+ *	2) compare realpath(@source) with @fs->source
+ *	3) compare realpath(@source) with realpath(@fs->source)
+ *	4) compare realpath(@source) with evaluated tag from @fs->source
+ *
+ * The 2nd, 3rd and 4th attempts are not performed when @cache is NULL. The
+ * 2nd and 3rd attempts are not performed if @fs->source is tag.
+ *
+ * Returns: 1 if @fs source is equal to @source else 0.
+ */
+int mnt_fs_match_source(mnt_fs *fs, const char *source, mnt_cache *cache)
+{
+	char *cn;
+	const char *src, *t, *v;
+
+	if (!fs || !source || !fs->source)
+		return 0;
+
+	/* 1) native paths/tags */
+	if (!strcmp(source, fs->source))
+		return 1;
+
+	if (!cache)
+		return 0;
+	if (fs->flags & (MNT_FS_NET | MNT_FS_PSEUDO))
+		return 0;
+
+	cn = mnt_resolve_spec(source, cache);
+	if (!cn)
+		return 0;
+
+	/* 2) canonicalized and native */
+	src = mnt_fs_get_srcpath(fs);
+	if (src && !strcmp(cn, src))
+		return 1;
+
+	/* 3) canonicalized and canonicalized */
+	if (src) {
+		src = mnt_resolve_path(src, cache);
+		if (src && !strcmp(cn, src))
+			return 1;
+	}
+	if (src || mnt_fs_get_tag(fs, &t, &v))
+		/* src path does not match and tag is not defined */
+		return 0;
+
+	/* read @source's tags to the cache */
+	if (mnt_cache_read_tags(cache, cn) < 0) {
+		if (errno == EACCES) {
+			/* we don't have permissions to read TAGs from
+			 * @source, but can translate @fs tag to devname.
+			 *
+			 * (because libblkid uses udev symlinks and this is
+			 * accessible for non-root uses)
+			 */
+			char *x = mnt_resolve_tag(t, v, cache);
+			if (x && !strcmp(x, cn))
+				return 1;
+		}
+		return 0;
+	}
+
+	/* 4) has the @source a tag that matches with tag from @fs ? */
+	if (mnt_cache_device_has_tag(cache, cn, t, v))
+		return 1;
+
+	return 0;
+}
+
+/**
+ * mnt_fs_match_fstype:
+ * @fs: filesystem
+ * @types: filesystem name or comma delimited list of filesystems
+ *
+ * For more details see mnt_match_fstype().
+ *
+ * Returns: 1 if @fs type is matching to @types else 0. The function returns
+ * 0 when types is NULL.
+ */
+int mnt_fs_match_fstype(mnt_fs *fs, const char *types)
+{
+	return mnt_match_fstype(fs->fstype, types);
+}
+
+/**
+ * mnt_fs_match_options:
+ * @fs: filesystem
+ * @options: comma delimited list of options (and nooptions)
+ *
+ * For more details see mnt_match_options().
+ *
+ * Returns: 1 if @fs type is matching to @options else 0. The function returns
+ * 0 when types is NULL.
+ */
+int mnt_fs_match_options(mnt_fs *fs, const char *options)
+{
+	char *o = mnt_fs_strdup_options(fs);
+	int rc = 0;
+
+	if (o)
+		rc = mnt_match_options(o, options);
+	free(o);
+	return rc;
+}
+
+/**
+ * mnt_fs_print_debug
+ * @fs: fstab/mtab/mountinfo entry
+ * @file: output
+ *
+ * Returns: 0 on success or negative number in case of error.
+ */
+int mnt_fs_print_debug(mnt_fs *fs, FILE *file)
+{
+	if (!fs)
+		return -EINVAL;
+	fprintf(file, "------ fs: %p\n", fs);
+	fprintf(file, "source: %s\n", mnt_fs_get_source(fs));
+	fprintf(file, "target: %s\n", mnt_fs_get_target(fs));
+	fprintf(file, "fstype: %s\n", mnt_fs_get_fstype(fs));
+
+	if (mnt_fs_get_vfs_options(fs))
+		fprintf(file, "VFS-optstr: %s\n", mnt_fs_get_vfs_options(fs));
+	if (mnt_fs_get_fs_options(fs))
+		fprintf(file, "FS-opstr: %s\n", mnt_fs_get_fs_options(fs));
+	if (mnt_fs_get_userspace_options(fs))
+		fprintf(file, "user-optstr: %s\n", mnt_fs_get_userspace_options(fs));
+	if (mnt_fs_get_attributes(fs))
+		fprintf(file, "attributes: %s\n", mnt_fs_get_attributes(fs));
+
+	if (mnt_fs_get_root(fs))
+		fprintf(file, "root:   %s\n", mnt_fs_get_root(fs));
+	if (mnt_fs_get_bindsrc(fs))
+		fprintf(file, "bindsrc: %s\n", mnt_fs_get_bindsrc(fs));
+	if (mnt_fs_get_freq(fs))
+		fprintf(file, "freq:   %d\n", mnt_fs_get_freq(fs));
+	if (mnt_fs_get_passno(fs))
+		fprintf(file, "pass:   %d\n", mnt_fs_get_passno(fs));
+	if (mnt_fs_get_id(fs))
+		fprintf(file, "id:     %d\n", mnt_fs_get_id(fs));
+	if (mnt_fs_get_parent_id(fs))
+		fprintf(file, "parent: %d\n", mnt_fs_get_parent_id(fs));
+	if (mnt_fs_get_devno(fs))
+		fprintf(file, "devno:  %d:%d\n", major(mnt_fs_get_devno(fs)),
+						 minor(mnt_fs_get_devno(fs)));
+	return 0;
+}
+
+/**
+ * mnt_free_mntent:
+ * @mnt: mount entry
+ *
+ * Deallocates "mntent.h" mount entry.
+ */
+void mnt_free_mntent(struct mntent *mnt)
+{
+	if (mnt) {
+		free(mnt->mnt_fsname);
+		free(mnt->mnt_dir);
+		free(mnt->mnt_type);
+		free(mnt->mnt_opts);
+		free(mnt);
+	}
+}
+
diff -up util-linux-ng-2.17.2/shlibs/mount/src/init.c.kzak util-linux-ng-2.17.2/shlibs/mount/src/init.c
--- util-linux-ng-2.17.2/shlibs/mount/src/init.c.kzak	2012-10-08 12:51:49.136688889 +0200
+++ util-linux-ng-2.17.2/shlibs/mount/src/init.c	2012-10-08 12:51:49.136688889 +0200
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2008 Karel Zak <kzak@redhat.com>
+ *
+ * This file may be redistributed under the terms of the
+ * GNU Lesser General Public License.
+ */
+
+/**
+ * SECTION: init
+ * @title: Library initialization
+ * @short_description: initialize debuging
+ */
+
+#include <stdlib.h>
+#include <stdarg.h>
+
+#include "mountP.h"
+
+int libmount_debug_mask;
+
+/**
+ * mnt_init_debug:
+ * @mask: debug mask (0xffff to enable full debuging)
+ *
+ * If the @mask is not specified then this function reads
+ * LIBMOUNT_DEBUG environment variable to get the mask.
+ *
+ * Already initialized debugging stuff cannot be changed. It does not
+ * have effect to call this function twice.
+ */
+void mnt_init_debug(int mask)
+{
+	if (libmount_debug_mask & MNT_DEBUG_INIT)
+		return;
+	if (!mask) {
+		char *str = getenv("LIBMOUNT_DEBUG");
+		if (str)
+			libmount_debug_mask = strtoul(str, 0, 0);
+	} else
+		libmount_debug_mask = mask;
+
+	if (libmount_debug_mask)
+		printf("libmount: debug mask set to 0x%04x.\n",
+				libmount_debug_mask);
+	libmount_debug_mask |= MNT_DEBUG_INIT;
+}
diff -up util-linux-ng-2.17.2/shlibs/mount/src/iter.c.kzak util-linux-ng-2.17.2/shlibs/mount/src/iter.c
--- util-linux-ng-2.17.2/shlibs/mount/src/iter.c.kzak	2012-10-08 12:51:49.136688889 +0200
+++ util-linux-ng-2.17.2/shlibs/mount/src/iter.c	2012-10-08 12:51:49.136688889 +0200
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2009 Karel Zak <kzak@redhat.com>
+ *
+ * This file may be redistributed under the terms of the
+ * GNU Lesser General Public License.
+ */
+
+/**
+ * SECTION: iter
+ * @title: Iterator
+ * @short_description: unified iterator
+ *
+ * The iterator keeps direction and last position for access to the internal
+ * library tables/lists.
+ */
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+
+#include "mountP.h"
+
+/**
+ * mnt_new_iter:
+ * @direction: MNT_INTER_{FOR,BACK}WARD direction
+ *
+ * Returns: newly allocated generic libmount iterator.
+ */
+mnt_iter *mnt_new_iter(int direction)
+{
+	mnt_iter *itr = calloc(1, sizeof(struct _mnt_iter));
+	if (!itr)
+		return NULL;
+	itr->direction = direction;
+	return itr;
+}
+
+/**
+ * mnt_free_iter:
+ * @itr: iterator pointer
+ *
+ * Deallocates iterator.
+ */
+void mnt_free_iter(mnt_iter *itr)
+{
+	free(itr);
+}
+
+/**
+ * mnt_reset_iter:
+ * @itr: iterator pointer
+ * @direction: MNT_INTER_{FOR,BACK}WARD or -1 to keep the derection unchanged
+ *
+ * Resets iterator.
+ */
+void mnt_reset_iter(mnt_iter *itr, int direction)
+{
+	assert(itr);
+
+	if (direction == -1)
+		direction = itr->direction;
+
+	if (itr) {
+		memset(itr, 0, sizeof(struct _mnt_iter));
+		itr->direction = direction;
+	}
+}
+
+/**
+ * mnt_iter_get_direction:
+ * @itr: iterator pointer
+ *
+ * Returns: MNT_INTER_{FOR,BACK}WARD or negative number in case of error.
+ */
+int mnt_iter_get_direction(mnt_iter *itr)
+{
+	assert(itr);
+	return itr ? itr->direction : -EINVAL;
+}
diff -up util-linux-ng-2.17.2/shlibs/mount/src/Makefile.am.kzak util-linux-ng-2.17.2/shlibs/mount/src/Makefile.am
--- util-linux-ng-2.17.2/shlibs/mount/src/Makefile.am.kzak	2012-10-08 12:51:49.136688889 +0200
+++ util-linux-ng-2.17.2/shlibs/mount/src/Makefile.am	2012-10-08 12:51:49.136688889 +0200
@@ -0,0 +1,45 @@
+include $(top_srcdir)/config/include-Makefile.am
+
+AM_CPPFLAGS += -I$(ul_libmount_incdir) \
+	       -I$(ul_libmount_srcdir) \
+	       -I$(ul_libblkid_incdir)
+
+
+
+
+
+usrlib_exec_LTLIBRARIES = libmount.la
+libmount_la_SOURCES =	mountP.h utils.c init.c cache.c \
+			optstr.c iter.c optmap.c \
+			fs.c tab.c tab_parse.c \
+			$(mountinc_HEADERS) \
+			$(top_srcdir)/include/list.h \
+			$(top_srcdir)/lib/canonicalize.c \
+			$(top_srcdir)/lib/strutils.c \
+			$(top_srcdir)/lib/env.c
+
+nodist_libmount_la_SOURCES = mount.h mountP.h
+
+libmount_la_LIBADD = $(ul_libblkid_la)
+
+libmount_la_DEPENDENCIES = $(libmount_la_LIBADD) mount.sym mount.h.in
+
+libmount_la_LDFLAGS = -Wl,--version-script=$(ul_libmount_srcdir)/mount.sym \
+                      -version-info $(LIBMOUNT_VERSION_INFO)
+
+EXTRA_DIST = mount.sym mount.h.in
+
+# move lib from $(usrlib_execdir) to $(libdir) if needed
+install-exec-hook:
+	if test "$(usrlib_execdir)" != "$(libdir)"; then \
+		mkdir -p $(DESTDIR)$(libdir); \
+		mv $(DESTDIR)$(usrlib_execdir)/libmount.so.* $(DESTDIR)$(libdir); \
+		so_img_name=$$(readlink $(DESTDIR)$(usrlib_execdir)/libmount.so); \
+		so_img_rel_target=$$(echo $(usrlib_execdir) | sed 's,\(^/\|\)[^/][^/]*,..,g'); \
+		(cd $(DESTDIR)$(usrlib_execdir) && \
+			rm -f libmount.so && \
+			$(LN_S) $$so_img_rel_target$(libdir)/$$so_img_name libmount.so); \
+	fi
+
+uninstall-hook:
+	rm -f $(DESTDIR)$(libdir)/libmount.so*
diff -up util-linux-ng-2.17.2/shlibs/mount/src/mount.h.in.kzak util-linux-ng-2.17.2/shlibs/mount/src/mount.h.in
--- util-linux-ng-2.17.2/shlibs/mount/src/mount.h.in.kzak	2012-10-08 12:51:49.137688895 +0200
+++ util-linux-ng-2.17.2/shlibs/mount/src/mount.h.in	2012-10-08 12:51:49.137688895 +0200
@@ -0,0 +1,366 @@
+/*
+ * mount.h - libmount API
+ *
+ * Copyright (C) 2008-2009 Karel Zak <kzak@redhat.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
+ */
+
+#ifndef _LIBMOUNT_MOUNT_H
+#define _LIBMOUNT_MOUNT_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef USE_UNSTABLE_LIBMOUNT_API
+# warning libmount API is not stable yet!
+#endif
+
+#include <stdio.h>
+#include <mntent.h>
+#include <sys/types.h>
+
+#define LIBMOUNT_VERSION   "@LIBMOUNT_VERSION@"
+
+/**
+ * mnt_cache:
+ *
+ * Stores canonicalized paths and evaluated tags
+ */
+typedef struct _mnt_cache mnt_cache;
+
+/**
+ * mnt_lock:
+ *
+ * Stores information about locked file (e.g. /etc/mtab)
+ */
+typedef struct _mnt_lock mnt_lock;
+
+/**
+ * mnt_iter:
+ *
+ * Generic iterator (stores state about lists)
+ */
+typedef struct _mnt_iter mnt_iter;
+
+/**
+ * mnt_optmap:
+ *
+ * Mount options description (map)
+ */
+struct mnt_optmap
+{
+	const char	*name;	 /* option name[=%<type>] (e.g. "loop[=%s]") */
+	int		id;	 /* option ID or MS_* flags (e.g MS_RDONLY) */
+	int		mask;	 /* MNT_{NOMTAB,INVERT,...} mask */
+};
+
+/*
+ * mount options map masks
+ */
+#define MNT_INVERT	(1 << 1) /* invert the mountflag */
+#define MNT_NOMTAB	(1 << 2) /* skip in the mtab option string */
+
+/**
+ * mnt_fs:
+ *
+ * Parsed fstab/mtab/mountinfo entry
+ */
+typedef struct _mnt_fs mnt_fs;
+
+/**
+ * mnt_tab:
+ *
+ * List of mnt_fs entries (parsed fstab/mtab/mountinfo)
+ */
+typedef struct _mnt_tab mnt_tab;
+
+/* init.c */
+extern void mnt_init_debug(int mask);
+
+/* utils.c */
+extern int mnt_fstype_is_netfs(const char *type);
+extern int mnt_fstype_is_pseudofs(const char *type);
+extern int mnt_match_fstype(const char *type, const char *pattern);
+extern int mnt_match_options(const char *optstr, const char *pattern);
+extern const char *mnt_get_fstab_path(void);
+extern const char *mnt_get_mtab_path(void);
+extern int mnt_has_regular_mtab(const char **mtab, int *writable);
+
+/* cache.c */
+extern mnt_cache *mnt_new_cache(void);
+extern void mnt_free_cache(mnt_cache *cache);
+extern int mnt_cache_read_tags(mnt_cache *cache, const char *devname);
+extern int mnt_cache_device_has_tag(mnt_cache *cache, const char *devname,
+                                const char *token, const char *value);
+
+extern char *mnt_cache_find_tag_value(mnt_cache *cache,
+				const char *devname, const char *token);
+
+extern char *mnt_get_fstype(const char *devname, int *ambi, mnt_cache *cache);
+extern char *mnt_resolve_path(const char *path, mnt_cache *cache);
+extern char *mnt_resolve_tag(const char *token, const char *value, mnt_cache *cache);
+extern char *mnt_resolve_spec(const char *spec, mnt_cache *cache);
+
+/* optstr.c */
+extern int mnt_optstr_next_option(char **optstr, char **name, size_t *namesz,
+				char **value, size_t *valuesz);
+extern int mnt_optstr_append_option(char **optstr, const char *name,
+				const char *value);
+extern int mnt_optstr_prepend_option(char **optstr, const char *name,
+				const char *value);
+extern int mnt_optstr_get_option(char *optstr, const char *name,
+				char **value, size_t *valsz);
+extern int mnt_optstr_set_option(char **optstr, const char *name,
+				const char *value);
+extern int mnt_optstr_remove_option(char **optstr, const char *name);
+
+extern int mnt_split_optstr(const char *optstr,
+			    char **user, char **vfs, char **fs,
+			    int ignore_user, int ignore_vfs);
+
+extern int mnt_optstr_get_options(const char *optstr, char **subset,
+                            const struct mnt_optmap *map, int ignore);
+
+extern int mnt_optstr_get_flags(const char *optstr, unsigned long *flags,
+				const struct mnt_optmap *map);
+extern int mnt_optstr_apply_flags(char **optstr, unsigned long flags,
+                                const struct mnt_optmap *map);
+
+/* iter.c */
+enum {
+
+	MNT_ITER_FORWARD = 0,
+	MNT_ITER_BACKWARD
+};
+extern mnt_iter *mnt_new_iter(int direction);
+extern void mnt_free_iter(mnt_iter *itr);
+extern void mnt_reset_iter(mnt_iter *itr, int direction);
+extern int mnt_iter_get_direction(mnt_iter *itr);
+
+/* optmap.c */
+enum {
+	MNT_LINUX_MAP = 1,
+	MNT_USERSPACE_MAP
+};
+extern const struct mnt_optmap *mnt_get_builtin_optmap(int id);
+
+/* fs.c */
+extern mnt_fs *mnt_new_fs(void);
+extern void mnt_free_fs(mnt_fs *fs);
+extern void *mnt_fs_get_userdata(mnt_fs *fs);
+extern int mnt_fs_set_userdata(mnt_fs *fs, void *data);
+extern const char *mnt_fs_get_source(mnt_fs *fs);
+extern int mnt_fs_set_source(mnt_fs *fs, const char *source);
+extern const char *mnt_fs_get_srcpath(mnt_fs *fs);
+extern int mnt_fs_get_tag(mnt_fs *fs, const char **name, const char **value);
+extern const char *mnt_fs_get_target(mnt_fs *fs);
+extern int mnt_fs_set_target(mnt_fs *fs, const char *target);
+extern const char *mnt_fs_get_fstype(mnt_fs *fs);
+extern int mnt_fs_set_fstype(mnt_fs *fs, const char *fstype);
+
+extern char *mnt_fs_strdup_options(mnt_fs *fs);
+extern int mnt_fs_set_options(mnt_fs *fs, const char *optstr);
+
+extern int mnt_fs_get_option(mnt_fs *fs, const char *name,
+				char **value, size_t *valsz);
+
+extern int mnt_fs_append_options(mnt_fs *fs, const char *optstr);
+extern int mnt_fs_prepend_options(mnt_fs *fs, const char *optstr);
+
+extern const char *mnt_fs_get_fs_options(mnt_fs *fs);
+extern int mnt_fs_set_fs_options(mnt_fs *fs, const char *optstr);
+extern int mnt_fs_append_fs_options(mnt_fs *fs, const char *optstr);
+extern int mnt_fs_prepend_fs_options(mnt_fs *fs, const char *optstr);
+
+extern const char *mnt_fs_get_vfs_options(mnt_fs *fs);
+extern int mnt_fs_set_vfs_options(mnt_fs *fs, const char *optstr);
+extern int mnt_fs_append_vfs_options(mnt_fs *fs, const char *optstr);
+extern int mnt_fs_prepend_vfs_options(mnt_fs *fs, const char *optstr);
+
+extern const char *mnt_fs_get_userspace_options(mnt_fs *fs);
+extern int mnt_fs_set_userspace_options(mnt_fs *fs, const char *optstr);
+extern int mnt_fs_append_userspace_options(mnt_fs *fs, const char *optstr);
+extern int mnt_fs_prepend_userspace_options(mnt_fs *fs, const char *optstr);
+
+extern const char *mnt_fs_get_attributes(mnt_fs *fs);
+extern int mnt_fs_set_attributes(mnt_fs *fs, const char *optstr);
+extern int mnt_fs_get_attribute(mnt_fs *fs, const char *name,
+				char **value, size_t *valsz);
+extern int mnt_fs_append_attributes(mnt_fs *fs, const char *optstr);
+extern int mnt_fs_prepend_attributes(mnt_fs *fs, const char *optstr);
+
+extern int mnt_fs_get_freq(mnt_fs *fs);
+extern int mnt_fs_set_freq(mnt_fs *fs, int freq);
+extern int mnt_fs_get_passno(mnt_fs *fs);
+extern int mnt_fs_set_passno(mnt_fs *fs, int passno);
+extern const char *mnt_fs_get_root(mnt_fs *fs);
+extern int mnt_fs_set_root(mnt_fs *fs, const char *root);
+extern const char *mnt_fs_get_bindsrc(mnt_fs *fs);
+extern int mnt_fs_set_bindsrc(mnt_fs *fs, const char *src);
+extern int mnt_fs_get_id(mnt_fs *fs);
+extern int mnt_fs_get_parent_id(mnt_fs *fs);
+extern dev_t mnt_fs_get_devno(mnt_fs *fs);
+
+extern int mnt_fs_match_target(mnt_fs *fs, const char *target, mnt_cache *cache);
+extern int mnt_fs_match_source(mnt_fs *fs, const char *source, mnt_cache *cache);
+extern int mnt_fs_match_fstype(mnt_fs *fs, const char *types);
+extern int mnt_fs_match_options(mnt_fs *fs, const char *options);
+extern int mnt_fs_print_debug(mnt_fs *fs, FILE *file);
+
+/* tab-parse.c */
+extern mnt_tab *mnt_new_tab_from_file(const char *filename);
+extern int mnt_tab_parse_stream(mnt_tab *tb, FILE *f, const char *filename);
+extern int mnt_tab_parse_file(mnt_tab *tb, const char *filename);
+extern int mnt_tab_parse_fstab(mnt_tab *tb, const char *filename);
+extern int mnt_tab_parse_mtab(mnt_tab *tb, const char *filename);
+extern int mnt_tab_set_parser_errcb(mnt_tab *tb,
+                int (*cb)(mnt_tab *tb, const char *filename, int line));
+
+/* tab.c */
+extern mnt_tab *mnt_new_tab(void);
+extern void mnt_free_tab(mnt_tab *tb);
+extern int mnt_tab_get_nents(mnt_tab *tb);
+extern int mnt_tab_set_cache(mnt_tab *tb, mnt_cache *mpc);
+extern mnt_cache *mnt_tab_get_cache(mnt_tab *tb);
+extern const char *mnt_tab_get_name(mnt_tab *tb);
+extern int mnt_tab_add_fs(mnt_tab *tb, mnt_fs *fs);
+extern int mnt_tab_remove_fs(mnt_tab *tb, mnt_fs *fs);
+extern int mnt_tab_next_fs(mnt_tab *tb, mnt_iter *itr, mnt_fs **fs);
+extern int mnt_tab_next_child_fs(mnt_tab *tb, mnt_iter *itr,
+	                        mnt_fs *parent, mnt_fs **chld);
+extern int mnt_tab_get_root_fs(mnt_tab *tb, mnt_fs **root);
+extern int mnt_tab_set_iter(mnt_tab *tb, mnt_iter *itr, mnt_fs *fs);
+
+extern mnt_fs *mnt_tab_find_target(mnt_tab *tb, const char *path, int direction);
+extern mnt_fs *mnt_tab_find_srcpath(mnt_tab *tb, const char *path, int direction);
+extern mnt_fs *mnt_tab_find_tag(mnt_tab *tb, const char *tag,
+				const char *val, int direction);
+extern mnt_fs *mnt_tab_find_source(mnt_tab *tb, const char *source, int direction);
+extern mnt_fs *mnt_tab_find_pair(mnt_tab *tb, const char *source,
+				const char *target, int direction);
+
+extern int mnt_tab_find_next_fs(mnt_tab *tb, mnt_iter *itr,
+			int (*match_func)(mnt_fs *, void *), void *userdata,
+		        mnt_fs **fs);
+
+/*
+ * mount(8) userspace options masks (MNT_MAP_USERSPACE map)
+ */
+#define MNT_MS_NOAUTO	(1 << 2)
+#define MNT_MS_USER	(1 << 3)
+#define MNT_MS_USERS	(1 << 4)
+#define MNT_MS_OWNER	(1 << 5)
+#define MNT_MS_GROUP	(1 << 6)
+#define MNT_MS_NETDEV	(1 << 7)
+#define MNT_MS_COMMENT  (1 << 8)
+#define MNT_MS_LOOP     (1 << 9)
+#define MNT_MS_NOFAIL   (1 << 10)
+#define MNT_MS_UHELPER  (1 << 11)
+
+/*
+ * mount(2) MS_* masks (MNT_MAP_LINUX map)
+ */
+#ifndef MS_RDONLY
+#define MS_RDONLY	 1	/* Mount read-only */
+#endif
+#ifndef MS_NOSUID
+#define MS_NOSUID	 2	/* Ignore suid and sgid bits */
+#endif
+#ifndef MS_NODEV
+#define MS_NODEV	 4	/* Disallow access to device special files */
+#endif
+#ifndef MS_NOEXEC
+#define MS_NOEXEC	 8	/* Disallow program execution */
+#endif
+#ifndef MS_SYNCHRONOUS
+#define MS_SYNCHRONOUS	16	/* Writes are synced at once */
+#endif
+#ifndef MS_REMOUNT
+#define MS_REMOUNT	32	/* Alter flags of a mounted FS */
+#endif
+#ifndef MS_MANDLOCK
+#define MS_MANDLOCK	64	/* Allow mandatory locks on an FS */
+#endif
+#ifndef MS_DIRSYNC
+#define MS_DIRSYNC	128	/* Directory modifications are synchronous */
+#endif
+#ifndef MS_NOATIME
+#define MS_NOATIME	0x400	/* 1024: Do not update access times. */
+#endif
+#ifndef MS_NODIRATIME
+#define MS_NODIRATIME   0x800	/* 2048: Don't update directory access times */
+#endif
+#ifndef MS_BIND
+#define	MS_BIND		0x1000	/* 4096: Mount existing tree also elsewhere */
+#endif
+#ifndef MS_MOVE
+#define MS_MOVE		0x2000	/* 8192: Atomically move tree */
+#endif
+#ifndef MS_REC
+#define MS_REC		0x4000	/* 16384: Recursive loopback */
+#endif
+#ifndef MS_VERBOSE
+#define MS_VERBOSE	0x8000	/* 32768 */
+#endif
+#ifndef MS_RELATIME
+#define MS_RELATIME	0x200000 /* 200000: Update access times relative
+                                  to mtime/ctime */
+#endif
+#ifndef MS_UNBINDABLE
+#define MS_UNBINDABLE	(1<<17)	/* 131072 unbindable*/
+#endif
+#ifndef MS_PRIVATE
+#define MS_PRIVATE	(1<<18)	/* 262144 Private*/
+#endif
+#ifndef MS_SLAVE
+#define MS_SLAVE	(1<<19)	/* 524288 Slave*/
+#endif
+#ifndef MS_SHARED
+#define MS_SHARED	(1<<20)	/* 1048576 Shared*/
+#endif
+#ifndef MS_I_VERSION
+#define MS_I_VERSION	(1<<23)	/* update inode I_version field */
+#endif
+#ifndef MS_STRICTATIME
+#define MS_STRICTATIME	(1<<24) /* strict atime semantics */
+#endif
+
+/*
+ * Magic mount flag number. Had to be or-ed to the flag values.
+ */
+#ifndef MS_MGC_VAL
+#define MS_MGC_VAL 0xC0ED0000	/* magic flag number to indicate "new" flags */
+#endif
+#ifndef MS_MGC_MSK
+#define MS_MGC_MSK 0xffff0000	/* magic flag number mask */
+#endif
+
+
+/* Shared-subtree options */
+#define MS_PROPAGATION  (MS_SHARED|MS_SLAVE|MS_UNBINDABLE|MS_PRIVATE)
+
+/* Options that we make ordinary users have by default.  */
+#define MS_SECURE	(MS_NOEXEC|MS_NOSUID|MS_NODEV)
+
+/* Options that we make owner-mounted devices have by default */
+#define MS_OWNERSECURE	(MS_NOSUID|MS_NODEV)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _LIBMOUNT_MOUNT_H */
diff -up util-linux-ng-2.17.2/shlibs/mount/src/mountP.h.kzak util-linux-ng-2.17.2/shlibs/mount/src/mountP.h
--- util-linux-ng-2.17.2/shlibs/mount/src/mountP.h.kzak	2012-10-08 12:51:49.138688901 +0200
+++ util-linux-ng-2.17.2/shlibs/mount/src/mountP.h	2012-10-08 12:51:49.138688901 +0200
@@ -0,0 +1,204 @@
+/*
+ * mountP.h - private library header file
+ *
+ * Copyright (C) 2008-2009 Karel Zak <kzak@redhat.com>
+ *
+ * This file may be redistributed under the terms of the
+ * GNU Lesser General Public License.
+ */
+
+#ifndef _LIBMOUNT_PRIVATE_H
+#define _LIBMOUNT_PRIVATE_H
+
+#include <sys/types.h>
+#include <errno.h>
+#include "c.h"
+
+#define USE_UNSTABLE_LIBMOUNT_API
+
+#include "mount.h"
+#include "list.h"
+
+/* features */
+#define CONFIG_LIBMOUNT_ASSERT
+#define CONFIG_LIBMOUNT_DEBUG
+
+#ifdef CONFIG_LIBMOUNT_ASSERT
+#include <assert.h>
+#endif
+
+/*
+ * Debug
+ */
+#if defined(TEST_PROGRAM) && !defined(LIBMOUNT_DEBUG)
+#define CONFIG_LIBMOUNT_DEBUG
+#endif
+
+#define MNT_DEBUG_INIT		(1 << 1)
+#define MNT_DEBUG_CACHE		(1 << 2)
+#define MNT_DEBUG_OPTIONS	(1 << 3)
+#define MNT_DEBUG_LOCKS		(1 << 4)
+#define MNT_DEBUG_TAB		(1 << 5)
+#define MNT_DEBUG_FS		(1 << 6)
+#define MNT_DEBUG_OPTS		(1 << 7)
+#define MNT_DEBUG_UPDATE	(1 << 8)
+#define MNT_DEBUG_UTILS		(1 << 9)
+#define MNT_DEBUG_CXT		(1 << 10)
+#define MNT_DEBUG_ALL		0xFFFF
+
+#ifdef CONFIG_LIBMOUNT_DEBUG
+# include <stdio.h>
+# include <stdarg.h>
+
+# define DBG(m,x)	do { \
+				if ((MNT_DEBUG_ ## m) & libmount_debug_mask) {\
+					fprintf(stderr, "libmount: %8s: ", # m); \
+					x; \
+				} \
+			} while(0)
+
+# define DBG_FLUSH	do { fflush(stderr); } while(0)
+
+extern int libmount_debug_mask;
+
+static inline void __attribute__ ((__format__ (__printf__, 1, 2)))
+mnt_debug(const char *mesg, ...)
+{
+	va_list ap;
+	va_start(ap, mesg);
+	vfprintf(stderr, mesg, ap);
+	va_end(ap);
+	fputc('\n', stderr);
+}
+
+static inline void __attribute__ ((__format__ (__printf__, 2, 3)))
+mnt_debug_h(void *handler, const char *mesg, ...)
+{
+	va_list ap;
+
+	fprintf(stderr, "[%p]: ", handler);
+	va_start(ap, mesg);
+	vfprintf(stderr, mesg, ap);
+	va_end(ap);
+	fputc('\n', stderr);
+}
+
+#else /* !CONFIG_LIBMOUNT_DEBUG */
+# define DBG(m,x) do { ; } while(0)
+# define DBG_FLUSH do { ; } while(0)
+#endif
+
+/* utils.c */
+extern int endswith(const char *s, const char *sx);
+extern int startswith(const char *s, const char *sx);
+
+/*
+ * Generic iterator
+ */
+struct _mnt_iter {
+        struct list_head        *p;		/* current position */
+        struct list_head        *head;		/* start position */
+	int			direction;	/* MNT_ITER_{FOR,BACK}WARD */
+};
+
+#define IS_ITER_FORWARD(_i)	((_i)->direction == MNT_ITER_FORWARD)
+#define IS_ITER_BACKWARD(_i)	((_i)->direction == MNT_ITER_BACKWARD)
+
+#define MNT_ITER_INIT(itr, list) \
+	do { \
+		(itr)->p = IS_ITER_FORWARD(itr) ? \
+				(list)->next : (list)->prev; \
+		(itr)->head = (list); \
+	} while(0)
+
+#define MNT_ITER_ITERATE(itr, res, restype, member) \
+	do { \
+		res = list_entry((itr)->p, restype, member); \
+		(itr)->p = IS_ITER_FORWARD(itr) ? \
+				(itr)->p->next : (itr)->p->prev; \
+	} while(0)
+
+
+/*
+ * This struct represents one entry in mtab/fstab/mountinfo file.
+ * (note that fstab[1] means the first column from fstab, and so on...)
+ */
+struct _mnt_fs {
+	struct list_head ents;
+
+	int		id;		/* mountinfo[1]: ID */
+	int		parent;		/* moutninfo[2]: parent */
+	dev_t		devno;		/* moutninfo[3]: st_dev */
+
+	char		*bindsrc;	/* utab, full path from fstab[1] for bind mounts */
+
+	char		*source;	/* fstab[1], mountinfo[10]:
+                                         * source dev, file, dir or TAG */
+	char		*tagname;	/* fstab[1]: tag name - "LABEL", "UUID", ..*/
+	char		*tagval;	/*           tag value */
+
+	char		*root;		/* mountinfo[4]: root of the mount within the FS */
+	char		*target;	/* mountinfo[5], fstab[2]: mountpoint */
+	char		*fstype;	/* mountinfo[9], fstab[3]: filesystem type */
+
+	char		*vfs_optstr;	/* mountinfo[6]: fs-independent (VFS) options */
+	char		*fs_optstr;	/* mountinfo[11]: fs-depend options */
+	char		*user_optstr;	/* userspace mount options */
+	char		*attrs;		/* mount attributes */
+
+	int		freq;		/* fstab[5]:  dump frequency in days */
+	int		passno;		/* fstab[6]: pass number on parallel fsck */
+
+	int		flags;		/* MNT_FS_* flags */
+
+	void		*userdata;	/* library independent data */
+};
+
+/*
+ * fs flags
+ */
+#define MNT_FS_PSEUDO	(1 << 1) /* pseudo filesystem */
+#define MNT_FS_NET	(1 << 2) /* network filesystem */
+#define MNT_FS_SWAP	(1 << 3) /* swap device */
+
+/*
+ * mtab/fstab/mountinfo file
+ */
+struct _mnt_tab {
+	int		fmt;		/* MNT_FMT_* file format */
+	int		nents;		/* number of valid entries */
+
+	mnt_cache	*cache;		/* canonicalized paths/tags cache */
+
+        int		(*errcb)(mnt_tab *tb, const char *filename, int line);
+
+	struct list_head	ents;	/* list of entries (mentry) */
+};
+
+extern mnt_tab *__mnt_new_tab_from_file(const char *filename, int fmt);
+
+/*
+ * Tab file format
+ */
+enum {
+	MNT_FMT_GUESS,
+	MNT_FMT_FSTAB,			/* /etc/{fs,m}tab */
+	MNT_FMT_MTAB = MNT_FMT_FSTAB,	/* alias */
+	MNT_FMT_MOUNTINFO,		/* /proc/#/mountinfo */
+};
+
+
+/* optmap.c */
+extern const struct mnt_optmap *mnt_optmap_get_entry(struct mnt_optmap const **maps,
+                             int nmaps, const char *name,
+                             size_t namelen, const struct mnt_optmap **mapent);
+
+/* optstr.c */
+extern int mnt_optstr_remove_option_at(char **optstr, char *begin, char *end);
+
+/* fs.c */
+extern mnt_fs *mnt_copy_mtab_fs(const mnt_fs *fs);
+extern int __mnt_fs_set_source_ptr(mnt_fs *fs, char *source);
+extern int __mnt_fs_set_fstype_ptr(mnt_fs *fs, char *fstype);
+
+#endif /* _LIBMOUNT_PRIVATE_H */
diff -up util-linux-ng-2.17.2/shlibs/mount/src/mount.sym.kzak util-linux-ng-2.17.2/shlibs/mount/src/mount.sym
--- util-linux-ng-2.17.2/shlibs/mount/src/mount.sym.kzak	2012-10-08 12:51:49.138688901 +0200
+++ util-linux-ng-2.17.2/shlibs/mount/src/mount.sym	2012-10-08 12:51:49.138688901 +0200
@@ -0,0 +1,118 @@
+/*
+ * The symbol versioning ensures that a new application requiring symbol foo;
+ * can't run with old libblkid.so not providing foo;
+ * version info can't enforce this since we never change the SONAME.
+ */
+MOUNT_2.19 {
+global:
+	mnt_cache_device_has_tag;
+	mnt_cache_find_tag_value;
+	mnt_cache_read_tags;
+	mnt_free_cache;
+	mnt_free_fs;
+	mnt_free_iter;
+	mnt_free_tab;
+	mnt_fs_append_attributes;
+	mnt_fs_append_fs_options;
+	mnt_fs_append_options;
+	mnt_fs_append_userspace_options;
+	mnt_fs_append_vfs_options;
+	mnt_fs_get_attribute;
+	mnt_fs_get_attributes;
+	mnt_fs_get_bindsrc;
+	mnt_fs_get_devno;
+	mnt_fs_get_freq;
+	mnt_fs_get_fs_options;
+	mnt_fs_get_fstype;
+	mnt_fs_get_id;
+	mnt_fs_get_option;
+	mnt_fs_get_parent_id;
+	mnt_fs_get_passno;
+	mnt_fs_get_root;
+	mnt_fs_get_source;
+	mnt_fs_get_srcpath;
+	mnt_fs_get_tag;
+	mnt_fs_get_target;
+	mnt_fs_get_userdata;
+	mnt_fs_get_userspace_options;
+	mnt_fs_get_vfs_options;
+	mnt_fs_match_fstype;
+	mnt_fs_match_options;
+	mnt_fs_match_source;
+	mnt_fs_match_target;
+	mnt_fs_prepend_attributes;
+	mnt_fs_prepend_fs_options;
+	mnt_fs_prepend_options;
+	mnt_fs_prepend_userspace_options;
+	mnt_fs_prepend_vfs_options;
+	mnt_fs_print_debug;
+	mnt_fs_set_attributes;
+	mnt_fs_set_bindsrc;
+	mnt_fs_set_freq;
+	mnt_fs_set_fs_options;
+	mnt_fs_set_fstype;
+	mnt_fs_set_options;
+	mnt_fs_set_passno;
+	mnt_fs_set_root;
+	mnt_fs_set_source;
+	mnt_fs_set_target;
+	mnt_fs_set_userdata;
+	mnt_fs_set_userspace_options;
+	mnt_fs_set_vfs_options;
+	mnt_fs_strdup_options;
+	mnt_fstype_is_netfs;
+	mnt_fstype_is_pseudofs;
+	mnt_get_fstab_path;
+	mnt_get_fstype;
+	mnt_get_mtab_path;
+	mnt_has_regular_mtab;
+	mnt_init_debug;
+	mnt_iter_get_direction;
+	mnt_match_fstype;
+	mnt_match_options;
+	mnt_new_cache;
+	mnt_new_context;
+	mnt_new_fs;
+	mnt_new_iter;
+	mnt_new_tab;
+	mnt_new_tab_from_file;
+	mnt_get_builtin_optmap;
+	mnt_optstr_append_option;
+	mnt_optstr_apply_flags;
+	mnt_optstr_get_flags;
+	mnt_optstr_get_option;
+	mnt_optstr_get_options;
+	mnt_optstr_next_option;
+	mnt_optstr_prepend_option;
+	mnt_optstr_remove_option;
+	mnt_optstr_set_option;
+	mnt_reset_iter;
+	mnt_resolve_path;
+	mnt_resolve_spec;
+	mnt_resolve_tag;
+	mnt_split_optstr;
+	mnt_tab_add_fs;
+	mnt_tab_find_next_fs;
+	mnt_tab_find_pair;
+	mnt_tab_find_source;
+	mnt_tab_find_srcpath;
+	mnt_tab_find_tag;
+	mnt_tab_find_target;
+	mnt_tab_get_cache;
+	mnt_tab_get_name;
+	mnt_tab_get_nents;
+	mnt_tab_get_root_fs;
+	mnt_tab_next_child_fs;
+	mnt_tab_next_fs;
+	mnt_tab_parse_file;
+	mnt_tab_parse_fstab;
+	mnt_tab_parse_mtab;
+	mnt_tab_parse_stream;
+	mnt_tab_remove_fs;
+	mnt_tab_set_cache;
+	mnt_tab_set_iter;
+	mnt_tab_set_parser_errcb;
+local:
+	*;
+};
+
diff -up util-linux-ng-2.17.2/shlibs/mount/src/optmap.c.kzak util-linux-ng-2.17.2/shlibs/mount/src/optmap.c
--- util-linux-ng-2.17.2/shlibs/mount/src/optmap.c.kzak	2012-10-08 12:51:49.139688907 +0200
+++ util-linux-ng-2.17.2/shlibs/mount/src/optmap.c	2012-10-08 12:51:49.139688907 +0200
@@ -0,0 +1,223 @@
+/*
+ * Copyright (C) 2010 Karel Zak <kzak@redhat.com>
+ *
+ * This file may be redistributed under the terms of the
+ * GNU Lesser General Public License.
+ */
+
+/**
+ * SECTION: optmap
+ * @title: Option maps
+ * @short_description: description for mount options
+ *
+ * The mount(2) linux syscall uses two arguments for mount options:
+ *
+ *	@mountflags: (see MS_* macros in linux/fs.h)
+ *
+ *	@mountdata: (usully a comma separated string of options)
+ *
+ * The libmount uses options-map(s) to describe mount options.
+ *
+ * The option description (map entry) includes:
+ *
+ *	@name: and argument name
+ *
+ *	@id: (in the map unique identifier or a mountflags, e.g MS_RDONLY)
+ *
+ *	@mask: (MNT_INVERT, MNT_NOMTAB)
+ *
+ * The option argument value is defined by:
+ *
+ *	"="   -- required argument, e.g "comment="
+ *
+ *	"[=]" -- optional argument, e.g. "loop[=]"
+ *
+ * Example:
+ *
+ * <informalexample>
+ *   <programlisting>
+ *     #define MY_MS_FOO   (1 << 1)
+ *     #define MY_MS_BAR   (1 << 2)
+ *
+ *     mnt_optmap myoptions[] = {
+ *       { "foo",   MY_MS_FOO },
+ *       { "nofoo", MY_MS_FOO | MNT_INVERT },
+ *       { "bar=",  MY_MS_BAR },
+ *       { NULL }
+ *     };
+ *   </programlisting>
+ * </informalexample>
+ *
+ * The libmount defines two basic built-in options maps:
+ *
+ *	@MNT_LINUX_MAP: fs-independent kernel mount options (usually MS_* flags)
+ *
+ *	@MNT_USERSPACE_MAP: userspace specific mount options (e.g. "user", "loop")
+ *
+ * For more details about option map struct see "struct mnt_optmap" in
+ * mount/mount.h.
+ */
+#include <string.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <errno.h>
+
+#include "nls.h"
+#include "mountP.h"
+
+/*
+ * fs-independent mount flags (built-in MNT_LINUX_MAP)
+ */
+static const struct mnt_optmap linux_flags_map[] =
+{
+   { "ro",       MS_RDONLY },                 /* read-only */
+   { "rw",       MS_RDONLY, MNT_INVERT },     /* read-write */
+   { "exec",     MS_NOEXEC, MNT_INVERT },     /* permit execution of binaries */
+   { "noexec",   MS_NOEXEC },                 /* don't execute binaries */
+   { "suid",     MS_NOSUID, MNT_INVERT },     /* honor suid executables */
+   { "nosuid",   MS_NOSUID },                 /* don't honor suid executables */
+   { "dev",      MS_NODEV, MNT_INVERT },      /* interpret device files  */
+   { "nodev",    MS_NODEV },                  /* don't interpret devices */
+
+   { "sync",     MS_SYNCHRONOUS },            /* synchronous I/O */
+   { "async",    MS_SYNCHRONOUS, MNT_INVERT },/* asynchronous I/O */
+
+   { "dirsync",  MS_DIRSYNC },                /* synchronous directory modifications */
+   { "remount",  MS_REMOUNT, MNT_NOMTAB },    /* alter flags of mounted FS */
+   { "bind",     MS_BIND },                   /* Remount part of tree elsewhere */
+   { "rbind",    MS_BIND | MS_REC },          /* Idem, plus mounted subtrees */
+#ifdef MS_NOSUB
+   { "sub",      MS_NOSUB, MNT_INVERT },      /* allow submounts */
+   { "nosub",    MS_NOSUB },                  /* don't allow submounts */
+#endif
+#ifdef MS_SILENT
+   { "quiet",	 MS_SILENT },                 /* be quiet  */
+   { "loud",     MS_SILENT, MNT_INVERT },     /* print out messages. */
+#endif
+#ifdef MS_MANDLOCK
+   { "mand",     MS_MANDLOCK },               /* Allow mandatory locks on this FS */
+   { "nomand",   MS_MANDLOCK, MNT_INVERT },   /* Forbid mandatory locks on this FS */
+#endif
+#ifdef MS_NOATIME
+   { "atime",    MS_NOATIME, MNT_INVERT },    /* Update access time */
+   { "noatime",	 MS_NOATIME },                /* Do not update access time */
+#endif
+#ifdef MS_I_VERSION
+   { "iversion", MS_I_VERSION },              /* Update inode I_version time */
+   { "noiversion", MS_I_VERSION,  MNT_INVERT},/* Don't update inode I_version time */
+#endif
+#ifdef MS_NODIRATIME
+   { "diratime", MS_NODIRATIME, MNT_INVERT }, /* Update dir access times */
+   { "nodiratime", MS_NODIRATIME },           /* Do not update dir access times */
+#endif
+#ifdef MS_RELATIME
+   { "relatime", MS_RELATIME },               /* Update access times relative to mtime/ctime */
+   { "norelatime", MS_RELATIME, MNT_INVERT }, /* Update access time without regard to mtime/ctime */
+#endif
+#ifdef MS_STRICTATIME
+   { "strictatime", MS_STRICTATIME },         /* Strict atime semantics */
+   { "nostrictatime", MS_STRICTATIME, MNT_INVERT }, /* kernel default atime */
+#endif
+   { NULL, 0, 0 }
+};
+
+/*
+ * userspace mount option (built-in MNT_USERSPACE_MAP)
+ *
+ * TODO: offset=, sizelimit=, encryption=, vfs=
+ */
+static const struct mnt_optmap userspace_opts_map[] =
+{
+   { "defaults", 0, 0 },               /* default options */
+
+   { "auto",    MNT_MS_NOAUTO, MNT_INVERT | MNT_NOMTAB },  /* Can be mounted using -a */
+   { "noauto",  MNT_MS_NOAUTO, MNT_NOMTAB },               /* Can  only be mounted explicitly */
+
+   { "user[=]", MNT_MS_USER },                           /* Allow ordinary user to mount (mtab) */
+   { "nouser",  MNT_MS_USER, MNT_INVERT | MNT_NOMTAB },    /* Forbid ordinary user to mount */
+
+   { "users",   MNT_MS_USERS, MNT_NOMTAB },                /* Allow ordinary users to mount */
+   { "nousers", MNT_MS_USERS, MNT_INVERT | MNT_NOMTAB },   /* Forbid ordinary users to mount */
+
+   { "owner",   MNT_MS_OWNER, MNT_NOMTAB },                /* Let the owner of the device mount */
+   { "noowner", MNT_MS_OWNER, MNT_INVERT | MNT_NOMTAB },   /* Device owner has no special privs */
+
+   { "group",   MNT_MS_GROUP, MNT_NOMTAB },                /* Let the group of the device mount */
+   { "nogroup", MNT_MS_GROUP, MNT_INVERT | MNT_NOMTAB },   /* Device group has no special privs */
+
+   { "_netdev", MNT_MS_NETDEV },                           /* Device requires network */
+
+   { "comment=", MNT_MS_COMMENT, MNT_NOMTAB },           /* fstab comment only */
+
+   { "loop[=]", MNT_MS_LOOP },                           /* use the loop device */
+
+   { "nofail",  MNT_MS_NOFAIL, MNT_NOMTAB },               /* Do not fail if ENOENT on dev */
+
+   { "uhelper=", MNT_MS_UHELPER },			   /* /sbin/umount.<helper> */
+
+   { NULL, 0, 0 }
+};
+
+/**
+ * mnt_get_builtin_map:
+ * @id: map id -- MNT_LINUX_MAP or MNT_USERSPACE_MAP
+ *
+ * MNT_LINUX_MAP - Linux kernel fs-independent mount options
+ *                 (usually MS_* flags, see linux/fs.h)
+ *
+ * MNT_USERSPACE_MAP - userpace mount(8) specific mount options
+ *                     (e.g user=, _netdev, ...)
+ *
+ * Returns: static built-in libmount map.
+ */
+const struct mnt_optmap *mnt_get_builtin_optmap(int id)
+{
+	assert(id);
+
+	if (id == MNT_LINUX_MAP)
+		return linux_flags_map;
+	else if (id == MNT_USERSPACE_MAP)
+		return userspace_opts_map;
+	return NULL;
+}
+
+/*
+ * Lookups for the @name in @maps and returns a map and in @mapent
+ * returns the map entry
+ */
+const struct mnt_optmap *mnt_optmap_get_entry(
+				struct mnt_optmap const **maps,
+				int nmaps,
+				const char *name,
+				size_t namelen,
+				const struct mnt_optmap **mapent)
+{
+	int i;
+
+	assert(maps);
+	assert(nmaps);
+	assert(name);
+	assert(namelen);
+
+	if (mapent)
+		*mapent = NULL;
+
+	for (i = 0; i < nmaps; i++) {
+		const struct mnt_optmap *map = maps[i];
+		const struct mnt_optmap *ent;
+		const char *p;
+
+		for (ent = map; ent && ent->name; ent++) {
+			if (strncmp(ent->name, name, namelen))
+				continue;
+			p = ent->name + namelen;
+			if (*p == '\0' || *p == '=' || *p == '[') {
+				if (mapent)
+					*mapent = ent;
+				return map;
+			}
+		}
+	}
+	return NULL;
+}
+
diff -up util-linux-ng-2.17.2/shlibs/mount/src/optstr.c.kzak util-linux-ng-2.17.2/shlibs/mount/src/optstr.c
--- util-linux-ng-2.17.2/shlibs/mount/src/optstr.c.kzak	2012-10-08 12:51:49.140688913 +0200
+++ util-linux-ng-2.17.2/shlibs/mount/src/optstr.c	2012-10-08 12:51:49.140688913 +0200
@@ -0,0 +1,563 @@
+/*
+ * Copyright (C) 2008-2009 Karel Zak <kzak@redhat.com>
+ *
+ * This file may be redistributed under the terms of the
+ * GNU Lesser General Public License.
+ */
+
+/**
+ * SECTION: optstr
+ * @title: Options string
+ * @short_description: low-level API for work with mount options
+ *
+ * This is simple and low-level API to work with mount options that are stored
+ * in string. This API is independent on the high-level options container and
+ * option maps.
+ */
+
+#include <string.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+#ifdef HAVE_LIBSELINUX
+#include <selinux/selinux.h>
+#include <selinux/context.h>
+#endif
+
+#include "nls.h"
+#include "mountP.h"
+
+/*
+ * Option location
+ */
+struct mnt_optloc {
+	char	*begin;
+	char	*end;
+	char	*value;
+	size_t	valsz;
+	size_t  namesz;
+};
+
+#define mnt_init_optloc(_ol)	(memset((_ol), 0, sizeof(struct mnt_optloc)))
+
+/*
+ * Parses the first option from @optstr. The @optstr pointer is set to begin of
+ * the next option.
+ *
+ * Returns -EINVAL on parse error, 1 at the end of optstr and 0 on success.
+ */
+static int mnt_optstr_parse_next(char **optstr,	 char **name, size_t *namesz,
+					char **value, size_t *valsz)
+{
+	int open_quote = 0;
+	char *start = NULL, *stop = NULL, *p, *sep = NULL;
+	char *optstr0;
+
+	assert(optstr);
+	assert(*optstr);
+
+	optstr0 = *optstr;
+
+	if (name)
+		*name = NULL;
+	if (namesz)
+		*namesz = 0;
+	if (value)
+		*value = NULL;
+	if (valsz)
+		*valsz = 0;
+
+	for (p = optstr0; p && *p; p++) {
+		if (!start)
+			start = p;		/* begin of the option item */
+		if (*p == '"')
+			open_quote ^= 1;	/* reverse the status */
+		if (open_quote)
+			continue;		/* still in quoted block */
+		if (!sep && *p == '=')
+			sep = p;		/* name and value separator */
+		if (*p == ',')
+			stop = p;		/* terminate the option item */
+		else if (*(p + 1) == '\0')
+			stop = p + 1;		/* end of optstr */
+		if (!start || !stop)
+			continue;
+		if (stop <= start)
+			goto error;
+
+		if (name)
+			*name = start;
+		if (namesz)
+			*namesz = sep ? sep - start : stop - start;
+		*optstr = *stop ? stop + 1 : stop;
+
+		if (sep) {
+			if (value)
+				*value = sep + 1;
+			if (valsz)
+				*valsz = stop - sep - 1;
+		}
+		return 0;
+	}
+
+	return 1;				/* end of optstr */
+
+error:
+	DBG(OPTIONS, mnt_debug("parse error: \"%s\"", optstr0));
+	return -EINVAL;
+}
+
+/*
+ * Locates the first option that match with @name. The @end is set to
+ * char behind the option (it means ',' or \0).
+ *
+ * Returns negative number on parse error, 1 when not found and 0 on success.
+ */
+static int mnt_optstr_locate_option(char *optstr, const char *name,
+					struct mnt_optloc *ol)
+{
+	char *n;
+	size_t namesz, nsz;
+	int rc;
+
+	if (!optstr)
+		return 1;
+
+	assert(name);
+	assert(optstr);
+
+	namesz = strlen(name);
+
+	do {
+		rc = mnt_optstr_parse_next(&optstr, &n, &nsz,
+					&ol->value, &ol->valsz);
+		if (rc)
+			break;
+
+		if (namesz == nsz && strncmp(n, name, nsz) == 0) {
+			ol->begin = n;
+			ol->end = *(optstr - 1) == ',' ? optstr - 1 : optstr;
+			ol->namesz = nsz;
+			return 0;
+		}
+	} while(1);
+
+	return rc;
+}
+
+/**
+ * mnt_optstr_next_option:
+ * @optstr: option string, returns position to next option
+ * @name: returns option name
+ * @namesz: returns option name length
+ * @value: returns option value or NULL
+ * @valuesz: returns option value length or zero
+ *
+ * Parses the first option in @optstr.
+ *
+ * Returns: 0 on success, 1 at the end of @optstr or negative number in case of
+ * error.
+ */
+int mnt_optstr_next_option(char **optstr, char **name, size_t *namesz,
+					char **value, size_t *valuesz)
+{
+	if (!optstr || !*optstr)
+		return -EINVAL;
+	return mnt_optstr_parse_next(optstr, name, namesz, value, valuesz);
+}
+
+static int __mnt_optstr_append_option(char **optstr,
+			const char *name, size_t nsz,
+			const char *value, size_t vsz)
+{
+	char *p;
+	size_t sz, osz;
+
+	assert(name);
+
+	osz = *optstr ? strlen(*optstr) : 0;
+
+	sz = osz + nsz + 1;		/* 1: '\0' */
+	if (osz)
+		sz++;			/* ',' options separator */
+	if (vsz)
+		sz += vsz + 1;		/* 1: '=' */
+
+	p = realloc(*optstr, sz);
+	if (!p)
+		return -ENOMEM;
+	*optstr = p;
+
+	if (osz) {
+		p += osz;
+		*p++ = ',';
+	}
+
+	memcpy(p, name, nsz);
+	p += nsz;
+
+	if (vsz) {
+		*p++ = '=';
+		memcpy(p, value, vsz);
+		p += vsz;
+	}
+	*p = '\0';
+
+	return 0;
+}
+
+/**
+ * mnt_optstr_append_option:
+ * @optstr: option string or NULL, returns reallocated string
+ * @name: value name
+ * @value: value
+ *
+ * Returns: 0 on success or -1 in case of error. After error the @optstr should
+ *          be unmodified.
+ */
+int mnt_optstr_append_option(char **optstr, const char *name, const char *value)
+{
+	size_t vsz, nsz;
+
+	if (!name)
+		return 0;
+
+	nsz = strlen(name);
+	vsz = value ? strlen(value) : 0;
+
+	return __mnt_optstr_append_option(optstr, name, nsz, value, vsz);
+}
+
+/**
+ * mnt_optstr_prepend_option:
+ * @optstr: option string or NULL, returns reallocated string
+ * @name: value name
+ * @value: value
+ *
+ * Returns: 0 on success or -1 in case of error. After error the @optstr should
+ *          be unmodified.
+ */
+int mnt_optstr_prepend_option(char **optstr, const char *name, const char *value)
+{
+	int rc = 0;
+	char *tmp = *optstr;
+
+	*optstr = NULL;
+
+	rc = mnt_optstr_append_option(optstr, name, value);
+	if (!rc && tmp && *tmp)
+		rc = mnt_optstr_append_option(optstr, tmp, NULL);
+	if (!rc) {
+		free(tmp);
+		return 0;
+	}
+
+	free(*optstr);
+	*optstr = tmp;
+
+	DBG(OPTIONS, mnt_debug("failed to prepend '%s[=%s]' to '%s'",
+				name, value, *optstr));
+	return rc;
+}
+
+/**
+ * mnt_optstr_get_option:
+ * @optstr: string with comma separated list of options
+ * @name: requested option name
+ * @value: returns pointer to the begin of the value (e.g. name=VALUE) or NULL
+ * @valsz: returns size of the value or 0
+ *
+ * Returns: 0 on success, 1 when not found the @name or negative number in case
+ * of error.
+ */
+int mnt_optstr_get_option(char *optstr, const char *name,
+				char **value, size_t *valsz)
+{
+	struct mnt_optloc ol;
+	int rc;
+
+	mnt_init_optloc(&ol);
+
+	rc = mnt_optstr_locate_option(optstr, name, &ol);
+	if (!rc) {
+		if (value)
+			*value = ol.value;
+		if (valsz)
+			*valsz = ol.valsz;
+	}
+	return rc;
+}
+
+/*
+ * The result never starts or ends with comma or contains two commas
+ *    (e.g. ",aaa,bbb" or "aaa,,bbb" or "aaa,")
+ */
+int mnt_optstr_remove_option_at(char **optstr, char *begin, char *end)
+{
+	size_t sz;
+
+	if (!optstr || !begin || !end)
+		return -EINVAL;
+
+	if ((begin == *optstr || *(begin - 1) == ',') && *end == ',')
+		end++;
+
+	sz = strlen(end);
+
+	memmove(begin, end, sz + 1);
+	if (!*begin && *(begin - 1) == ',')
+		*(begin - 1) = '\0';
+
+	return 0;
+}
+
+/* insert 'substr' or '=substr' to @str on position @pos */
+static int insert_value(char **str, char *pos, const char *substr, char **next)
+{
+	size_t subsz = strlen(substr);			/* substring size */
+	size_t strsz = strlen(*str);
+	size_t possz = strlen(pos);
+	size_t posoff;
+	char *p = NULL;
+	int sep;
+
+	/* is it necessary to prepend '=' before the substring ? */
+	sep = !(pos > *str && *(pos - 1) == '=');
+
+	/* save an offset of the place where we need add substr */
+	posoff = pos - *str;
+
+	p = realloc(*str, strsz + sep + subsz + 1);
+	if (!p)
+		return -ENOMEM;
+
+	/* zeroize new allocated memory -- valgind loves is... */
+	memset(p + strsz, 0, sep + subsz + 1);
+
+	/* set pointers to the reallocated string */
+	*str = p;
+	pos = p + posoff;
+
+	if (possz)
+		/* create a room for new substring */
+		memmove(pos + subsz + sep, pos, possz + 1);
+	if (sep)
+		*pos++ = '=';
+
+	memcpy(pos, substr, subsz);
+
+	if (next) {
+		/* set pointer to the next option */
+		*next = pos + subsz + sep + 1;
+		if (**next == ',')
+			(*next)++;
+	}
+	return 0;
+}
+
+/**
+ * mnt_optstr_set_option:
+ * @optstr: string with comma separated list of options
+ * @name: requested option
+ * @value: new value or NULL
+ *
+ * Set or unset option @value.
+ *
+ * Returns: 0 on success, 1 when not found the @name or negative number in case
+ * of error.
+ */
+int mnt_optstr_set_option(char **optstr, const char *name, const char *value)
+{
+	struct mnt_optloc ol;
+	char *nameend;
+	int rc = 1;
+
+	if (!optstr)
+		return -EINVAL;
+
+	mnt_init_optloc(&ol);
+
+	if (*optstr)
+		rc = mnt_optstr_locate_option(*optstr, name, &ol);
+	if (rc < 0)
+		return rc;			/* parse error */
+	if (rc == 1)
+		return mnt_optstr_append_option(optstr, name, value);	/* not found */
+
+	nameend = ol.begin + ol.namesz;
+
+	if (value == NULL && ol.value && ol.valsz)
+		/* remove unwanted "=value" */
+		mnt_optstr_remove_option_at(optstr, nameend, ol.end);
+
+	else if (value && ol.value == NULL)
+		/* insert "=value" */
+		rc = insert_value(optstr, nameend, value, NULL);
+
+	else if (value && ol.value && strlen(value) == ol.valsz)
+		/* simply replace =value */
+		memcpy(ol.value, value, ol.valsz);
+
+	else if (value && ol.value) {
+		mnt_optstr_remove_option_at(optstr, nameend, ol.end);
+		rc = insert_value(optstr, nameend, value, NULL);
+	}
+	return rc;
+}
+
+/**
+ * mnt_optstr_remove_option:
+ * @optstr: string with comma separated list of options
+ * @name: requested option name
+ *
+ * Returns: 0 on success, 1 when not found the @name or negative number in case
+ * of error.
+ */
+int mnt_optstr_remove_option(char **optstr, const char *name)
+{
+	struct mnt_optloc ol;
+	int rc;
+
+	mnt_init_optloc(&ol);
+
+	rc = mnt_optstr_locate_option(*optstr, name, &ol);
+	if (rc != 0)
+		return rc;
+
+	mnt_optstr_remove_option_at(optstr, ol.begin, ol.end);
+	return 0;
+}
+
+/**
+ * mnt_split_optstr:
+ * @optstr: string with comma separated list of options
+ * @user: returns newly allocated string with userspace options
+ * @vfs: returns newly allocated string with VFS options
+ * @fs: returns newly allocated string with FS options
+ * @ignore_user: option mask for options that should be ignored
+ * @ignore_vfs: option mask for options that should be ignored
+ *
+ * For example:
+ *
+ *	mnt_split_optstr(optstr, &u, NULL, NULL, MNT_NOMTAB, 0);
+ *
+ * returns all userspace options, the options that does not belong to
+ * mtab are ignored.
+ *
+ * Note that FS options are all options that are undefined in MNT_USERSPACE_MAP
+ * or MNT_LINUX_MAP.
+ *
+ * Returns: 0 on success, or negative number in case of error.
+ */
+int mnt_split_optstr(const char *optstr, char **user, char **vfs, char **fs, int ignore_user, int ignore_vfs)
+{
+	char *name, *val, *str = (char *) optstr;
+	size_t namesz, valsz;
+	struct mnt_optmap const *maps[2];
+
+	assert(optstr);
+
+	if (!optstr)
+		return -EINVAL;
+
+	maps[0] = mnt_get_builtin_optmap(MNT_LINUX_MAP);
+	maps[1] = mnt_get_builtin_optmap(MNT_USERSPACE_MAP);
+
+	if (vfs)
+		*vfs = NULL;
+	if (fs)
+		*fs = NULL;
+	if (user)
+		*user = NULL;
+
+	while(!mnt_optstr_next_option(&str, &name, &namesz, &val, &valsz)) {
+		int rc = 0;
+		const struct mnt_optmap *ent;
+		const struct mnt_optmap *m =
+			 mnt_optmap_get_entry(maps, 2, name, namesz, &ent);
+
+		if (ent && !ent->id)
+			continue;	/* ignore undefined options (comments) */
+
+		if (m && m == maps[0] && vfs) {
+			if (ignore_vfs && (ent->mask & ignore_vfs))
+				continue;
+			rc = __mnt_optstr_append_option(vfs, name, namesz,
+								val, valsz);
+		} else if (m && m == maps[1] && user) {
+			if (ignore_user && (ent->mask & ignore_user))
+				continue;
+			rc = __mnt_optstr_append_option(user, name, namesz,
+								val, valsz);
+		} else if (!m && fs)
+			rc = __mnt_optstr_append_option(fs, name, namesz,
+								val, valsz);
+		if (rc) {
+			if (vfs)
+				free(*vfs);
+			if (fs)
+				free(*fs);
+			if (user)
+				free(*user);
+			return rc;
+		}
+	}
+
+	return 0;
+}
+
+/**
+ * mnt_optstr_get_options
+ * @optstr: string with comma separated list of options
+ * @subset: returns newly allocated string with options
+ * @map: options map
+ * @ignore: mask of the options that should be ignored
+ *
+ * Extracts options from @optstr that belongs to the @map, for example:
+ *
+ *	 mnt_split_optstr_by_map(optstr, &p,
+ *			mnt_get_builtin_optmap(MNT_LINUX_MAP),
+ *			MNT_NOMTAB);
+ *
+ * returns all VFS options, the options that does not belong to mtab
+ * are ignored.
+ *
+ * Returns: 0 on success, or negative number in case of error.
+ */
+int mnt_optstr_get_options(const char *optstr, char **subset,
+			    const struct mnt_optmap *map, int ignore)
+{
+	struct mnt_optmap const *maps[1];
+	char *name, *val, *str = (char *) optstr;
+	size_t namesz, valsz;
+
+	if (!optstr || !subset)
+		return -EINVAL;
+
+	maps[0] = map;
+	*subset = NULL;
+
+	while(!mnt_optstr_next_option(&str, &name, &namesz, &val, &valsz)) {
+		int rc = 0;
+		const struct mnt_optmap *ent;
+
+		mnt_optmap_get_entry(maps, 1, name, namesz, &ent);
+
+		if (!ent || !ent->id)
+			continue;	/* ignore undefined options (comments) */
+
+		if (ignore && (ent->mask & ignore))
+			continue;
+		rc = __mnt_optstr_append_option(subset, name, namesz, val, valsz);
+		if (rc) {
+			free(*subset);
+			return rc;
+		}
+	}
+
+	return 0;
+}
+
diff -up util-linux-ng-2.17.2/shlibs/mount/src/tab.c.kzak util-linux-ng-2.17.2/shlibs/mount/src/tab.c
--- util-linux-ng-2.17.2/shlibs/mount/src/tab.c.kzak	2012-10-08 12:51:49.141688919 +0200
+++ util-linux-ng-2.17.2/shlibs/mount/src/tab.c	2012-10-08 12:51:49.141688919 +0200
@@ -0,0 +1,693 @@
+/*
+ * Copyright (C) 2008-2010 Karel Zak <kzak@redhat.com>
+ *
+ * This file may be redistributed under the terms of the
+ * GNU Lesser General Public License.
+ */
+
+/**
+ * SECTION: tab
+ * @title: Table of filesystems
+ * @short_description: container for entries from fstab/mtab/mountinfo
+ *
+ *
+ * Note that mnt_tab_find_* functions are mount(8) compatible. These functions
+ * try to found an entry in more iterations where the first attempt is always
+ * based on comparison with unmodified (non-canonicalized or un-evaluated)
+ * paths or tags. For example fstab with two entries:
+ * <informalexample>
+ *   <programlisting>
+ *	LABEL=foo	/foo	auto   rw
+ *	/dev/foo	/foo	auto   rw
+ *  </programlisting>
+ * </informalexample>
+ *
+ * where both lines are used for the *same* device, then
+ * <informalexample>
+ *  <programlisting>
+ *	mnt_tab_find_source(tb, "/dev/foo", &fs);
+ *  </programlisting>
+ * </informalexample>
+ * will returns the second line, and
+ * <informalexample>
+ *  <programlisting>
+ *	mnt_tab_find_source(tb, "LABEL=foo", &fs);
+ *  </programlisting>
+ * </informalexample>
+ * will returns the first entry, and
+ * <informalexample>
+ *  <programlisting>
+ *	mnt_tab_find_source(tb, "UUID=anyuuid", &fs);
+ *  </programlisting>
+ * </informalexample>
+ * will returns the first entry (if UUID matches with the device).
+ */
+
+#include <string.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <errno.h>
+#include <limits.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <blkid.h>
+
+#include "nls.h"
+#include "mountP.h"
+#include "c.h"
+
+/**
+ * mnt_new_tab:
+ *
+ * The tab is a container for mnt_fs entries that usually represents a fstab,
+ * mtab or mountinfo file from your system.
+ *
+ * See also mnt_tab_parse_file().
+ *
+ * Returns: newly allocated tab struct.
+ */
+mnt_tab *mnt_new_tab(void)
+{
+	mnt_tab *tb = NULL;
+
+	tb = calloc(1, sizeof(struct _mnt_tab));
+	if (!tb)
+		return NULL;
+
+	DBG(TAB, mnt_debug_h(tb, "alloc"));
+
+	INIT_LIST_HEAD(&tb->ents);
+	return tb;
+}
+
+/**
+ * mnt_free_tab:
+ * @tb: tab pointer
+ *
+ * Deallocates tab struct and all entries.
+ */
+void mnt_free_tab(mnt_tab *tb)
+{
+	if (!tb)
+		return;
+
+	DBG(TAB, mnt_debug_h(tb, "free"));
+
+	while (!list_empty(&tb->ents)) {
+		mnt_fs *fs = list_entry(tb->ents.next, mnt_fs, ents);
+		mnt_free_fs(fs);
+	}
+
+	free(tb);
+}
+
+/**
+ * mnt_tab_get_nents:
+ * @tb: pointer to tab
+ *
+ * Returns: number of valid entries in tab.
+ */
+int mnt_tab_get_nents(mnt_tab *tb)
+{
+	assert(tb);
+	return tb ? tb->nents : 0;
+}
+
+/**
+ * mnt_tab_set_cache:
+ * @tb: pointer to tab
+ * @mpc: pointer to mnt_cache instance
+ *
+ * Setups a cache for canonicalized paths and evaluated tags (LABEL/UUID). The
+ * cache is recommended for mnt_tab_find_*() functions.
+ *
+ * The cache could be shared between more tabs. Be careful when you share the
+ * same cache between more threads -- currently the cache does not provide any
+ * locking method.
+ *
+ * See also mnt_new_cache().
+ *
+ * Returns: 0 on success or negative number in case of error.
+ */
+int mnt_tab_set_cache(mnt_tab *tb, mnt_cache *mpc)
+{
+	assert(tb);
+	if (!tb)
+		return -EINVAL;
+	tb->cache = mpc;
+	return 0;
+}
+
+/**
+ * mnt_tab_get_cache:
+ * @tb: pointer to tab
+ *
+ * Returns: pointer to mnt_cache instance or NULL.
+ */
+mnt_cache *mnt_tab_get_cache(mnt_tab *tb)
+{
+	assert(tb);
+	return tb ? tb->cache : NULL;
+}
+
+/**
+ * mnt_tab_add_fs:
+ * @tb: tab pointer
+ * @fs: new entry
+ *
+ * Adds a new entry to tab.
+ *
+ * Returns: 0 on success or negative number in case of error.
+ */
+int mnt_tab_add_fs(mnt_tab *tb, mnt_fs *fs)
+{
+	assert(tb);
+	assert(fs);
+
+	if (!tb || !fs)
+		return -EINVAL;
+
+	list_add_tail(&fs->ents, &tb->ents);
+
+	DBG(TAB, mnt_debug_h(tb, "add entry: %s %s",
+			mnt_fs_get_source(fs), mnt_fs_get_target(fs)));
+	tb->nents++;
+	return 0;
+}
+
+/**
+ * mnt_tab_remove_fs:
+ * @tb: tab pointer
+ * @fs: new entry
+ *
+ * Returns: 0 on success or negative number in case of error.
+ */
+int mnt_tab_remove_fs(mnt_tab *tb, mnt_fs *fs)
+{
+	assert(tb);
+	assert(fs);
+
+	if (!tb || !fs)
+		return -EINVAL;
+	list_del(&fs->ents);
+	tb->nents--;
+	return 0;
+}
+
+/**
+ * mnt_tab_get_root_fs:
+ * @tb: mountinfo file (/proc/self/mountinfo)
+ * @root: returns pointer to the root filesystem (/)
+ *
+ * Returns: 0 on success or -1 case of error.
+ */
+int mnt_tab_get_root_fs(mnt_tab *tb, mnt_fs **root)
+{
+	mnt_iter itr;
+	mnt_fs *fs;
+	int root_id = 0;
+
+	assert(tb);
+	assert(root);
+
+	if (!tb || !root)
+		return -EINVAL;
+
+	DBG(TAB, mnt_debug_h(tb, "lookup root fs"));
+
+	mnt_reset_iter(&itr, MNT_ITER_FORWARD);
+	while(mnt_tab_next_fs(tb, &itr, &fs) == 0) {
+		int id = mnt_fs_get_parent_id(fs);
+		if (!id)
+			break;		/* @tab is not mountinfo file? */
+
+		if (!*root || id < root_id) {
+			*root = fs;
+			root_id = id;
+		}
+	}
+
+	return root_id ? 0 : -EINVAL;
+}
+
+/**
+ * mnt_tab_next_child_fs:
+ * @tb: mountinfo file (/proc/self/mountinfo)
+ * @itr: iterator
+ * @parent: parental FS
+ * @chld: returns the next child filesystem
+ *
+ * Note that filesystems are returned in the order how was mounted (according to
+ * IDs in /proc/self/mountinfo).
+ *
+ * Returns: 0 on success, negative number in case of error or 1 at end of list.
+ */
+int mnt_tab_next_child_fs(mnt_tab *tb, mnt_iter *itr,
+			mnt_fs *parent, mnt_fs **chld)
+{
+	mnt_fs *fs;
+	int parent_id, lastchld_id = 0, chld_id = 0;
+
+	if (!tb || !itr || !parent)
+		return -EINVAL;
+
+	DBG(TAB, mnt_debug_h(tb, "lookup next child of %s",
+				mnt_fs_get_target(parent)));
+
+	parent_id = mnt_fs_get_id(parent);
+	if (!parent_id)
+		return -EINVAL;
+
+	/* get ID of the previously returned child */
+	if (itr->head && itr->p != itr->head) {
+		MNT_ITER_ITERATE(itr, fs, struct _mnt_fs, ents);
+		lastchld_id = mnt_fs_get_id(fs);
+	}
+
+	*chld = NULL;
+
+	mnt_reset_iter(itr, MNT_ITER_FORWARD);
+	while(mnt_tab_next_fs(tb, itr, &fs) == 0) {
+		int id;
+
+		if (mnt_fs_get_parent_id(fs) != parent_id)
+			continue;
+
+		id = mnt_fs_get_id(fs);
+
+		if ((!lastchld_id || id > lastchld_id) &&
+		    (!*chld || id < chld_id)) {
+			*chld = fs;
+			chld_id = id;
+		}
+	}
+
+	if (!chld_id)
+		return 1;	/* end of iterator */
+
+	/* set the iterator to the @chld for the next call */
+	mnt_tab_set_iter(tb, itr, *chld);
+
+	return 0;
+}
+
+/**
+ * mnt_tab_next_fs:
+ * @tb: tab pointer
+ * @itr: iterator
+ * @fs: returns the next tab entry
+ *
+ * Returns: 0 on success, negative number in case of error or 1 at end of list.
+ *
+ * Example:
+ * <informalexample>
+ *   <programlisting>
+ *	mnt_fs *fs;
+ *	mnt_tab *tb = mnt_new_tab("/etc/fstab");
+ *	mnt_iter *itr = mnt_new_iter(MNT_ITER_BACKWARD);
+ *
+ *	mnt_tab_parse_file(tb);
+ *
+ *	while(mnt_tab_next_fs(tb, itr, &fs) == 0) {
+ *		const char *dir = mnt_fs_get_target(fs);
+ *		printf("mount point: %s\n", dir);
+ *	}
+ *	mnt_free_tab(fi);
+ *   </programlisting>
+ * </informalexample>
+ *
+ * lists all mountpoints from fstab in backward order.
+ */
+int mnt_tab_next_fs(mnt_tab *tb, mnt_iter *itr, mnt_fs **fs)
+{
+	int rc = 1;
+
+	assert(tb);
+	assert(itr);
+	assert(fs);
+
+	if (!tb || !itr || !fs)
+		return -EINVAL;
+	*fs = NULL;
+
+	if (!itr->head)
+		MNT_ITER_INIT(itr, &tb->ents);
+	if (itr->p != itr->head) {
+		MNT_ITER_ITERATE(itr, *fs, struct _mnt_fs, ents);
+		rc = 0;
+	}
+
+	return rc;
+}
+
+/**
+ * mnt_tab_find_next_fs:
+ * @tb: table
+ * @itr: iterator
+ * @match_func: function returns 1 or 0
+ * @userdata: extra data for match_func
+ * @fs: returns pointer to the next matching table entry
+ *
+ * This function allows search in @tb.
+ *
+ * Returns: negative number in case of error, 1 at end of table or 0 o success.
+ */
+int mnt_tab_find_next_fs(mnt_tab *tb, mnt_iter *itr,
+		int (*match_func)(mnt_fs *, void *), void *userdata,
+		mnt_fs **fs)
+{
+	if (!tb || !itr || !fs || !match_func)
+		return -EINVAL;
+
+	DBG(TAB, mnt_debug_h(tb, "lookup next fs"));
+
+	if (!itr->head)
+		MNT_ITER_INIT(itr, &tb->ents);
+
+	do {
+		if (itr->p != itr->head)
+			MNT_ITER_ITERATE(itr, *fs, struct _mnt_fs, ents);
+		else
+			break;			/* end */
+
+		if (match_func(*fs, userdata))
+			return 0;
+	} while(1);
+
+	*fs = NULL;
+	return 1;
+}
+
+/**
+ * mnt_tab_set_iter:
+ * @tb: tab pointer
+ * @itr: iterator
+ * @fs: tab entry
+ *
+ * Sets @iter to the position of @fs in the file @tb.
+ *
+ * Returns: 0 on success, negative number in case of error.
+ */
+int mnt_tab_set_iter(mnt_tab *tb, mnt_iter *itr, mnt_fs *fs)
+{
+	assert(tb);
+	assert(itr);
+	assert(fs);
+
+	if (!tb || !itr || !fs)
+		return -EINVAL;
+
+	MNT_ITER_INIT(itr, &tb->ents);
+	itr->p = &fs->ents;
+
+	return 0;
+}
+
+/**
+ * mnt_tab_find_target:
+ * @tb: tab pointer
+ * @path: mountpoint directory
+ * @direction: MNT_ITER_{FORWARD,BACKWARD}
+ *
+ * Try to lookup an entry in given tab, possible are three iterations, first
+ * with @path, second with realpath(@path) and third with realpath(@path)
+ * against realpath(fs->target). The 2nd and 3rd iterations are not performed
+ * when @tb cache is not set (see mnt_tab_set_cache()).
+ *
+ * Returns: a tab entry or NULL.
+ */
+mnt_fs *mnt_tab_find_target(mnt_tab *tb, const char *path, int direction)
+{
+	mnt_iter itr;
+	mnt_fs *fs = NULL;
+	char *cn;
+
+	assert(tb);
+	assert(path);
+
+	if (!tb || !path)
+		return NULL;
+
+	DBG(TAB, mnt_debug_h(tb, "lookup target: %s", path));
+
+	/* native @target */
+	mnt_reset_iter(&itr, direction);
+	while(mnt_tab_next_fs(tb, &itr, &fs) == 0)
+		if (fs->target && strcmp(fs->target, path) == 0)
+			return fs;
+
+	if (!tb->cache || !(cn = mnt_resolve_path(path, tb->cache)))
+		return NULL;
+
+	/* canonicalized paths in mnt_tab */
+	mnt_reset_iter(&itr, direction);
+	while(mnt_tab_next_fs(tb, &itr, &fs) == 0) {
+		if (fs->target && strcmp(fs->target, cn) == 0)
+			return fs;
+	}
+
+	/* non-canonicaled path in mnt_tab */
+	mnt_reset_iter(&itr, direction);
+	while(mnt_tab_next_fs(tb, &itr, &fs) == 0) {
+		char *p;
+
+		if (!fs->target || !(fs->flags & MNT_FS_SWAP) ||
+		    (*fs->target == '/' && *(fs->target + 1) == '\0'))
+		       continue;
+
+		p = mnt_resolve_path(fs->target, tb->cache);
+		if (strcmp(cn, p) == 0)
+			return fs;
+	}
+	return NULL;
+}
+
+/**
+ * mnt_tab_find_srcpath:
+ * @tb: tab pointer
+ * @path: source path (devname or dirname)
+ * @direction: MNT_ITER_{FORWARD,BACKWARD}
+ *
+ * Try to lookup an entry in given tab, possible are four iterations, first
+ * with @path, second with realpath(@path), third with tags (LABEL, UUID, ..)
+ * from @path and fourth with realpath(@path) against realpath(entry->srcpath).
+ *
+ * The 2nd, 3rd and 4th iterations are not performed when @tb cache is not
+ * set (see mnt_tab_set_cache()).
+ *
+ * Returns: a tab entry or NULL.
+ */
+mnt_fs *mnt_tab_find_srcpath(mnt_tab *tb, const char *path, int direction)
+{
+	mnt_iter itr;
+	mnt_fs *fs = NULL;
+	int ntags = 0;
+	char *cn;
+	const char *p;
+
+	assert(tb);
+	assert(path);
+
+	DBG(TAB, mnt_debug_h(tb, "lookup srcpath: %s", path));
+
+	/* native paths */
+	mnt_reset_iter(&itr, direction);
+	while(mnt_tab_next_fs(tb, &itr, &fs) == 0) {
+		p = mnt_fs_get_srcpath(fs);
+		if (p && strcmp(p, path) == 0)
+			return fs;
+		if (!p)
+			/* mnt_fs_get_srcpath() returs nothing, it's TAG */
+			ntags++;
+	}
+
+	if (!tb->cache || !(cn = mnt_resolve_path(path, tb->cache)))
+		return NULL;
+
+	/* canonicalized paths in mnt_tab */
+	if (ntags < mnt_tab_get_nents(tb)) {
+		mnt_reset_iter(&itr, direction);
+		while(mnt_tab_next_fs(tb, &itr, &fs) == 0) {
+			p = mnt_fs_get_srcpath(fs);
+			if (p && strcmp(p, cn) == 0)
+				return fs;
+		}
+	}
+
+	/* evaluated tag */
+	if (ntags) {
+		int rc = mnt_cache_read_tags(tb->cache, cn);
+
+		mnt_reset_iter(&itr, direction);
+
+		if (rc == 0) {
+			/* @path's TAGs are in the cache */
+			while(mnt_tab_next_fs(tb, &itr, &fs) == 0) {
+				const char *t, *v;
+
+				if (mnt_fs_get_tag(fs, &t, &v))
+					continue;
+
+				if (mnt_cache_device_has_tag(tb->cache, cn, t, v))
+					return fs;
+			}
+		} else if (rc < 0 && errno == EACCES) {
+			/* @path is unaccessible, try evaluate all TAGs in @tb
+			 * by udev symlinks -- this could be expensive on systems
+			 * with huge fstab/mtab */
+			 while(mnt_tab_next_fs(tb, &itr, &fs) == 0) {
+				 const char *t, *v, *x;
+				 if (mnt_fs_get_tag(fs, &t, &v))
+					 continue;
+				 x = mnt_resolve_tag(t, v, tb->cache);
+				 if (x && !strcmp(x, cn))
+					 return fs;
+			 }
+		}
+	}
+
+	/* non-canonicalized paths in mnt_tab */
+	if (ntags <= mnt_tab_get_nents(tb)) {
+		mnt_reset_iter(&itr, direction);
+		while(mnt_tab_next_fs(tb, &itr, &fs) == 0) {
+			if (fs->flags & (MNT_FS_NET | MNT_FS_PSEUDO))
+				continue;
+			p = mnt_fs_get_srcpath(fs);
+			if (p)
+				p = mnt_resolve_path(p, tb->cache);
+			if (p && strcmp(cn, p) == 0)
+				return fs;
+		}
+	}
+
+	return NULL;
+}
+
+
+/**
+ * mnt_tab_find_tag:
+ * @tb: tab pointer
+ * @tag: tag name (e.g "LABEL", "UUID", ...)
+ * @val: tag value
+ * @direction: MNT_ITER_{FORWARD,BACKWARD}
+ *
+ * Try to lookup an entry in given tab, first attempt is lookup by @tag and
+ * @val, for the second attempt the tag is evaluated (converted to the device
+ * name) and mnt_tab_find_srcpath() is preformed. The second attempt is not
+ * performed when @tb cache is not set (see mnt_tab_set_cache()).
+
+ * Returns: a tab entry or NULL.
+ */
+mnt_fs *mnt_tab_find_tag(mnt_tab *tb, const char *tag,
+			const char *val, int direction)
+{
+	mnt_iter itr;
+	mnt_fs *fs = NULL;
+
+	assert(tb);
+	assert(tag);
+	assert(val);
+
+	if (!tb || !tag || !val)
+		return NULL;
+
+	DBG(TAB, mnt_debug_h(tb, "lookup by TAG: %s %s", tag, val));
+
+	/* look up by TAG */
+	mnt_reset_iter(&itr, direction);
+	while(mnt_tab_next_fs(tb, &itr, &fs) == 0) {
+		if (fs->tagname && fs->tagval &&
+		    strcmp(fs->tagname, tag) == 0 &&
+		    strcmp(fs->tagval, val) == 0)
+			return fs;
+	}
+
+	if (tb->cache) {
+		/* look up by device name */
+		char *cn = mnt_resolve_tag(tag, val, tb->cache);
+		if (cn)
+			return mnt_tab_find_srcpath(tb, cn, direction);
+	}
+	return NULL;
+}
+
+/**
+ * mnt_tab_find_source:
+ * @tb: tab pointer
+ * @source: TAG or path
+ * @direction: MNT_ITER_{FORWARD,BACKWARD}
+ *
+ * This is high-level API for mnt_tab_find_{srcpath,tag}. You needn't to care
+ * about @source format (device, LABEL, UUID, ...). This function parses @source
+ * and calls mnt_tab_find_tag() or mnt_tab_find_srcpath().
+ *
+ * Returns: a tab entry or NULL.
+ */
+mnt_fs *mnt_tab_find_source(mnt_tab *tb, const char *source, int direction)
+{
+	mnt_fs *fs = NULL;
+
+	assert(tb);
+	assert(source);
+
+	if (!tb || !source)
+		return NULL;
+
+	DBG(TAB, mnt_debug_h(tb, "lookup SOURCE: %s", source));
+
+	if (strchr(source, '=')) {
+		char *tag, *val;
+
+		if (blkid_parse_tag_string(source, &tag, &val) == 0) {
+
+			fs = mnt_tab_find_tag(tb, tag, val, direction);
+
+			free(tag);
+			free(val);
+		}
+	} else
+		fs = mnt_tab_find_srcpath(tb, source, direction);
+
+	return fs;
+}
+
+/**
+ * mnt_tab_find_pair
+ * @tb: tab pointer
+ * @source: TAG or path
+ * @target: mountpoint
+ * @direction: MNT_ITER_{FORWARD,BACKWARD}
+ *
+ * This function is implemented by mnt_fs_match_source() and
+ * mnt_fs_match_target() functions. It means that this is more expensive that
+ * others mnt_tab_find_* function, because every @tab entry is fully evaluated.
+ *
+ * Returns: a tab entry or NULL.
+ */
+mnt_fs *mnt_tab_find_pair(mnt_tab *tb, const char *source,
+			const char *target, int direction)
+{
+	mnt_fs *fs = NULL;
+	mnt_iter itr;
+
+	assert(tb);
+	assert(source);
+	assert(target);
+
+	if (!tb || !source || !target)
+		return NULL;
+
+	DBG(TAB, mnt_debug_h(tb, "lookup SOURCE: %s TARGET: %s", source, target));
+
+	mnt_reset_iter(&itr, direction);
+	while(mnt_tab_next_fs(tb, &itr, &fs) == 0) {
+
+		if (mnt_fs_match_target(fs, target, tb->cache) &&
+		    mnt_fs_match_source(fs, source, tb->cache))
+			return fs;
+	}
+
+	return NULL;
+}
+
diff -up util-linux-ng-2.17.2/shlibs/mount/src/tab_parse.c.kzak util-linux-ng-2.17.2/shlibs/mount/src/tab_parse.c
--- util-linux-ng-2.17.2/shlibs/mount/src/tab_parse.c.kzak	2012-10-08 12:51:49.142688925 +0200
+++ util-linux-ng-2.17.2/shlibs/mount/src/tab_parse.c	2012-10-08 12:51:49.142688925 +0200
@@ -0,0 +1,506 @@
+/*
+ * Copyright (C) 2009 Karel Zak <kzak@redhat.com>
+ *
+ * This file may be redistributed under the terms of the
+ * GNU Lesser General Public License.
+ */
+
+#include <string.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <limits.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <dirent.h>
+#include <fcntl.h>
+#include <unistd.h>
+
+#include "nls.h"
+#include "mountP.h"
+#include "pathnames.h"
+
+#define isoctal(a) (((a) & ~7) == '0')
+
+void unmangle_to_buffer(const char *s, char *buf, size_t len)
+{
+	size_t sz = 0;
+
+	if (!s)
+		return;
+
+	while(*s && sz < len - 1) {
+		if (*s == '\\' && sz + 4 < len - 1 && isoctal(s[1]) &&
+		    isoctal(s[2]) && isoctal(s[3])) {
+
+			*buf++ = 64*(s[1] & 7) + 8*(s[2] & 7) + (s[3] & 7);
+			s += 4;
+			sz += 4;
+		} else {
+			*buf++ = *s++;
+			sz++;
+		}
+	}
+	*buf = '\0';
+}
+
+static inline void unmangle_string(char *s)
+{
+	unmangle_to_buffer(s, s, strlen(s) + 1);
+}
+
+static inline char *skip_spaces(char *s)
+{
+	assert(s);
+
+	while (*s == ' ' || *s == '\t')
+		s++;
+	return s;
+}
+
+static int next_number(char **s, int *num)
+{
+	char *end = NULL;
+
+	assert(num);
+	assert(s);
+
+	*s = skip_spaces(*s);
+	if (!**s)
+		return -1;
+	*num = strtol(*s, &end, 10);
+	if (end == NULL || *s == end)
+	       return -1;
+
+	*s = end;
+
+	/* valid end of number is space or terminator */
+	if (*end == ' ' || *end == '\t' || *end == '\0')
+		return 0;
+	return -1;
+}
+
+/*
+ * Parses one line from {fs,m}tab
+ */
+static int mnt_parse_tab_line(mnt_fs *fs, char *s)
+{
+	int rc, n = 0;
+	char *src, *fstype, *optstr;
+
+	rc = sscanf(s,	"%ms "	/* (1) source */
+			"%ms "	/* (2) target */
+			"%ms "	/* (3) FS type */
+			"%ms "  /* (4) options */
+			"%n",	/* byte count */
+			&src,
+			&fs->target,
+			&fstype,
+			&optstr,
+			&n);
+
+	if (rc == 4) {
+		unmangle_string(src);
+		unmangle_string(fs->target);
+		unmangle_string(fstype);
+		unmangle_string(optstr);
+
+		rc = __mnt_fs_set_source_ptr(fs, src);
+		if (!rc)
+			rc = __mnt_fs_set_fstype_ptr(fs, fstype);
+		if (!rc)
+			rc = mnt_fs_set_options(fs, optstr);
+		free(optstr);
+	} else {
+		DBG(TAB, mnt_debug("tab parse error: [sscanf rc=%d]: '%s'", rc, s));
+		rc = -EINVAL;
+	}
+
+	if (rc)
+		return rc;	/* error */
+
+	fs->passno = fs->freq = 0;
+	s = skip_spaces(s + n);
+	if (*s) {
+		if (next_number(&s, &fs->freq) != 0) {
+			if (*s) {
+				DBG(TAB, mnt_debug("tab parse error: [freq]"));
+				rc = -EINVAL;
+			}
+		} else if (next_number(&s, &fs->passno) != 0 && *s) {
+			DBG(TAB, mnt_debug("tab parse error: [passno]"));
+			rc = -EINVAL;
+		}
+	}
+
+	return rc;
+}
+
+/*
+ * Parses one line from mountinfo file
+ */
+static int mnt_parse_mountinfo_line(mnt_fs *fs, char *s)
+{
+	int rc;
+	unsigned int maj, min;
+	char *fstype, *src;
+
+	rc = sscanf(s,	"%u "		/* (1) id */
+			"%u "		/* (2) parent */
+			"%u:%u "	/* (3) maj:min */
+			"%ms "		/* (4) mountroot */
+			"%ms "		/* (5) target */
+			"%ms"		/* (6) vfs options (fs-independent) */
+			"%*[^-]"	/* (7) optional fields */
+			"- "		/* (8) separator */
+			"%ms "		/* (9) FS type */
+			"%ms "		/* (10) source */
+			"%ms",		/* (11) fs options (fs specific) */
+
+			&fs->id,
+			&fs->parent,
+			&maj, &min,
+			&fs->root,
+			&fs->target,
+			&fs->vfs_optstr,
+			&fstype,
+			&src,
+			&fs->fs_optstr);
+
+	if (rc == 10) {
+		fs->devno = makedev(maj, min);
+
+		unmangle_string(fs->root);
+		unmangle_string(fs->target);
+		unmangle_string(fs->vfs_optstr);
+		unmangle_string(fstype);
+
+		if (!strcmp(src, "none")) {
+			free(src);
+			src = NULL;
+		} else
+			unmangle_string(src);
+
+		if (!strcmp(fs->fs_optstr, "none")) {
+			free(fs->fs_optstr);
+			fs->fs_optstr = NULL;
+		} else
+			unmangle_string(fs->fs_optstr);
+
+		rc = __mnt_fs_set_fstype_ptr(fs, fstype);
+		if (!rc)
+			rc = __mnt_fs_set_source_ptr(fs, src);
+	} else {
+		DBG(TAB, mnt_debug(
+			"mountinfo parse error [sscanf rc=%d]: '%s'", rc, s));
+		rc = -EINVAL;
+	}
+	return rc;
+}
+
+/*
+ * Returns {m,fs}tab or mountinfo file format (MNT_FMT_*)
+ *
+ * mountinfo: "<number> <number> ... "
+ */
+static int guess_tab_format(char *line)
+{
+	unsigned int a, b;
+
+	if (sscanf(line, "%u %u", &a, &b) == 2)
+		return MNT_FMT_MOUNTINFO;
+	return MNT_FMT_FSTAB;
+}
+
+/*
+ * Read and parse the next line from {fs,m}tab or mountinfo
+ */
+static int mnt_tab_parse_next(mnt_tab *tb, FILE *f, mnt_fs *fs,
+				const char *filename, int *nlines)
+{
+	char buf[BUFSIZ];
+	char *s;
+
+	assert(tb);
+	assert(f);
+	assert(fs);
+
+	/* read the next non-blank non-comment line */
+	do {
+		if (fgets(buf, sizeof(buf), f) == NULL)
+			return -EINVAL;
+		++*nlines;
+		s = index (buf, '\n');
+		if (!s) {
+			/* Missing final newline?  Otherwise extremely */
+			/* long line - assume file was corrupted */
+			if (feof(f)) {
+				DBG(TAB, mnt_debug_h(tb,
+					"%s: no final newline",	filename));
+				s = index (buf, '\0');
+			} else {
+				DBG(TAB, mnt_debug_h(tb,
+					"%s:%d: missing newline at line",
+					filename, *nlines));
+				goto err;
+			}
+		}
+		*s = '\0';
+		if (--s >= buf && *s == '\r')
+			*s = '\0';
+		s = skip_spaces(buf);
+	} while (*s == '\0' || *s == '#');
+
+	if (tb->fmt == MNT_FMT_GUESS)
+		tb->fmt = guess_tab_format(s);
+
+	if (tb->fmt == MNT_FMT_FSTAB) {
+		if (mnt_parse_tab_line(fs, s) != 0)
+			goto err;
+
+	} else if (tb->fmt == MNT_FMT_MOUNTINFO) {
+		if (mnt_parse_mountinfo_line(fs, s) != 0)
+			goto err;
+
+	}
+
+	/*DBG(TAB, mnt_fs_print_debug(fs, stderr));*/
+
+	return 0;
+err:
+	DBG(TAB, mnt_debug_h(tb, "%s:%d: %s parse error", filename, *nlines,
+				tb->fmt == MNT_FMT_MOUNTINFO ? "mountinfo" :
+				tb->fmt == MNT_FMT_FSTAB ? "fstab" : "uknown"));
+
+	/* by default all errors are recoverable, otherwise behavior depends on
+	 * errcb() function. See mnt_tab_set_parser_errcb().
+	 */
+	return tb->errcb ? tb->errcb(tb, filename, *nlines) : 1;
+}
+
+/**
+ * mnt_tab_parse_stream:
+ * @tb: tab pointer
+ * @f: file stream
+ * @filename: filename used for debug and error messages
+ *
+ * Returns: 0 on success, negative number in case of error.
+ */
+int mnt_tab_parse_stream(mnt_tab *tb, FILE *f, const char *filename)
+{
+	int nlines = 0;
+	int rc = -1;
+
+	assert(tb);
+	assert(f);
+	assert(filename);
+
+	DBG(TAB, mnt_debug_h(tb, "%s: start parsing", filename));
+
+	while (!feof(f)) {
+		mnt_fs *fs = mnt_new_fs();
+
+		if (!fs)
+			goto err;
+
+		rc = mnt_tab_parse_next(tb, f, fs, filename, &nlines);
+		if (!rc)
+			rc = mnt_tab_add_fs(tb, fs);
+		if (rc) {
+			mnt_free_fs(fs);
+			if (rc == 1)
+				continue;	/* recoverable error */
+			if (feof(f))
+				break;
+			goto err;		/* fatal error */
+		}
+	}
+
+	DBG(TAB, mnt_debug_h(tb, "%s: stop parsing", filename));
+	return 0;
+err:
+	DBG(TAB, mnt_debug_h(tb, "%s: parse error (rc=%d)", filename, rc));
+	return rc;
+}
+
+/**
+ * mnt_tab_parse_file:
+ * @tb: tab pointer
+ * @filename: file
+ *
+ * Parses whole table (e.g. /etc/mtab) and appends new records to the @tab.
+ *
+ * The libmount parser ignores broken (syntax error) lines, these lines are
+ * reported to caller by errcb() function (see mnt_tab_set_parser_errcb()).
+ *
+ * Returns: 0 on success, negative number in case of error.
+ */
+int mnt_tab_parse_file(mnt_tab *tb, const char *filename)
+{
+	FILE *f;
+	int rc;
+
+	assert(tb);
+	assert(filename);
+
+	if (!filename || !tb)
+		return -EINVAL;
+
+	f = fopen(filename, "r");
+	if (f) {
+		rc = mnt_tab_parse_stream(tb, f, filename);
+		fclose(f);
+	} else
+		return -errno;
+
+	return rc;
+}
+
+mnt_tab *__mnt_new_tab_from_file(const char *filename, int fmt)
+{
+	mnt_tab *tb;
+	struct stat st;
+
+	assert(filename);
+
+	if (!filename)
+		return NULL;
+	if (stat(filename, &st))
+		return NULL;
+	tb = mnt_new_tab();
+	if (tb) {
+		tb->fmt = fmt;
+		if (mnt_tab_parse_file(tb, filename) != 0) {
+			mnt_free_tab(tb);
+			tb = NULL;
+		}
+	}
+	return tb;
+}
+
+/**
+ * mnt_new_tab_from_file:
+ * @filename: /etc/{m,fs}tab or /proc/self/mountinfo path
+ *
+ * Same as mnt_new_tab() + mnt_tab_parse_file(). Use this function for private
+ * files only. This function does not allow to use error callback, so you
+ * cannot provide any feedback to end-users about broken records in files (e.g.
+ * fstab).
+ *
+ * Returns: newly allocated tab on success and NULL in case of error.
+ */
+mnt_tab *mnt_new_tab_from_file(const char *filename)
+{
+	return __mnt_new_tab_from_file(filename, MNT_FMT_GUESS);
+}
+
+/**
+ * mnt_tab_set_parser_errcb:
+ * @tb: pointer to table
+ * @cb: pointer to callback function
+ *
+ * The error callback function is called by table parser (mnt_tab_parse_file())
+ * in case of syntax error. The callback function could be used for errors
+ * evaluation, libmount will continue/stop parsing according to callback return
+ * codes:
+ *
+ *   <0  : fatal error (abort parsing)
+ *    0	 : success (parsing continue)
+ *   >0  : recoverable error (the line is ignored, parsing continue).
+ *
+ * Returns: 0 on success or negative number in case of error.
+ */
+int mnt_tab_set_parser_errcb(mnt_tab *tb,
+		int (*cb)(mnt_tab *tb, const char *filename, int line))
+{
+	assert(tb);
+	tb->errcb = cb;
+	return 0;
+}
+
+/**
+ * mnt_tab_parse_fstab:
+ * @tb: table
+ * @filename: overwrites default (/etc/fstab or $LIBMOUNT_FSTAB) or NULL
+ *
+ * This function parses /etc/fstab or /etc/fstab.d and appends new lines to the
+ * @tab. If the system contains classic fstab file and also fstab.d directory
+ * then the fstab file is parsed before the fstab.d directory.
+ *
+ * The fstab.d directory:
+ *	- files are sorted by strverscmp(3)
+ *	- files that starts with "." are ignored (e.g. ".10foo.fstab")
+ *	- files without the ".fstab" extension are ignored
+ *
+ * See also mnt_tab_set_parser_errcb().
+ *
+ * Returns: 0 on success or negative number in case of error.
+ */
+int mnt_tab_parse_fstab(mnt_tab *tb, const char *filename)
+{
+	FILE *f;
+
+	assert(tb);
+
+	if (!tb)
+		return -EINVAL;
+	if (!filename)
+		filename = mnt_get_fstab_path();
+
+	tb->fmt = MNT_FMT_FSTAB;
+
+	f = fopen(filename, "r");
+	if (f) {
+		int rc = mnt_tab_parse_stream(tb, f, filename);
+		fclose(f);
+
+		if (rc)
+			return rc;
+
+		if (strcmp(filename, _PATH_MNTTAB))
+			/* /etc/fstab.d sould be used together with /etc/fstab only */
+			return 0;
+	}
+
+	return 0;
+}
+
+/**
+ * mnt_tab_parse_mtab:
+ * @tb: table
+ * @filename: overwrites default (/etc/mtab or $LIBMOUNT_MTAB) or NULL
+ *
+ * This function parses /etc/mtab or /proc/self/mountinfo or
+ * /proc/mounts.
+ *
+ * See also mnt_tab_set_parser_errcb().
+ *
+ * Returns: 0 on success or negative number in case of error.
+ */
+int mnt_tab_parse_mtab(mnt_tab *tb, const char *filename)
+{
+	int rc;
+
+	if (mnt_has_regular_mtab(&filename, NULL)) {
+
+		DBG(TAB, mnt_debug_h(tb, "force %s usage", filename));
+
+		rc = mnt_tab_parse_file(tb, filename);
+		if (!rc)
+			return 0;
+		filename = NULL;	/* failed */
+	}
+
+	/*
+	 * useless /etc/mtab
+	 * -- read kernel information from /proc/self/mountinfo
+	 */
+	tb->fmt = MNT_FMT_MOUNTINFO;
+	rc = mnt_tab_parse_file(tb, _PATH_PROC_MOUNTINFO);
+	if (rc) {
+		/* hmm, old kernel? ...try /proc/mounts */
+		tb->fmt = MNT_FMT_MTAB;
+		return mnt_tab_parse_file(tb, _PATH_PROC_MOUNTS);
+	}
+
+	return 0;
+}
diff -up util-linux-ng-2.17.2/shlibs/mount/src/utils.c.kzak util-linux-ng-2.17.2/shlibs/mount/src/utils.c
--- util-linux-ng-2.17.2/shlibs/mount/src/utils.c.kzak	2012-10-08 12:51:49.143688932 +0200
+++ util-linux-ng-2.17.2/shlibs/mount/src/utils.c	2012-10-08 12:51:49.143688932 +0200
@@ -0,0 +1,342 @@
+/*
+ * Copyright (C) 2008-2009 Karel Zak <kzak@redhat.com>
+ *
+ * This file may be redistributed under the terms of the
+ * GNU Lesser General Public License.
+ */
+
+/**
+ * SECTION: utils
+ * @title: Utils
+ * @short_description: misc utils.
+ */
+#include <unistd.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/stat.h>
+#include <ctype.h>
+#include <sys/types.h>
+#include <fcntl.h>
+#include <pwd.h>
+#include <grp.h>
+
+#include "strutils.h"
+#include "pathnames.h"
+#include "mountP.h"
+#include "canonicalize.h"
+#include "env.h"
+
+int endswith(const char *s, const char *sx)
+{
+	ssize_t off;
+
+	assert(s);
+	assert(sx);
+
+	off = strlen(s);
+	if (!off)
+		return 0;
+	off -= strlen(sx);
+	if (off < 0)
+		return 0;
+
+        return !strcmp(s + off, sx);
+}
+
+int startswith(const char *s, const char *sx)
+{
+	size_t off;
+
+	assert(s);
+	assert(sx);
+
+	off = strlen(sx);
+	if (!off)
+		return 0;
+
+        return !strncmp(s, sx, off);
+}
+
+/* returns basename and keeps dirname in the @path, if @path is "/" (root)
+ * then returns empty string */
+static char *stripoff_last_component(char *path)
+{
+	char *p = path ? strrchr(path, '/') : NULL;
+
+	if (!p)
+		return NULL;
+	*p = '\0';
+	return ++p;
+}
+
+/**
+ * mnt_fstype_is_pseudofs:
+ * @type: filesystem name
+ *
+ * Returns: 1 for filesystems like proc, sysfs, ... or 0.
+ */
+int mnt_fstype_is_pseudofs(const char *type)
+{
+	if (!type)
+		return 0;
+	if (strcmp(type, "none")  == 0 ||
+	    strcmp(type, "proc")  == 0 ||
+	    strcmp(type, "tmpfs") == 0 ||
+	    strcmp(type, "sysfs") == 0 ||
+	    strcmp(type, "devpts") == 0||
+	    strcmp(type, "cgroups") == 0 ||
+	    strcmp(type, "devfs") == 0 ||
+	    strcmp(type, "dlmfs") == 0 ||
+	    strcmp(type, "cpuset") == 0 ||
+	    strcmp(type, "securityfs") == 0 ||
+	    strcmp(type, "rpc_pipefs") == 0 ||
+	    strcmp(type, "fusectl") == 0 ||
+	    strcmp(type, "binfmt_misc") == 0 ||
+	    strcmp(type, "fuse.gvfs-fuse-daemon") == 0 ||
+	    strcmp(type, "debugfs") == 0 ||
+	    strcmp(type, "spufs") == 0)
+		return 1;
+	return 0;
+}
+
+/**
+ * mnt_fstype_is_netfs:
+ * @type: filesystem name
+ *
+ * Returns: 1 for filesystems like cifs, nfs, ... or 0.
+ */
+int mnt_fstype_is_netfs(const char *type)
+{
+	if (!type)
+		return 0;
+	if (strcmp(type, "cifs")   == 0 ||
+	    strcmp(type, "smbfs")  == 0 ||
+	    strncmp(type,"nfs", 3) == 0 ||
+	    strcmp(type, "afs")    == 0 ||
+	    strcmp(type, "ncpfs")  == 0 ||
+	    strncmp(type,"9p", 2)  == 0)
+		return 1;
+	return 0;
+}
+
+/**
+ * mnt_match_fstype:
+ * @type: filesystem type
+ * @pattern: filesystem name or comma delimitted list of names
+ *
+ * The @pattern list of filesystem can be prefixed with a global
+ * "no" prefix to invert matching of the whole list. The "no" could
+ * also used for individual items in the @pattern list. So,
+ * "nofoo,bar" has the same meaning as "nofoo,nobar".
+ *
+ * "bar"  : "nofoo,bar"		-> False   (global "no" prefix)
+ *
+ * "bar"  : "foo,bar"		-> True
+ *
+ * "bar" : "foo,nobar"		-> False
+ *
+ * Returns: 1 if type is matching, else 0. This function also returns
+ *          0 if @pattern is NULL and @type is non-NULL.
+ */
+int mnt_match_fstype(const char *type, const char *pattern)
+{
+	int no = 0;		/* negated types list */
+	int len;
+	const char *p;
+
+	if (!pattern && !type)
+		return 1;
+	if (!pattern)
+		return 0;
+
+	if (!strncmp(pattern, "no", 2)) {
+		no = 1;
+		pattern += 2;
+	}
+
+	/* Does type occur in types, separated by commas? */
+	len = strlen(type);
+	p = pattern;
+	while(1) {
+		if (!strncmp(p, "no", 2) && !strncmp(p+2, type, len) &&
+		    (p[len+2] == 0 || p[len+2] == ','))
+			return 0;
+		if (strncmp(p, type, len) == 0 && (p[len] == 0 || p[len] == ','))
+			return !no;
+		p = strchr(p,',');
+		if (!p)
+			break;
+		p++;
+	}
+	return no;
+}
+
+
+/* Returns 1 if needle found or noneedle not found in haystack
+ * Otherwise returns 0
+ */
+static int check_option(const char *haystack, size_t len,
+			const char *needle, size_t needle_len)
+{
+	const char *p;
+	int no = 0;
+
+	if (needle_len >= 2 && !strncmp(needle, "no", 2)) {
+		no = 1;
+		needle += 2;
+		needle_len -= 2;
+	}
+
+	for (p = haystack; p && p < haystack + len; p++) {
+		char *sep = strchr(p, ',');
+		size_t plen = sep ? sep - p : len - (p - haystack);
+
+		if (plen == needle_len) {
+			if (!strncmp(p, needle, plen))
+				return !no;	/* foo or nofoo was found */
+		}
+		p += plen;
+	}
+
+	return no;  /* foo or nofoo was not found */
+}
+
+/**
+ * mnt_match_options:
+ * @optstr: options string
+ * @pattern: comma delimitted list of options
+ *
+ * The "no" could used for individual items in the @options list. The "no"
+ * prefix does not have a global meanning.
+ *
+ * Unlike fs type matching, nonetdev,user and nonetdev,nouser have
+ * DIFFERENT meanings; each option is matched explicitly as specified.
+ *
+ * "xxx,yyy,zzz" : "nozzz"	-> False
+ *
+ * "xxx,yyy,zzz" : "xxx,noeee"	-> True
+ *
+ * Returns: 1 if pattern is matching, else 0. This function also returns 0
+ *          if @pattern is NULL and @optstr is non-NULL.
+ */
+int mnt_match_options(const char *optstr, const char *pattern)
+{
+	const char *p;
+	size_t len, optstr_len = 0;
+
+	if (!pattern && !optstr)
+		return 1;
+	if (!pattern)
+		return 0;
+
+	len = strlen(pattern);
+	if (optstr)
+		optstr_len = strlen(optstr);
+
+	for (p = pattern; p < pattern + len; p++) {
+		char *sep = strchr(p, ',');
+		size_t plen = sep ? sep - p : len - (p - pattern);
+
+		if (!plen)
+			continue; /* if two ',' appear in a row */
+
+		if (!check_option(optstr, optstr_len, p, plen))
+			return 0; /* any match failure means failure */
+
+		p += plen;
+	}
+
+	/* no match failures in list means success */
+	return 1;
+}
+
+static int try_write(const char *filename)
+{
+	int fd;
+
+	if (!filename)
+		return -EINVAL;
+
+	fd = open(filename, O_RDWR|O_CREAT, S_IWUSR| \
+					    S_IRUSR|S_IRGRP|S_IROTH);
+	if (fd >= 0) {
+		close(fd);
+		return 0;
+	}
+	return -errno;
+}
+
+/**
+ * mnt_has_regular_mtab:
+ * @mtab: returns path to mtab
+ * @writable: returns 1 if the file is writable
+ *
+ * If the file does not exist and @writable argument is not NULL then it will
+ * try to create the file
+ *
+ * Returns: 1 if /etc/mtab is a reqular file, and 0 in case of error (check
+ *          errno for more details).
+ */
+int mnt_has_regular_mtab(const char **mtab, int *writable)
+{
+	struct stat st;
+	int rc;
+	const char *filename = mtab && *mtab ? *mtab : mnt_get_mtab_path();
+
+	if (writable)
+		*writable = 0;
+	if (mtab && !*mtab)
+		*mtab = filename;
+
+	DBG(UTILS, mnt_debug("mtab: %s", filename));
+
+	rc = lstat(filename, &st);
+
+	if (rc == 0) {
+		/* file exist */
+		if (S_ISREG(st.st_mode)) {
+			if (writable)
+				*writable = !try_write(filename);
+			return 1;
+		}
+		goto done;
+	}
+
+	/* try to create the file */
+	if (writable) {
+		*writable = !try_write(filename);
+		if (*writable)
+			return 1;
+	}
+
+done:
+	DBG(UTILS, mnt_debug("%s: irregular/non-writable", filename));
+	return 0;
+}
+
+/**
+ * mnt_get_fstab_path:
+ *
+ * Returns: path to /etc/fstab or $LIBMOUNT_FSTAB.
+ */
+const char *mnt_get_fstab_path(void)
+{
+	const char *p = safe_getenv("LIBMOUNT_FSTAB");
+	return p ? : _PATH_MNTTAB;
+}
+
+/**
+ * mnt_get_mtab_path:
+ *
+ * This function returns *default* location of the mtab file. The result does
+ * not have to be writable. See also mnt_has_regular_mtab().
+ *
+ * Returns: path to /etc/mtab or $LIBMOUNT_MTAB.
+ */
+const char *mnt_get_mtab_path(void)
+{
+	const char *p = safe_getenv("LIBMOUNT_MTAB");
+	return p ? : _PATH_MOUNTED;
+}
+
