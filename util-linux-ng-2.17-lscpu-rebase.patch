diff -up util-linux-ng-2.17.2/include/cpuset.h.lscpu util-linux-ng-2.17.2/include/cpuset.h
--- util-linux-ng-2.17.2/include/cpuset.h.lscpu	2012-10-05 17:41:26.607773103 +0200
+++ util-linux-ng-2.17.2/include/cpuset.h	2012-10-05 17:41:26.607773103 +0200
@@ -0,0 +1,99 @@
+#ifndef UTIL_LINUX_CPUSET_H
+#define UTIL_LINUX_CPUSET_H
+
+#include <sched.h>
+
+/* hardcoded for backport to 2.17 (RHEL6), upstream version uses ./configure */
+#define HAVE_CPU_SET_T		1
+#define HAVE_DECL_CPU_ALLOC	1
+
+/*
+ * Fallback for old or obscure libcs without dynamically allocated cpusets
+ *
+ * The following macros are based on code from glibc.
+ *
+ * The GNU C Library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ */
+#if !HAVE_DECL_CPU_ALLOC
+
+# define CPU_ZERO_S(setsize, cpusetp) \
+  do {									      \
+    size_t __i;								      \
+    size_t __imax = (setsize) / sizeof (__cpu_mask);			      \
+    __cpu_mask *__bits = (cpusetp)->__bits;				      \
+    for (__i = 0; __i < __imax; ++__i)					      \
+      __bits[__i] = 0;							      \
+  } while (0)
+
+# define CPU_SET_S(cpu, setsize, cpusetp) \
+   ({ size_t __cpu = (cpu);						      \
+      __cpu < 8 * (setsize)						      \
+      ? (((__cpu_mask *) ((cpusetp)->__bits))[__CPUELT (__cpu)]		      \
+	 |= __CPUMASK (__cpu))						      \
+      : 0; })
+
+# define CPU_ISSET_S(cpu, setsize, cpusetp) \
+   ({ size_t __cpu = (cpu);						      \
+      __cpu < 8 * (setsize)						      \
+      ? ((((__cpu_mask *) ((cpusetp)->__bits))[__CPUELT (__cpu)]	      \
+	  & __CPUMASK (__cpu))) != 0					      \
+      : 0; })
+
+# define CPU_EQUAL_S(setsize, cpusetp1, cpusetp2) \
+   ({ __cpu_mask *__arr1 = (cpusetp1)->__bits;				      \
+      __cpu_mask *__arr2 = (cpusetp2)->__bits;				      \
+      size_t __imax = (setsize) / sizeof (__cpu_mask);			      \
+      size_t __i;							      \
+      for (__i = 0; __i < __imax; ++__i)				      \
+	if (__arr1[__i] != __arr2[__i])					      \
+	  break;							      \
+      __i == __imax; })
+
+extern int __cpuset_count_s(size_t setsize, const cpu_set_t *set);
+# define CPU_COUNT_S(setsize, cpusetp)	__cpuset_count_s(setsize, cpusetp)
+
+# define CPU_ALLOC_SIZE(count) \
+	  ((((count) + __NCPUBITS - 1) / __NCPUBITS) * sizeof (__cpu_mask))
+# define CPU_ALLOC(count)	(malloc(CPU_ALLOC_SIZE(count)))
+# define CPU_FREE(cpuset)	(free(cpuset))
+
+#endif /* !HAVE_DECL_CPU_ALLOC */
+
+
+#define cpuset_nbits(setsize)	(8 * (setsize))
+
+/*
+ * The @idx parametr returns an index of the first mask from @ary array where
+ * the @cpu is set.
+ *
+ * Returns: 0 if found, otherwise 1.
+ */
+static inline int cpuset_ary_isset(size_t cpu, cpu_set_t **ary, size_t nmemb,
+				   size_t setsize, size_t *idx)
+{
+	size_t i;
+
+	for (i = 0; i < nmemb; i++) {
+		if (CPU_ISSET_S(cpu, setsize, ary[i])) {
+			*idx = i;
+			return 0;
+		}
+	}
+	return 1;
+}
+
+extern int get_max_number_of_cpus(void);
+
+extern cpu_set_t *cpuset_alloc(int ncpus, size_t *setsize, size_t *nbits);
+extern void cpuset_free(cpu_set_t *set);
+
+extern char *cpulist_create(char *str, size_t len, cpu_set_t *set, size_t setsize);
+extern int cpulist_parse(const char *str, cpu_set_t *set, size_t setsize, int fail);
+
+extern char *cpumask_create(char *str, size_t len, cpu_set_t *set, size_t setsize);
+extern int cpumask_parse(const char *str, cpu_set_t *set, size_t setsize);
+
+#endif /* UTIL_LINUX_CPUSET_H */
diff -up util-linux-ng-2.17.2/lib/cpuset.c.lscpu util-linux-ng-2.17.2/lib/cpuset.c
--- util-linux-ng-2.17.2/lib/cpuset.c.lscpu	2012-10-05 17:41:26.609773115 +0200
+++ util-linux-ng-2.17.2/lib/cpuset.c	2012-10-05 17:41:26.609773115 +0200
@@ -0,0 +1,399 @@
+/*
+ * Terminology:
+ *
+ *	cpuset	- (libc) cpu_set_t data structure represents set of CPUs
+ *	cpumask	- string with hex mask (e.g. "0x00000001")
+ *	cpulist - string with CPU ranges (e.g. "0-3,5,7,8")
+ *
+ * Based on code from taskset.c and Linux kernel.
+ *
+ * Copyright (C) 2010 Karel Zak <kzak@redhat.com>
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sched.h>
+#include <errno.h>
+#include <string.h>
+#include <ctype.h>
+#include <sys/syscall.h>
+
+#include "cpuset.h"
+#include "c.h"
+
+static inline int val_to_char(int v)
+{
+	if (v >= 0 && v < 10)
+		return '0' + v;
+	else if (v >= 10 && v < 16)
+		return ('a' - 10) + v;
+	else
+		return -1;
+}
+
+static inline int char_to_val(int c)
+{
+	int cl;
+
+	cl = tolower(c);
+	if (c >= '0' && c <= '9')
+		return c - '0';
+	else if (cl >= 'a' && cl <= 'f')
+		return cl + (10 - 'a');
+	else
+		return -1;
+}
+
+static const char *nexttoken(const char *q,  int sep)
+{
+	if (q)
+		q = strchr(q, sep);
+	if (q)
+		q++;
+	return q;
+}
+
+/*
+ * Number of bits in a CPU bitmask on current system
+ */
+int get_max_number_of_cpus(void)
+{
+#ifdef SYS_sched_getaffinity
+	int n, cpus = 2048;
+	size_t setsize;
+	cpu_set_t *set = cpuset_alloc(cpus, &setsize, NULL);
+
+	if (!set)
+		return -1;	/* error */
+
+	for (;;) {
+		CPU_ZERO_S(setsize, set);
+
+		/* the library version does not return size of cpumask_t */
+		n = syscall(SYS_sched_getaffinity, 0, setsize, set);
+
+		if (n < 0 && errno == EINVAL && cpus < 1024 * 1024) {
+			cpuset_free(set);
+			cpus *= 2;
+			set = cpuset_alloc(cpus, &setsize, NULL);
+			if (!set)
+				return -1;	/* error */
+			continue;
+		}
+		cpuset_free(set);
+		return n * 8;
+	}
+#endif
+	return -1;
+}
+
+/*
+ * Allocates a new set for ncpus and returns size in bytes and size in bits
+ */
+cpu_set_t *cpuset_alloc(int ncpus, size_t *setsize, size_t *nbits)
+{
+	cpu_set_t *set = CPU_ALLOC(ncpus);
+
+	if (!set)
+		return NULL;
+	if (setsize)
+		*setsize = CPU_ALLOC_SIZE(ncpus);
+	if (nbits)
+		*nbits = cpuset_nbits(CPU_ALLOC_SIZE(ncpus));
+	return set;
+}
+
+void cpuset_free(cpu_set_t *set)
+{
+	CPU_FREE(set);
+}
+
+#if !HAVE_DECL_CPU_ALLOC
+/* Please, use CPU_COUNT_S() macro. This is fallback */
+int __cpuset_count_s(size_t setsize, const cpu_set_t *set)
+{
+	int s = 0;
+	const __cpu_mask *p = set->__bits;
+	const __cpu_mask *end = &set->__bits[setsize / sizeof (__cpu_mask)];
+
+	while (p < end) {
+		__cpu_mask l = *p++;
+
+		if (l == 0)
+			continue;
+# if LONG_BIT > 32
+		l = (l & 0x5555555555555555ul) + ((l >> 1) & 0x5555555555555555ul);
+		l = (l & 0x3333333333333333ul) + ((l >> 2) & 0x3333333333333333ul);
+		l = (l & 0x0f0f0f0f0f0f0f0ful) + ((l >> 4) & 0x0f0f0f0f0f0f0f0ful);
+		l = (l & 0x00ff00ff00ff00fful) + ((l >> 8) & 0x00ff00ff00ff00fful);
+		l = (l & 0x0000ffff0000fffful) + ((l >> 16) & 0x0000ffff0000fffful);
+		l = (l & 0x00000000fffffffful) + ((l >> 32) & 0x00000000fffffffful);
+# else
+		l = (l & 0x55555555ul) + ((l >> 1) & 0x55555555ul);
+		l = (l & 0x33333333ul) + ((l >> 2) & 0x33333333ul);
+		l = (l & 0x0f0f0f0ful) + ((l >> 4) & 0x0f0f0f0ful);
+		l = (l & 0x00ff00fful) + ((l >> 8) & 0x00ff00fful);
+		l = (l & 0x0000fffful) + ((l >> 16) & 0x0000fffful);
+# endif
+		s += l;
+	}
+	return s;
+}
+#endif
+
+/*
+ * Returns human readable representation of the cpuset. The output format is
+ * a list of CPUs with ranges (for example, "0,1,3-9").
+ */
+char *cpulist_create(char *str, size_t len,
+			cpu_set_t *set, size_t setsize)
+{
+	size_t i;
+	char *ptr = str;
+	int entry_made = 0;
+	size_t max = cpuset_nbits(setsize);
+
+	for (i = 0; i < max; i++) {
+		if (CPU_ISSET_S(i, setsize, set)) {
+			int rlen;
+			size_t j, run = 0;
+			entry_made = 1;
+			for (j = i + 1; j < max; j++) {
+				if (CPU_ISSET_S(j, setsize, set))
+					run++;
+				else
+					break;
+			}
+			if (!run)
+				rlen = snprintf(ptr, len, "%zd,", i);
+			else if (run == 1) {
+				rlen = snprintf(ptr, len, "%zd,%zd,", i, i + 1);
+				i++;
+			} else {
+				rlen = snprintf(ptr, len, "%zd-%zd,", i, i + run);
+				i += run;
+			}
+			if (rlen < 0 || (size_t) rlen + 1 > len)
+				return NULL;
+			ptr += rlen;
+			if (rlen > 0 && len > (size_t) rlen)
+				len -= rlen;
+			else
+				len = 0;
+		}
+	}
+	ptr -= entry_made;
+	*ptr = '\0';
+
+	return str;
+}
+
+/*
+ * Returns string with CPU mask.
+ */
+char *cpumask_create(char *str, size_t len,
+			cpu_set_t *set, size_t setsize)
+{
+	char *ptr = str;
+	char *ret = NULL;
+	int cpu;
+
+	for (cpu = cpuset_nbits(setsize) - 4; cpu >= 0; cpu -= 4) {
+		char val = 0;
+
+		if (len == (size_t) (ptr - str))
+			break;
+
+		if (CPU_ISSET_S(cpu, setsize, set))
+			val |= 1;
+		if (CPU_ISSET_S(cpu + 1, setsize, set))
+			val |= 2;
+		if (CPU_ISSET_S(cpu + 2, setsize, set))
+			val |= 4;
+		if (CPU_ISSET_S(cpu + 3, setsize, set))
+			val |= 8;
+
+		if (!ret && val)
+			ret = ptr;
+		*ptr++ = val_to_char(val);
+	}
+	*ptr = '\0';
+	return ret ? ret : ptr - 1;
+}
+
+/*
+ * Parses string with CPUs mask.
+ */
+int cpumask_parse(const char *str, cpu_set_t *set, size_t setsize)
+{
+	int len = strlen(str);
+	const char *ptr = str + len - 1;
+	int cpu = 0;
+
+	/* skip 0x, it's all hex anyway */
+	if (len > 1 && !memcmp(str, "0x", 2L))
+		str += 2;
+
+	CPU_ZERO_S(setsize, set);
+
+	while (ptr >= str) {
+		char val;
+
+		/* cpu masks in /sys uses comma as a separator */
+		if (*ptr == ',')
+			ptr--;
+
+		val = char_to_val(*ptr);
+		if (val == (char) -1)
+			return -1;
+		if (val & 1)
+			CPU_SET_S(cpu, setsize, set);
+		if (val & 2)
+			CPU_SET_S(cpu + 1, setsize, set);
+		if (val & 4)
+			CPU_SET_S(cpu + 2, setsize, set);
+		if (val & 8)
+			CPU_SET_S(cpu + 3, setsize, set);
+		len--;
+		ptr--;
+		cpu += 4;
+	}
+
+	return 0;
+}
+
+/*
+ * Parses string with list of CPU ranges.
+ * Returns 0 on success.
+ * Returns 1 on error.
+ * Returns 2 if fail is set and a cpu number passed in the list doesn't fit
+ * into the cpu_set. If fail is not set cpu numbers that do not fit are
+ * ignored and 0 is returned instead.
+ */
+int cpulist_parse(const char *str, cpu_set_t *set, size_t setsize, int fail)
+{
+	size_t max = cpuset_nbits(setsize);
+	const char *p, *q;
+	int r = 0;
+
+	q = str;
+	CPU_ZERO_S(setsize, set);
+
+	while (p = q, q = nexttoken(q, ','), p) {
+		unsigned int a;	/* beginning of range */
+		unsigned int b;	/* end of range */
+		unsigned int s;	/* stride */
+		const char *c1, *c2;
+		char c;
+
+		if ((r = sscanf(p, "%u%c", &a, &c)) < 1)
+			return 1;
+		b = a;
+		s = 1;
+
+		c1 = nexttoken(p, '-');
+		c2 = nexttoken(p, ',');
+		if (c1 != NULL && (c2 == NULL || c1 < c2)) {
+			if ((r = sscanf(c1, "%u%c", &b, &c)) < 1)
+				return 1;
+			c1 = nexttoken(c1, ':');
+			if (c1 != NULL && (c2 == NULL || c1 < c2)) {
+				if ((r = sscanf(c1, "%u%c", &s, &c)) < 1)
+					return 1;
+				if (s == 0)
+					return 1;
+			}
+		}
+
+		if (!(a <= b))
+			return 1;
+		while (a <= b) {
+			if (fail && (a >= max))
+				return 2;
+			CPU_SET_S(a, setsize, set);
+			a += s;
+		}
+	}
+
+	if (r == 2)
+		return 1;
+	return 0;
+}
+
+#ifdef TEST_PROGRAM
+
+#include <getopt.h>
+
+int main(int argc, char *argv[])
+{
+	cpu_set_t *set;
+	size_t setsize, buflen, nbits;
+	char *buf, *mask = NULL, *range = NULL;
+	int ncpus = 2048, rc, c;
+
+	static const struct option longopts[] = {
+	    { "ncpus", 1, 0, 'n' },
+	    { "mask",  1, 0, 'm' },
+	    { "range", 1, 0, 'r' },
+	    { NULL,    0, 0, 0 }
+	};
+
+	while ((c = getopt_long(argc, argv, "n:m:r:", longopts, NULL)) != -1) {
+		switch(c) {
+		case 'n':
+			ncpus = atoi(optarg);
+			break;
+		case 'm':
+			mask = strdup(optarg);
+			break;
+		case 'r':
+			range = strdup(optarg);
+			break;
+		default:
+			goto usage_err;
+		}
+	}
+
+	if (!mask && !range)
+		goto usage_err;
+
+	set = cpuset_alloc(ncpus, &setsize, &nbits);
+	if (!set)
+		err(EXIT_FAILURE, "failed to allocate cpu set");
+
+	/*
+	fprintf(stderr, "ncpus: %d, cpuset bits: %zd, cpuset bytes: %zd\n",
+			ncpus, nbits, setsize);
+	*/
+
+	buflen = 7 * nbits;
+	buf = malloc(buflen);
+	if (!buf)
+		err(EXIT_FAILURE, "failed to allocate cpu set buffer");
+
+	if (mask)
+		rc = cpumask_parse(mask, set, setsize);
+	else
+		rc = cpulist_parse(range, set, setsize, 0);
+
+	if (rc)
+		errx(EXIT_FAILURE, "failed to parse string: %s", mask ? : range);
+
+	printf("%-15s = %15s ", mask ? : range,
+				cpumask_create(buf, buflen, set, setsize));
+	printf("[%s]\n", cpulist_create(buf, buflen, set, setsize));
+
+	free(buf);
+	free(range);
+	cpuset_free(set);
+
+	return EXIT_SUCCESS;
+
+usage_err:
+	fprintf(stderr,
+		"usage: %s [--ncpus <num>] --mask <mask> | --range <list>",
+		program_invocation_short_name);
+	exit(EXIT_FAILURE);
+}
+#endif
diff -up util-linux-ng-2.17.2/sys-utils/lscpu.1.lscpu util-linux-ng-2.17.2/sys-utils/lscpu.1
--- util-linux-ng-2.17.2/sys-utils/lscpu.1.lscpu	2010-02-04 12:53:59.000000000 +0100
+++ util-linux-ng-2.17.2/sys-utils/lscpu.1	2012-10-05 17:41:26.612773133 +0200
@@ -1,34 +1,149 @@
 .\" Process this file with
 .\" groff -man -Tascii lscpu.1
 .\"
-.TH LSCPU 1 "JULY 2008" Linux "User Manuals"
+.TH LSCPU 1 "February 2011" "util-linux" "User Commands"
 .SH NAME
-lscpu \- CPU architecture information helper
+lscpu \- display information about the CPU architecture
 .SH SYNOPSIS
 .B lscpu
-.RB [ \-hp ]
+.RB [ \-a | \-b | \-c "] [" \-x "] [" \-s " \fIdirectory\fP] [" \-e " [\fI=list\fP]|" \-p " [\fI=list\fP]]"
+.br
+.B lscpu
+.BR \-h | \-V
 .SH DESCRIPTION
 .B lscpu
-gathers CPU architecture information like number of CPUs, threads,
-cores, sockets, NUMA nodes, information about CPU caches, CPU family,
-model and stepping from sysfs and /proc/cpuinfo, and prints it in
-human-readable format. Alternatively, it can print out in parsable
-format including how different caches are shared by different CPUs,
-which can also be fed to other programs.
+gathers CPU architecture information from sysfs and /proc/cpuinfo. The
+command output can be optimized for parsing or for easy readability by humans.
+.br
+The information includes, for example, the number of CPUs, threads, cores,
+sockets,  and Non-Uniform Memory Access (NUMA) nodes. There is also information
+about the CPU caches and cache sharing, family, model, bogoMIPS, byte order,
+and stepping.
+
+Options that result in an output table have a \fIlist\fP argument. Use this
+argument to customize the command output. Specify a comma-separated list of
+column labels to limit the output table to only the specified columns, arranged
+in the specified order. See \fBCOLUMNS\fP for a list of valid column labels. The
+column labels are not case sensitive.
+
+Not all columns are supported on all architectures. If an unsupported column is
+specified, \fBlscpu\fP prints the column but does not provide any data for it.
+
+.SS COLUMNS
+.TP
+.B CPU
+The logical CPU number of a CPU as used by the Linux kernel.
+.TP
+.B CORE
+The logical core number. A core can contain several CPUs.
+.TP
+.B SOCKET
+The logical socket number. A socket can contain several cores.
+.TP
+.B BOOK
+The logical book number. A book can contain several sockets.
+.TP
+.B NODE
+The logical NUMA node number. A node may contain several books.
+.TP
+.B CACHE
+Information about how caches are shared between CPUs.
+.TP
+.B ADDRESS
+The physical address of a CPU.
+.TP
+.B ONLINE
+Indicator that shows whether the Linux instance currently makes use of the CPU.
+.TP
+.B CONFIGURED
+Indicator that shows if the hypervisor has allocated the CPU to the virtual
+hardware on which the Linux instance runs. CPUs that are configured can be set
+online by the Linux instance.
+This column contains data only if your hardware system and hypervisor support
+dynamic CPU resource allocation.
+.TP
+.B POLARIZATION
+This column contains data for Linux instances that run on virtual hardware with
+a hypervisor that can switch the CPU dispatching mode (polarization). The
+polarization can be:
+.RS
+.TP 12
+.B horizontal\fP
+The workload is spread across all available CPUs.
+.TP 12
+.B vertical
+The workload is concentrated on few CPUs.
+.P
+For vertical polarization, the column also shows the degree of concentration,
+high, medium, or low. This column contains data only if your hardware system
+and hypervisor support CPU polarization.
+.RE
 .SH OPTIONS
 .TP
+.BR \-a , " \-\-all"
+Include lines for online and offline CPUs in the output (default for -e). This
+option may only specified together with option -e or -p.
+.TP
+.BR \-b , " \-\-online"
+Limit the output to online CPUs (default for -p). This option may only
+be specified together with option -e or -p.
+.TP
+.BR \-c , " \-\-offline"
+Limit the output to offline CPUs. This option may only be specified together
+with option -e or -p.
+.TP
+.BR \-e , " \-\-extended " \fI[=list]\fP
+Display the CPU information in human readable format.
+
+If the \fIlist\fP argument is omitted, all columns for which data is available
+are included in the command output.
+
+When specifying the \fIlist\fP argument, the string of option, equal sign (=), and
+\fIlist\fP must not contain any blanks or other white space.
+Examples: '\fB-e=cpu,node\fP' or '\fB--extended=cpu,node\fP'.
+.TP
 .BR \-h , " \-\-help"
-Print a help message.
+Display help information and exit.
 .TP
-.BR \-p , " \-\-parse"
-Print out in parsable instead of printable format.
+.BR \-p , " \-\-parse " \fI[=list]\fP
+Optimize the command output for easy parsing.
+
+If the \fIlist\fP argument is omitted, the command output is compatible with earlier
+versions of \fBlscpu\fP. In this compatible format, two commas are used to separate
+CPU cache columns. If no CPU caches are identified the cache column is omitted.
+.br
+If the \fIlist\fP argument is used, cache columns are separated with a colon (:).
+
+When specifying the \fIlist\fP argument, the string of option, equal sign (=), and
+\fIlist\fP must not contain any blanks or other white space.
+Examples: '\fB-p=cpu,node\fP' or '\fB--parse=cpu,node\fP'.
+.TP
+.BR \-s , " \-\-sysroot " \fIdirectory\fP
+Gather CPU data for a Linux instance other than the instance from which the
+\fBlscpu\fP command is issued. The specified \fIdirectory\fP is the system root
+of the Linux instance to be inspected.
+.TP
+.BR \-x , " \-\-hex"
+Use hexadecimal masks for CPU sets (for example 0x3).  The default is to print
+the sets in list format (for example 0,1).
+.TP
+.BR \-V , " \-\-version"
+Display version information and exit.
 .SH BUGS
-The program at the moment does not handle the system installed with
-different types of physical processors.
+The basic overview about CPU family, model, etc. is always based on the first
+CPU only.
+
+Sometimes in Xen Dom0 the kernel reports wrong data.
 
-Sometimes in Xen Dom0 kernel reports wrong data.
+On virtual hardware the number of cores per socket, etc. can be wrong.
 .SH AUTHOR
+.nf
 Cai Qian <qcai@redhat.com>
+Karel Zak <kzak@redhat.com>
+Heiko Carstens <heiko.carstens@de.ibm.com>
+.fi
+.SH "SEE ALSO"
+.BR chcpu (8)
 .SH AVAILABILITY
-The setarch command is part of the util-linux-ng package and is available from
-ftp://ftp.kernel.org/pub/linux/utils/util-linux-ng/.
+The lscpu command is part of the util-linux package and is available from
+ftp://ftp.kernel.org/pub/linux/utils/util-linux/.
diff -up util-linux-ng-2.17.2/sys-utils/lscpu.c.lscpu util-linux-ng-2.17.2/sys-utils/lscpu.c
--- util-linux-ng-2.17.2/sys-utils/lscpu.c.lscpu	2010-03-18 23:11:23.000000000 +0100
+++ util-linux-ng-2.17.2/sys-utils/lscpu.c	2012-10-05 17:41:26.613773139 +0200
@@ -4,23 +4,23 @@
  * Copyright (C) 2008 Cai Qian <qcai@redhat.com>
  * Copyright (C) 2008 Karel Zak <kzak@redhat.com>
  *
- * This program is free software: you can redistribute it and/or modify
+ * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
+ * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  *
- * This program is distributed in the hope that it will be useful,
+ * This program is distributed in the hope that it would be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  */
 
 #include <ctype.h>
 #include <dirent.h>
-#include <err.h>
 #include <errno.h>
 #include <fcntl.h>
 #include <getopt.h>
@@ -30,29 +30,29 @@
 #include <sys/utsname.h>
 #include <unistd.h>
 #include <stdarg.h>
+#include <sys/types.h>
+#include <sys/stat.h>
 
+#include "cpuset.h"
 #include "nls.h"
+#include "xalloc.h"
+#include "c.h"
+#include "strutils.h"
+#include "bitops.h"
+#include "tt.h"
+#include "path.h"
+#include "optutils.h"
 
 #define CACHE_MAX 100
 
 /* /sys paths */
-#define _PATH_SYS_SYSTEM	"sys/devices/system"
-#define _PATH_SYS_CPU0		_PATH_SYS_SYSTEM "/cpu/cpu0"
-#define _PATH_PROC_XEN		"proc/xen"
+#define _PATH_SYS_SYSTEM	"/sys/devices/system"
+#define _PATH_SYS_CPU		_PATH_SYS_SYSTEM "/cpu"
+#define _PATH_PROC_XEN		"/proc/xen"
 #define _PATH_PROC_XENCAP	_PATH_PROC_XEN "/capabilities"
-#define _PATH_PROC_CPUINFO	"proc/cpuinfo"
-#define _PATH_PROC_PCIDEVS	"proc/bus/pci/devices"
-
-int have_topology;
-int have_cache;
-int have_node;
-
-/* cache(s) description */
-struct ca_desc {
-	char	*caname;
-	char	*casize;
-	int	camap;
-};
+#define _PATH_PROC_CPUINFO	"/proc/cpuinfo"
+#define _PATH_PROC_PCIDEVS	"/proc/bus/pci/devices"
+#define _PATH_PROC_SYSINFO	"/proc/sysinfo"
 
 /* virtualization types */
 enum {
@@ -71,147 +71,193 @@ enum {
 	HYPER_NONE	= 0,
 	HYPER_XEN,
 	HYPER_KVM,
-	HYPER_MSHV
+	HYPER_MSHV,
+	HYPER_VMWARE,
+	HYPER_IBM
 };
 const char *hv_vendors[] = {
 	[HYPER_NONE]	= NULL,
 	[HYPER_XEN]	= "Xen",
 	[HYPER_KVM]	= "KVM",
-	[HYPER_MSHV]	= "Microsoft"
+	[HYPER_MSHV]	= "Microsoft",
+	[HYPER_VMWARE]  = "VMware",
+	[HYPER_IBM]	= "IBM"
 };
 
-/* CPU modes (bits) */
+/* CPU modes */
 enum {
-	MODE_REAL	= (1 << 1),
-	MODE_TRANSPARENT = (1 << 2),
-	MODE_LONG	= (1 << 3)
-};
-
-/* CPU(s) description */
-struct cpu_desc {
-	/* counters */
-	int	ct_cpu;
-	int	ct_thread;
-	int	ct_core;
-	int	ct_socket;
-	int	ct_node;
-	int	ct_cache;
+	MODE_32BIT	= (1 << 1),
+	MODE_64BIT	= (1 << 2)
+};
+
+/* cache(s) description */
+struct cpu_cache {
+	char		*name;
+	char		*size;
 
-	/* who is who */
+	int		nsharedmaps;
+	cpu_set_t	**sharedmaps;
+};
+
+/* dispatching modes */
+enum {
+	DISP_HORIZONTAL = 0,
+	DISP_VERTICAL	= 1
+};
+
+const char *disp_modes[] = {
+	[DISP_HORIZONTAL]	= N_("horizontal"),
+	[DISP_VERTICAL]		= N_("vertical")
+};
+
+/* cpu polarization */
+enum {
+	POLAR_UNKNOWN	= 0,
+	POLAR_VLOW,
+	POLAR_VMEDIUM,
+	POLAR_VHIGH,
+	POLAR_HORIZONTAL
+};
+
+struct polarization_modes {
+	char *parsable;
+	char *readable;
+};
+
+struct polarization_modes polar_modes[] = {
+	[POLAR_UNKNOWN]	   = {"U",  "-"},
+	[POLAR_VLOW]	   = {"VL", "vert-low"},
+	[POLAR_VMEDIUM]	   = {"VM", "vert-medium"},
+	[POLAR_VHIGH]	   = {"VH", "vert-high"},
+	[POLAR_HORIZONTAL] = {"H",  "horizontal"},
+};
+
+/* global description */
+struct lscpu_desc {
 	char	*arch;
 	char	*vendor;
 	char	*family;
 	char	*model;
 	char	*virtflag;	/* virtualization flag (vmx, svm) */
+	char	*hypervisor;	/* hypervisor software */
 	int	hyper;		/* hypervisor vendor ID */
 	int	virtype;	/* VIRT_PARA|FULL|NONE ? */
-
-	/* caches */
-	struct ca_desc	cache[CACHE_MAX];
-
-	/* misc */
 	char	*mhz;
 	char	*stepping;
+	char    *bogomips;
 	char	*flags;
-
+	int	dispatching;	/* none, horizontal or vertical */
 	int	mode;		/* rm, lm or/and tm */
 
-	/* NUMA */
-	int	*nodecpu;
-};
+	int		ncpus;		/* number of CPUs */
+	cpu_set_t	*online;	/* mask with online CPUs */
 
-char pathbuf[PATH_MAX] = "/";
+	int		nnodes;		/* number of NUMA modes */
+	cpu_set_t	**nodemaps;	/* array with NUMA nodes */
 
-static void path_scanstr(char *result, const char *path, ...)
-		__attribute__ ((__format__ (__printf__, 2, 3)));
-static int path_exist(const char *path, ...)
-		__attribute__ ((__format__ (__printf__, 1, 2)));
-static int path_sibling(const char *path, ...)
-		__attribute__ ((__format__ (__printf__, 1, 2)));
+	/* books -- based on book_siblings (internal kernel map of cpuX's
+	 * hardware threads within the same book */
+	int		nbooks;		/* number of all online books */
+	cpu_set_t	**bookmaps;	/* unique book_siblings */
+
+	/* sockets -- based on core_siblings (internal kernel map of cpuX's
+	 * hardware threads within the same physical_package_id (socket)) */
+	int		nsockets;	/* number of all online sockets */
+	cpu_set_t	**socketmaps;	/* unique core_siblings */
+
+	/* cores -- based on thread_siblings (internel kernel map of cpuX's
+	 * hardware threads within the same core as cpuX) */
+	int		ncores;		/* number of all online cores */
+	cpu_set_t	**coremaps;	/* unique thread_siblings */
+
+	int		nthreads;	/* number of online threads */
+
+	int		ncaches;
+	struct cpu_cache *caches;
+
+	int		*polarization;	/* cpu polarization */
+	int		*addresses;	/* physical cpu addresses */
+	int		*configured;	/* cpu configured */
+};
 
-static FILE *
-xfopen(const char *path, const char *mode)
-{
-	FILE *fd = fopen(path, mode);
-	if (!fd)
-		err(EXIT_FAILURE, _("error: %s"), path);
-	return fd;
-}
+enum {
+	OUTPUT_SUMMARY	= 0,	/* default */
+	OUTPUT_PARSABLE,	/* -p */
+	OUTPUT_READABLE,	/* -e */
+};
 
-static FILE *
-path_vfopen(const char *mode, const char *path, va_list ap)
-{
-	vsnprintf(pathbuf, sizeof(pathbuf), path, ap);
-	return xfopen(pathbuf, mode);
-}
+enum {
+	SYSTEM_LIVE = 0,	/* analyzing a live system */
+	SYSTEM_SNAPSHOT,	/* analyzing a snapshot of a different system */
+};
 
-static void
-path_scanstr(char *result, const char *path, ...)
-{
-	FILE *fd;
-	va_list ap;
+struct lscpu_modifier {
+	int		mode;		/* OUTPUT_* */
+	int		system;		/* SYSTEM_* */
+	unsigned int	hex:1,		/* print CPU masks rather than CPU lists */
+			compat:1,	/* use backwardly compatible format */
+			online:1,	/* print online CPUs */
+			offline:1;	/* print offline CPUs */
+};
 
-	va_start(ap, path);
-	fd = path_vfopen("r", path, ap);
-	va_end(ap);
+static int maxcpus;		/* size in bits of kernel cpu mask */
 
-	if (fscanf(fd, "%s", result) != 1) {
-		if (ferror(fd))
-			err(EXIT_FAILURE, _("error: %s"), pathbuf);
-		else
-			errx(EXIT_FAILURE, _("error parse: %s"), pathbuf);
-	}
-	fclose(fd);
-}
+#define is_cpu_online(_d, _cpu) \
+		((_d) && (_d)->online ? \
+			CPU_ISSET_S((_cpu), CPU_ALLOC_SIZE(maxcpus), (_d)->online) : 0)
 
-static int
-path_exist(const char *path, ...)
-{
-	va_list ap;
+/*
+ * IDs
+ */
+enum {
+	COL_CPU,
+	COL_CORE,
+	COL_SOCKET,
+	COL_NODE,
+	COL_BOOK,
+	COL_CACHE,
+	COL_POLARIZATION,
+	COL_ADDRESS,
+	COL_CONFIGURED,
+	COL_ONLINE,
+};
 
-	va_start(ap, path);
-	vsnprintf(pathbuf, sizeof(pathbuf), path, ap);
-	va_end(ap);
+/* column description
+ */
+struct lscpu_coldesc {
+	const char *name;
+	const char *help;
 
-	return access(pathbuf, F_OK) == 0;
-}
+	unsigned int  is_abbr:1;	/* name is abbreviation */
+};
 
-char *
-xstrdup(const char *str)
+static struct lscpu_coldesc coldescs[] =
 {
-	char *s = strdup(str);
-	if (!s)
-		err(EXIT_FAILURE, _("error: strdup failed"));
-	return s;
-}
+	[COL_CPU]          = { "CPU", N_("logical CPU number"), 1 },
+	[COL_CORE]         = { "CORE", N_("logical core number") },
+	[COL_SOCKET]       = { "SOCKET", N_("logical socket number") },
+	[COL_NODE]         = { "NODE", N_("logical NUMA node number") },
+	[COL_BOOK]         = { "BOOK", N_("logical book number") },
+	[COL_CACHE]        = { "CACHE", N_("shows how caches are shared between CPUs") },
+	[COL_POLARIZATION] = { "POLARIZATION", N_("CPU dispatching mode on virtual hardware") },
+	[COL_ADDRESS]      = { "ADDRESS", N_("physical address of a CPU") },
+	[COL_CONFIGURED]   = { "CONFIGURED", N_("shows if the hypervisor has allocated the CPU") },
+	[COL_ONLINE]       = { "ONLINE", N_("shows if Linux currently makes use of the CPU") }
+};
 
-/* count the set bit in a mapping file */
 static int
-path_sibling(const char *path, ...)
+column_name_to_id(const char *name, size_t namesz)
 {
-	int c, n;
-	int result = 0;
-	char s[2];
-	FILE *fp;
-	va_list ap;
-
-	va_start(ap, path);
-	fp = path_vfopen("r", path, ap);
-	va_end(ap);
-
-	while ((c = fgetc(fp)) != EOF) {
-		if (isxdigit(c)) {
-			s[0] = c;
-			s[1] = '\0';
-			for (n = strtol(s, NULL, 16); n > 0; n /= 2) {
-				if (n % 2)
-					result++;
-			}
-		}
-	}
-	fclose(fp);
+	size_t i;
 
-	return result;
+	for (i = 0; i < ARRAY_SIZE(coldescs); i++) {
+		const char *cn = coldescs[i].name;
+
+		if (!strncasecmp(name, cn, namesz) && !*(cn + namesz))
+			return i;
+	}
+	warnx(_("unknown column: %s"), name);
+	return -1;
 }
 
 /* Lookup a pattern and get the value from cpuinfo.
@@ -219,7 +265,8 @@ path_sibling(const char *path, ...)
  *
  *	"<pattern>   : <key>"
  */
-int lookup(char *line, char *pattern, char **value)
+static int
+lookup(char *line, char *pattern, char **value)
 {
 	char *p, *v;
 	int len = strlen(pattern);
@@ -255,64 +302,118 @@ int lookup(char *line, char *pattern, ch
 	return 1;
 }
 
+/* Don't init the mode for platforms where we are not able to
+ * detect that CPU supports 64-bit mode.
+ */
+static int
+init_mode(struct lscpu_modifier *mod)
+{
+	int m = 0;
+
+	if (mod->system == SYSTEM_SNAPSHOT)
+		/* reading info from any /{sys,proc} dump, don't mix it with
+		 * information about our real CPU */
+		return 0;
+
+#if defined(__alpha__) || defined(__ia64__)
+	m |= MODE_64BIT;	/* 64bit platforms only */
+#endif
+	/* platforms with 64bit flag in /proc/cpuinfo, define
+	 * 32bit default here */
+#if defined(__i386__) || defined(__x86_64__) || \
+    defined(__s390x__) || defined(__s390__) || defined(__sparc_v9__)
+	m |= MODE_32BIT;
+#endif
+	return m;
+}
+
 static void
-read_basicinfo(struct cpu_desc *cpu)
+read_basicinfo(struct lscpu_desc *desc, struct lscpu_modifier *mod)
 {
-	FILE *fp = xfopen(_PATH_PROC_CPUINFO, "r");
+	FILE *fp = path_fopen("r", 1, _PATH_PROC_CPUINFO);
 	char buf[BUFSIZ];
 	struct utsname utsbuf;
 
 	/* architecture */
 	if (uname(&utsbuf) == -1)
 		err(EXIT_FAILURE, _("error: uname failed"));
-	cpu->arch = xstrdup(utsbuf.machine);
+	desc->arch = xstrdup(utsbuf.machine);
 
 	/* count CPU(s) */
-	while(path_exist(_PATH_SYS_SYSTEM "/cpu/cpu%d", cpu->ct_cpu))
-		cpu->ct_cpu++;
+	while(path_exist(_PATH_SYS_SYSTEM "/cpu/cpu%d", desc->ncpus))
+		desc->ncpus++;
 
 	/* details */
 	while (fgets(buf, sizeof(buf), fp) != NULL) {
-		/* IA64 */
-		if (lookup(buf, "vendor", &cpu->vendor)) ;
-		else if (lookup(buf, "vendor_id", &cpu->vendor)) ;
-		/* IA64 */
-		else if (lookup(buf, "family", &cpu->family)) ;
-		else if (lookup(buf, "cpu family", &cpu->family)) ;
-		else if (lookup(buf, "model", &cpu->model)) ;
-		else if (lookup(buf, "stepping", &cpu->stepping)) ;
-		else if (lookup(buf, "cpu MHz", &cpu->mhz)) ;
-		else if (lookup(buf, "flags", &cpu->flags)) ;
+		if (lookup(buf, "vendor", &desc->vendor)) ;
+		else if (lookup(buf, "vendor_id", &desc->vendor)) ;
+		else if (lookup(buf, "family", &desc->family)) ;
+		else if (lookup(buf, "cpu family", &desc->family)) ;
+		else if (lookup(buf, "model", &desc->model)) ;
+		else if (lookup(buf, "stepping", &desc->stepping)) ;
+		else if (lookup(buf, "cpu MHz", &desc->mhz)) ;
+		else if (lookup(buf, "flags", &desc->flags)) ;		/* x86 */
+		else if (lookup(buf, "features", &desc->flags)) ;	/* s390 */
+		else if (lookup(buf, "type", &desc->flags)) ;		/* sparc64 */
+		else if (lookup(buf, "bogomips", &desc->bogomips)) ;
+		else if (lookup(buf, "bogomips per cpu", &desc->bogomips)) ; /* s390 */
 		else
 			continue;
 	}
 
-	if (cpu->flags) {
-		snprintf(buf, sizeof(buf), " %s ", cpu->flags);
+	desc->mode = init_mode(mod);
+
+	if (desc->flags) {
+		snprintf(buf, sizeof(buf), " %s ", desc->flags);
 		if (strstr(buf, " svm "))
-			cpu->virtflag = strdup("svm");
+			desc->virtflag = xstrdup("svm");
 		else if (strstr(buf, " vmx "))
-			cpu->virtflag = strdup("vmx");
-
-		if (strstr(buf, " rm "))
-			cpu->mode |= MODE_REAL;
-		if (strstr(buf, " tm "))
-			cpu->mode |= MODE_TRANSPARENT;
+			desc->virtflag = xstrdup("vmx");
 		if (strstr(buf, " lm "))
-			cpu->mode |= MODE_LONG;
+			desc->mode |= MODE_32BIT | MODE_64BIT;		/* x86_64 */
+		if (strstr(buf, " zarch "))
+			desc->mode |= MODE_32BIT | MODE_64BIT;		/* s390x */
+		if (strstr(buf, " sun4v ") || strstr(buf, " sun4u "))
+			desc->mode |= MODE_32BIT | MODE_64BIT;		/* sparc64 */
 	}
 
 	fclose(fp);
+
+	if (path_exist(_PATH_SYS_SYSTEM "/cpu/kernel_max"))
+		/* note that kernel_max is maximum index [NR_CPUS-1] */
+		maxcpus = path_getnum(_PATH_SYS_SYSTEM "/cpu/kernel_max") + 1;
+
+	else if (mod->system == SYSTEM_LIVE)
+		/* the root is '/' so we are working with data from the current kernel */
+		maxcpus = get_max_number_of_cpus();
+
+	if (maxcpus <= 0)
+		/* error or we are reading some /sys snapshot instead of the
+		 * real /sys, let's use any crazy number... */
+		maxcpus = desc->ncpus > 2048 ? desc->ncpus : 2048;
+
+	/* get mask for online CPUs */
+	if (path_exist(_PATH_SYS_SYSTEM "/cpu/online")) {
+		size_t setsize = CPU_ALLOC_SIZE(maxcpus);
+		desc->online = path_cpulist(maxcpus, _PATH_SYS_SYSTEM "/cpu/online");
+		desc->nthreads = CPU_COUNT_S(setsize, desc->online);
+	}
+
+	/* get dispatching mode */
+	if (path_exist(_PATH_SYS_SYSTEM "/cpu/dispatching"))
+		desc->dispatching = path_getnum(_PATH_SYS_SYSTEM "/cpu/dispatching");
+	else
+		desc->dispatching = -1;
 }
 
 static int
-has_pci_device(int vendor, int device)
+has_pci_device(unsigned int vendor, unsigned int device)
 {
 	FILE *f;
-	int num, fn, ven, dev;
+	unsigned int num, fn, ven, dev;
 	int res = 1;
 
-	f = fopen(_PATH_PROC_PCIDEVS, "r");
+	f = path_fopen("r", 0, _PATH_PROC_PCIDEVS);
 	if (!f)
 		return 0;
 
@@ -364,7 +465,7 @@ cpuid(unsigned int op, unsigned int *eax
 }
 
 static void
-read_hypervisor_cpuid(struct cpu_desc *cpu)
+read_hypervisor_cpuid(struct lscpu_desc *desc)
 {
 	unsigned int eax = 0, ebx = 0, ecx = 0, edx = 0;
 	char hyper_vendor_id[13];
@@ -381,32 +482,34 @@ read_hypervisor_cpuid(struct cpu_desc *c
 		return;
 
 	if (!strncmp("XenVMMXenVMM", hyper_vendor_id, 12))
-		cpu->hyper = HYPER_XEN;
+		desc->hyper = HYPER_XEN;
 	else if (!strncmp("KVMKVMKVM", hyper_vendor_id, 9))
-		cpu->hyper = HYPER_KVM;
+		desc->hyper = HYPER_KVM;
 	else if (!strncmp("Microsoft Hv", hyper_vendor_id, 12))
-		cpu->hyper = HYPER_MSHV;
+		desc->hyper = HYPER_MSHV;
+	else if (!strncmp("VMwareVMware", hyper_vendor_id, 12))
+		desc->hyper = HYPER_VMWARE;
 }
 
 #else	/* ! __x86_64__ */
 static void
-read_hypervisor_cpuid(struct cpu_desc *cpu)
+read_hypervisor_cpuid(struct lscpu_desc *desc)
 {
 }
 #endif
 
 static void
-read_hypervisor(struct cpu_desc *cpu)
+read_hypervisor(struct lscpu_desc *desc)
 {
-	read_hypervisor_cpuid(cpu);
+	read_hypervisor_cpuid(desc);
 
-	if (cpu->hyper)
+	if (desc->hyper)
 		/* hvm */
-		cpu->virtype = VIRT_FULL;
+		desc->virtype = VIRT_FULL;
 
-	else if (!access(_PATH_PROC_XEN, F_OK)) {
+	else if (path_exist(_PATH_PROC_XEN)) {
 		/* Xen para-virt or dom0 */
-		FILE *fd = fopen(_PATH_PROC_XENCAP, "r");
+		FILE *fd = path_fopen("r", 0, _PATH_PROC_XENCAP);
 		int dom0 = 0;
 
 		if (fd) {
@@ -417,328 +520,879 @@ read_hypervisor(struct cpu_desc *cpu)
 				dom0 = 1;
 			fclose(fd);
 		}
-		cpu->virtype = dom0 ? VIRT_NONE : VIRT_PARA;
-		cpu->hyper = HYPER_XEN;
+		desc->virtype = dom0 ? VIRT_NONE : VIRT_PARA;
+		desc->hyper = HYPER_XEN;
 
 	} else if (has_pci_device(0x5853, 0x0001)) {
 		/* Xen full-virt on non-x86_64 */
-		cpu->hyper = HYPER_XEN;
-		cpu->virtype = VIRT_FULL;
+		desc->hyper = HYPER_XEN;
+		desc->virtype = VIRT_FULL;
+	} else if (path_exist(_PATH_PROC_SYSINFO)) {
+		FILE *fd = path_fopen("r", 0, _PATH_PROC_SYSINFO);
+		char buf[BUFSIZ];
+
+		desc->hyper = HYPER_IBM;
+		desc->hypervisor = "PR/SM";
+		desc->virtype = VIRT_FULL;
+		while (fgets(buf, sizeof(buf), fd) != NULL) {
+			char *str;
+
+			if (!strstr(buf, "Control Program:"))
+				continue;
+			if (!strstr(buf, "KVM"))
+				desc->hyper = HYPER_IBM;
+			else
+				desc->hyper = HYPER_KVM;
+			str = strchr(buf, ':');
+			if (!str)
+				continue;
+			if (xasprintf(&str, "%s", str + 1) == -1)
+				errx(EXIT_FAILURE, _("failed to allocate memory"));
+			/* remove leading, trailing and repeating whitespace */
+			while (*str == ' ')
+				str++;
+			desc->hypervisor = str;
+			str += strlen(str) - 1;
+			while ((*str == '\n') || (*str == ' '))
+				*(str--) = '\0';
+			while ((str = strstr(desc->hypervisor, "  ")))
+				memmove(str, str + 1, strlen(str));
+		}
+		fclose(fd);
+	}
+}
+
+/* add @set to the @ary, unnecessary set is deallocated. */
+static int add_cpuset_to_array(cpu_set_t **ary, int *items, cpu_set_t *set)
+{
+	int i;
+	size_t setsize = CPU_ALLOC_SIZE(maxcpus);
+
+	if (!ary)
+		return -1;
+
+	for (i = 0; i < *items; i++) {
+		if (CPU_EQUAL_S(setsize, set, ary[i]))
+			break;
 	}
+	if (i == *items) {
+		ary[*items] = set;
+		++*items;
+		return 0;
+	}
+	CPU_FREE(set);
+	return 1;
 }
 
 static void
-read_topology(struct cpu_desc *cpu)
+read_topology(struct lscpu_desc *desc, int num)
 {
-	/* number of threads */
-	cpu->ct_thread = path_sibling(
-				_PATH_SYS_CPU0 "/topology/thread_siblings");
+	cpu_set_t *thread_siblings, *core_siblings, *book_siblings;
 
-	/* number of cores */
-	cpu->ct_core = path_sibling(
-				_PATH_SYS_CPU0 "/topology/core_siblings")
-			/ cpu->ct_thread;
+	if (!path_exist(_PATH_SYS_CPU "/cpu%d/topology/thread_siblings", num))
+		return;
 
-	/* number of sockets */
-	cpu->ct_socket = cpu->ct_cpu / cpu->ct_core / cpu->ct_thread;
+	thread_siblings = path_cpuset(maxcpus, _PATH_SYS_CPU
+					"/cpu%d/topology/thread_siblings", num);
+	core_siblings = path_cpuset(maxcpus, _PATH_SYS_CPU
+					"/cpu%d/topology/core_siblings", num);
+	book_siblings = NULL;
+	if (path_exist(_PATH_SYS_CPU "/cpu%d/topology/book_siblings", num)) {
+		book_siblings = path_cpuset(maxcpus, _PATH_SYS_CPU
+					    "/cpu%d/topology/book_siblings", num);
+	}
+
+	if (!desc->coremaps) {
+		int nbooks, nsockets, ncores, nthreads;
+		size_t setsize = CPU_ALLOC_SIZE(maxcpus);
+
+		/* threads within one core */
+		nthreads = CPU_COUNT_S(setsize, thread_siblings);
+		/* cores within one socket */
+		ncores = CPU_COUNT_S(setsize, core_siblings) / nthreads;
+		/* number of sockets within one book.
+		 * Because of odd / non-present cpu maps and to keep
+		 * calculation easy we make sure that nsockets and
+		 * nbooks is at least 1.
+		 */
+		nsockets = desc->ncpus / nthreads / ncores ?: 1;
+		/* number of books */
+		nbooks = desc->ncpus / nthreads / ncores / nsockets ?: 1;
+
+		/* all threads, see also read_basicinfo()
+		 * -- fallback for kernels without
+		 *    /sys/devices/system/cpu/online.
+		 */
+		if (!desc->nthreads)
+			desc->nthreads = nbooks * nsockets * ncores * nthreads;
+		/* For each map we make sure that it can have up to ncpus
+		 * entries. This is because we cannot reliably calculate the
+		 * number of cores, sockets and books on all architectures.
+		 * E.g. completely virtualized architectures like s390 may
+		 * have multiple sockets of different sizes.
+		 */
+		desc->coremaps = xcalloc(desc->ncpus, sizeof(cpu_set_t *));
+		desc->socketmaps = xcalloc(desc->ncpus, sizeof(cpu_set_t *));
+		if (book_siblings)
+			desc->bookmaps = xcalloc(desc->ncpus, sizeof(cpu_set_t *));
+	}
+
+	add_cpuset_to_array(desc->socketmaps, &desc->nsockets, core_siblings);
+	add_cpuset_to_array(desc->coremaps, &desc->ncores, thread_siblings);
+	if (book_siblings)
+		add_cpuset_to_array(desc->bookmaps, &desc->nbooks, book_siblings);
+}
+static void
+read_polarization(struct lscpu_desc *desc, int num)
+{
+	char mode[64];
+
+	if (desc->dispatching < 0)
+		return;
+	if (!path_exist(_PATH_SYS_CPU "/cpu%d/polarization", num))
+		return;
+	if (!desc->polarization)
+		desc->polarization = xcalloc(desc->ncpus, sizeof(int));
+	path_getstr(mode, sizeof(mode), _PATH_SYS_CPU "/cpu%d/polarization", num);
+	if (strncmp(mode, "vertical:low", sizeof(mode)) == 0)
+		desc->polarization[num] = POLAR_VLOW;
+	else if (strncmp(mode, "vertical:medium", sizeof(mode)) == 0)
+		desc->polarization[num] = POLAR_VMEDIUM;
+	else if (strncmp(mode, "vertical:high", sizeof(mode)) == 0)
+		desc->polarization[num] = POLAR_VHIGH;
+	else if (strncmp(mode, "horizontal", sizeof(mode)) == 0)
+		desc->polarization[num] = POLAR_HORIZONTAL;
+	else
+		desc->polarization[num] = POLAR_UNKNOWN;
+}
+
+static void
+read_address(struct lscpu_desc *desc, int num)
+{
+	if (!path_exist(_PATH_SYS_CPU "/cpu%d/address", num))
+		return;
+	if (!desc->addresses)
+		desc->addresses = xcalloc(desc->ncpus, sizeof(int));
+	desc->addresses[num] = path_getnum(_PATH_SYS_CPU "/cpu%d/address", num);
+}
+
+static void
+read_configured(struct lscpu_desc *desc, int num)
+{
+	if (!path_exist(_PATH_SYS_CPU "/cpu%d/configure", num))
+		return;
+	if (!desc->configured)
+		desc->configured = xcalloc(desc->ncpus, sizeof(int));
+	desc->configured[num] = path_getnum(_PATH_SYS_CPU "/cpu%d/configure", num);
+}
+
+static int
+cachecmp(const void *a, const void *b)
+{
+	struct cpu_cache *c1 = (struct cpu_cache *) a;
+	struct cpu_cache *c2 = (struct cpu_cache *) b;
+
+	return strcmp(c2->name, c1->name);
 }
 
 static void
-read_cache(struct cpu_desc *cpu)
+read_cache(struct lscpu_desc *desc, int num)
 {
 	char buf[256];
-	DIR *dp;
-	struct dirent *dir;
-	int level, type;
-
-	dp = opendir(_PATH_SYS_CPU0 "/cache");
-	if (dp == NULL)
-		err(EXIT_FAILURE, _("error: %s"), _PATH_SYS_CPU0 "/cache");
-
-	while ((dir = readdir(dp)) != NULL) {
-		if (!strcmp(dir->d_name, ".")
-		    || !strcmp(dir->d_name, ".."))
-			continue;
+	int i;
 
-		/* cache type */
-		path_scanstr(buf, _PATH_SYS_CPU0 "/cache/%s/type", dir->d_name);
-		if (!strcmp(buf, "Data"))
-			type = 'd';
-		else if (!strcmp(buf, "Instruction"))
-			type = 'i';
-		else
-			type = 0;
+	if (!desc->ncaches) {
+		while(path_exist(_PATH_SYS_SYSTEM "/cpu/cpu%d/cache/index%d",
+					num, desc->ncaches))
+			desc->ncaches++;
 
-		/* cache level */
-		path_scanstr(buf, _PATH_SYS_CPU0 "/cache/%s/level", dir->d_name);
-		level = atoi(buf);
+		if (!desc->ncaches)
+			return;
 
-		if (type)
-			snprintf(buf, sizeof(buf), "L%d%c", level, type);
-		else
-			snprintf(buf, sizeof(buf), "L%d", level);
+		desc->caches = xcalloc(desc->ncaches, sizeof(*desc->caches));
+	}
+	for (i = 0; i < desc->ncaches; i++) {
+		struct cpu_cache *ca = &desc->caches[i];
+		cpu_set_t *map;
 
-		cpu->cache[cpu->ct_cache].caname = xstrdup(buf);
+		if (!path_exist(_PATH_SYS_SYSTEM "/cpu/cpu%d/cache/index%d",
+				num, i))
+			continue;
+		if (!ca->name) {
+			int type, level;
 
-		/* cache size */
-		path_scanstr(buf, _PATH_SYS_CPU0 "/cache/%s/size", dir->d_name);
-		cpu->cache[cpu->ct_cache].casize = xstrdup(buf);
+			/* cache type */
+			path_getstr(buf, sizeof(buf),
+					_PATH_SYS_CPU "/cpu%d/cache/index%d/type",
+					num, i);
+			if (!strcmp(buf, "Data"))
+				type = 'd';
+			else if (!strcmp(buf, "Instruction"))
+				type = 'i';
+			else
+				type = 0;
+
+			/* cache level */
+			level = path_getnum(_PATH_SYS_CPU "/cpu%d/cache/index%d/level",
+					num, i);
+			if (type)
+				snprintf(buf, sizeof(buf), "L%d%c", level, type);
+			else
+				snprintf(buf, sizeof(buf), "L%d", level);
+
+			ca->name = xstrdup(buf);
+
+			/* cache size */
+			path_getstr(buf, sizeof(buf),
+					_PATH_SYS_CPU "/cpu%d/cache/index%d/size",
+					num, i);
+			ca->size = xstrdup(buf);
+		}
 
 		/* information about how CPUs share different caches */
-		cpu->cache[cpu->ct_cache].camap = path_sibling(
-				_PATH_SYS_CPU0 "/cache/%s/shared_cpu_map",
-				dir->d_name);
-		cpu->ct_cache++;
+		map = path_cpuset(maxcpus,
+				  _PATH_SYS_CPU "/cpu%d/cache/index%d/shared_cpu_map",
+				  num, i);
+
+		if (!ca->sharedmaps)
+			ca->sharedmaps = xcalloc(desc->ncpus, sizeof(cpu_set_t *));
+		add_cpuset_to_array(ca->sharedmaps, &ca->nsharedmaps, map);
 	}
 }
 
 static void
-read_nodes(struct cpu_desc *cpu)
+read_nodes(struct lscpu_desc *desc)
 {
 	int i;
 
 	/* number of NUMA node */
-	while (path_exist(_PATH_SYS_SYSTEM "/node/node%d", cpu->ct_node))
-		cpu->ct_node++;
+	while (path_exist(_PATH_SYS_SYSTEM "/node/node%d", desc->nnodes))
+		desc->nnodes++;
+
+	if (!desc->nnodes)
+		return;
 
-	cpu->nodecpu = (int *) malloc(cpu->ct_node * sizeof(int));
-	if (!cpu->nodecpu)
-		err(EXIT_FAILURE, _("error: malloc failed"));
+	desc->nodemaps = xcalloc(desc->nnodes, sizeof(cpu_set_t *));
 
 	/* information about how nodes share different CPUs */
-	for (i = 0; i < cpu->ct_node; i++)
-		cpu->nodecpu[i] = path_sibling(
+	for (i = 0; i < desc->nnodes; i++)
+		desc->nodemaps[i] = path_cpuset(maxcpus,
 					_PATH_SYS_SYSTEM "/node/node%d/cpumap",
 					i);
 }
 
-static void
-check_system(void)
-{
-	/* Read through sysfs. */
-	if (access(_PATH_SYS_SYSTEM, F_OK))
-		errx(EXIT_FAILURE,
-		     _("error: /sys filesystem is not accessable."));
+static char *
+get_cell_data(struct lscpu_desc *desc, int cpu, int col,
+	      struct lscpu_modifier *mod,
+	      char *buf, size_t bufsz)
+{
+	size_t setsize = CPU_ALLOC_SIZE(maxcpus);
+	size_t idx;
+
+	*buf = '\0';
+
+	switch (col) {
+	case COL_CPU:
+		snprintf(buf, bufsz, "%d", cpu);
+		break;
+	case COL_CORE:
+		if (cpuset_ary_isset(cpu, desc->coremaps,
+				     desc->ncores, setsize, &idx) == 0)
+			snprintf(buf, bufsz, "%zd", idx);
+		break;
+	case COL_SOCKET:
+		if (cpuset_ary_isset(cpu, desc->socketmaps,
+				     desc->nsockets, setsize, &idx) == 0)
+			snprintf(buf, bufsz, "%zd", idx);
+		break;
+	case COL_NODE:
+		if (cpuset_ary_isset(cpu, desc->nodemaps,
+				     desc->nnodes, setsize, &idx) == 0)
+			snprintf(buf, bufsz, "%zd", idx);
+		break;
+	case COL_BOOK:
+		if (cpuset_ary_isset(cpu, desc->bookmaps,
+				     desc->nbooks, setsize, &idx) == 0)
+			snprintf(buf, bufsz, "%zd", idx);
+		break;
+	case COL_CACHE:
+	{
+		char *p = buf;
+		size_t sz = bufsz;
+		int j;
+
+		for (j = desc->ncaches - 1; j >= 0; j--) {
+			struct cpu_cache *ca = &desc->caches[j];
+
+			if (cpuset_ary_isset(cpu, ca->sharedmaps,
+					     ca->nsharedmaps, setsize, &idx) == 0) {
+				int x = snprintf(p, sz, "%zd", idx);
+				if (x <= 0 || (size_t) x + 2 >= sz)
+					return NULL;
+				p += x;
+				sz -= x;
+			}
+			if (j != 0) {
+				*p++ = mod->compat ? ',' : ':';
+				*p = '\0';
+				sz++;
+			}
+		}
+		break;
+	}
+	case COL_POLARIZATION:
+		if (desc->polarization) {
+			int x = desc->polarization[cpu];
+
+			snprintf(buf, bufsz, "%s",
+				 mod->mode == OUTPUT_PARSABLE ?
+						polar_modes[x].parsable :
+						polar_modes[x].readable);
+		}
+		break;
+	case COL_ADDRESS:
+		if (desc->addresses)
+			snprintf(buf, bufsz, "%d", desc->addresses[cpu]);
+		break;
+	case COL_CONFIGURED:
+		if (!desc->configured)
+			break;
+		if (mod->mode == OUTPUT_PARSABLE)
+			snprintf(buf, bufsz,
+				 desc->configured[cpu] ? _("Y") : _("N"));
+		else
+			snprintf(buf, bufsz,
+				 desc->configured[cpu] ? _("yes") : _("no"));
+		break;
+	case COL_ONLINE:
+		if (!desc->online)
+			break;
+		if (mod->mode == OUTPUT_PARSABLE)
+			snprintf(buf, bufsz,
+				 is_cpu_online(desc, cpu) ? _("Y") : _("N"));
+		else
+			snprintf(buf, bufsz,
+				 is_cpu_online(desc, cpu) ? _("yes") : _("no"));
+		break;
+	}
+	return buf;
+}
 
-	if (!access(_PATH_SYS_SYSTEM "/node", F_OK))
-		have_node = 1;
+static char *
+get_cell_header(struct lscpu_desc *desc, int col,
+		struct lscpu_modifier *mod,
+	        char *buf, size_t bufsz)
+{
+	*buf = '\0';
 
-	if (!access(_PATH_SYS_CPU0 "/topology/thread_siblings", F_OK))
-		have_topology = 1;
+	if (col == COL_CACHE) {
+		char *p = buf;
+		size_t sz = bufsz;
+		int i;
 
-	if (!access(_PATH_SYS_CPU0 "/cache", F_OK))
-		have_cache = 1;
+		for (i = desc->ncaches - 1; i >= 0; i--) {
+			int x = snprintf(p, sz, "%s", desc->caches[i].name);
+			if (x <= 0 || (size_t) x + 2 > sz)
+				return NULL;
+			sz -= x;
+			p += x;
+			if (i > 0) {
+				*p++ = mod->compat ? ',' : ':';
+				*p = '\0';
+				sz++;
+			}
+		}
+		if (desc->ncaches)
+			return buf;
+	}
+	snprintf(buf, bufsz, "%s", coldescs[col].name);
+	return buf;
 }
 
+/*
+ * [-p] backend, we support two parsable formats:
+ *
+ * 1) "compatible" -- this format is compatible with the original lscpu(1)
+ * output and it contains fixed set of the columns. The CACHE columns are at
+ * the end of the line and the CACHE is not printed if the number of the caches
+ * is zero. The CACHE columns are separated by two commas, for example:
+ *
+ *    $ lscpu --parse
+ *    # CPU,Core,Socket,Node,,L1d,L1i,L2
+ *    0,0,0,0,,0,0,0
+ *    1,1,0,0,,1,1,0
+ *
+ * 2) "user defined output" -- this format prints always all columns without
+ * special prefix for CACHE column. If there are not CACHEs then the column is
+ * empty and the header "Cache" is printed rather than a real name of the cache.
+ * The CACHE columns are separated by ':'.
+ *
+ *	$ lscpu --parse=CPU,CORE,SOCKET,NODE,CACHE
+ *	# CPU,Core,Socket,Node,L1d:L1i:L2
+ *	0,0,0,0,0:0:0
+ *	1,1,0,0,1:1:0
+ */
 static void
-print_parsable(struct cpu_desc *cpu)
+print_parsable(struct lscpu_desc *desc, int cols[], int ncols,
+	       struct lscpu_modifier *mod)
 {
-	int i, j;
+	char buf[BUFSIZ], *data;
+	int i;
 
+	/*
+	 * Header
+	 */
 	printf(_(
 	"# The following is the parsable format, which can be fed to other\n"
 	"# programs. Each different item in every column has an unique ID\n"
-	"# starting from zero.\n"
-	"# CPU,Core,Socket,Node"));
+	"# starting from zero.\n"));
+
+	fputs("# ", stdout);
+	for (i = 0; i < ncols; i++) {
+		int col = cols[i];
+
+		if (col == COL_CACHE) {
+			if (mod->compat && !desc->ncaches)
+				continue;
+			if (mod->compat && i != 0)
+				putchar(',');
+		}
+		if (i > 0)
+			putchar(',');
 
-	if (have_cache) {
-		/* separator between CPU topology and cache information */
-		putchar(',');
+		data = get_cell_header(desc, col, mod, buf, sizeof(buf));
 
-		for (i = cpu->ct_cache - 1; i >= 0; i--)
-			printf(",%s", cpu->cache[i].caname);
+		if (data && * data && col != COL_CACHE &&
+		    !coldescs[col].is_abbr) {
+			/*
+			 * For normal column names use mixed case (e.g. "Socket")
+			 */
+			char *p = data + 1;
+
+			while (p && *p != '\0') {
+				*p = tolower((unsigned int) *p);
+				p++;
+			}
+		}
+		fputs(data && *data ? data : "", stdout);
 	}
 	putchar('\n');
 
-	for (i = 0; i < cpu->ct_cpu; i++) {
-		printf("%d", i);
+	/*
+	 * Data
+	 */
+	for (i = 0; i < desc->ncpus; i++) {
+		int c;
 
-		if (have_topology)
-			printf(",%d,%d",
-				i / cpu->ct_thread,
-			        i / cpu->ct_core / cpu->ct_thread);
-		else
-			printf(",,");
+		if (!mod->offline && desc->online && !is_cpu_online(desc, i))
+			continue;
+		if (!mod->online && desc->online && is_cpu_online(desc, i))
+			continue;
+		for (c = 0; c < ncols; c++) {
+			if (mod->compat && cols[c] == COL_CACHE) {
+				if (!desc->ncaches)
+					continue;
+				if (c > 0)
+					putchar(',');
+			}
+			if (c > 0)
+				putchar(',');
 
-		if (have_node) {
-			int c = 0;
+			data = get_cell_data(desc, i, cols[c], mod,
+					     buf, sizeof(buf));
+			fputs(data && *data ? data : "", stdout);
+		}
+		putchar('\n');
+	}
+}
 
-			for (j = 0; j < cpu->ct_node; j++) {
-				c += cpu->nodecpu[j];
-				if (i < c) {
-					printf(",%d", j);
-					break;
-				}
-			}
-		} else
-			putchar(',');
+/*
+ * [-e] backend
+ */
+static void
+print_readable(struct lscpu_desc *desc, int cols[], int ncols,
+	       struct lscpu_modifier *mod)
+{
+	int i;
+	char buf[BUFSIZ], *data;
+	struct tt *tt = tt_new_table(0);
 
-		if (have_cache) {
-			putchar(',');
+	if (!tt)
+		 err(EXIT_FAILURE, _("failed to initialize output table"));
 
-			for (j = cpu->ct_cache - 1; j >= 0; j--) {
-				/* If shared_cpu_map is 0, all CPUs share the same
-				   cache. */
-				if (cpu->cache[j].camap == 0)
-					cpu->cache[j].camap = cpu->ct_core *
-							      cpu->ct_thread;
+	for (i = 0; i < ncols; i++) {
+		data = get_cell_header(desc, cols[i], mod, buf, sizeof(buf));
+		tt_define_column(tt, xstrdup(data), 0, 0);
+	}
 
-				printf(",%d", i / cpu->cache[j].camap);
-			}
+	for (i = 0; i < desc->ncpus; i++) {
+		int c;
+		struct tt_line *line;
+
+		if (!mod->offline && desc->online && !is_cpu_online(desc, i))
+			continue;
+		if (!mod->online && desc->online && is_cpu_online(desc, i))
+			continue;
+
+		line = tt_add_line(tt, NULL);
+
+		for (c = 0; c < ncols; c++) {
+			data = get_cell_data(desc, i, cols[c], mod,
+					     buf, sizeof(buf));
+			tt_line_set_data(line, c, data && *data ? xstrdup(data) : "-");
 		}
-		putchar('\n');
 	}
-}
 
+	tt_print_table(tt);
+}
 
 /* output formats "<key>  <value>"*/
 #define print_s(_key, _val)	printf("%-23s%s\n", _key, _val)
 #define print_n(_key, _val)	printf("%-23s%d\n", _key, _val)
 
 static void
-print_readable(struct cpu_desc *cpu)
+print_cpuset(const char *key, cpu_set_t *set, int hex)
 {
-	print_s("Architecture:", cpu->arch);
+	size_t setsize = CPU_ALLOC_SIZE(maxcpus);
+	size_t setbuflen = 7 * maxcpus;
+	char setbuf[setbuflen], *p;
+
+	if (hex) {
+		p = cpumask_create(setbuf, setbuflen, set, setsize);
+		printf("%-23s0x%s\n", key, p);
+	} else {
+		p = cpulist_create(setbuf, setbuflen, set, setsize);
+		print_s(key, p);
+	}
 
-	if (cpu->mode & (MODE_REAL | MODE_TRANSPARENT | MODE_LONG)) {
-		char buf[64], *p = buf;
+}
 
-		if (cpu->mode & MODE_REAL) {
-			strcpy(p, "16-bit, ");
-			p += 8;
-		}
-		if (cpu->mode & MODE_TRANSPARENT) {
+/*
+ * default output
+ */
+static void
+print_summary(struct lscpu_desc *desc, struct lscpu_modifier *mod)
+{
+	char buf[512];
+	int i;
+	size_t setsize = CPU_ALLOC_SIZE(maxcpus);
+
+	print_s(_("Architecture:"), desc->arch);
+
+	if (desc->mode) {
+		char mbuf[64], *p = mbuf;
+
+		if (desc->mode & MODE_32BIT) {
 			strcpy(p, "32-bit, ");
 			p += 8;
 		}
-		if (cpu->mode & MODE_LONG) {
+		if (desc->mode & MODE_64BIT) {
 			strcpy(p, "64-bit, ");
 			p += 8;
 		}
 		*(p - 2) = '\0';
-		print_s(_("CPU op-mode(s):"), buf);
+		print_s(_("CPU op-mode(s):"), mbuf);
+	}
+#if !defined(WORDS_BIGENDIAN)
+	print_s(_("Byte Order:"), "Little Endian");
+#else
+	print_s(_("Byte Order:"), "Big Endian");
+#endif
+	print_n(_("CPU(s):"), desc->ncpus);
+
+	if (desc->online)
+		print_cpuset(mod->hex ? _("On-line CPU(s) mask:") :
+					_("On-line CPU(s) list:"),
+				desc->online, mod->hex);
+
+	if (desc->online && CPU_COUNT_S(setsize, desc->online) != desc->ncpus) {
+		cpu_set_t *set;
+
+		/* Linux kernel provides cpuset of off-line CPUs that contains
+		 * all configured CPUs (see /sys/devices/system/cpu/offline),
+		 * but want to print real (present in system) off-line CPUs only.
+		 */
+		set = cpuset_alloc(maxcpus, NULL, NULL);
+		if (!set)
+			err(EXIT_FAILURE, _("failed to callocate cpu set"));
+		CPU_ZERO_S(setsize, set);
+		for (i = 0; i < desc->ncpus; i++) {
+			if (!is_cpu_online(desc, i))
+				CPU_SET_S(i, setsize, set);
+		}
+		print_cpuset(mod->hex ? _("Off-line CPU(s) mask:") :
+					_("Off-line CPU(s) list:"),
+			     set, mod->hex);
+		cpuset_free(set);
 	}
 
-	print_n("CPU(s):", cpu->ct_cpu);
+	if (desc->nsockets) {
+		int cores_per_socket, sockets_per_book, books;
 
-	if (have_topology) {
-		print_n(_("Thread(s) per core:"), cpu->ct_thread);
-		print_n(_("Core(s) per socket:"), cpu->ct_core);
-		print_n(_("CPU socket(s):"), cpu->ct_socket);
-	}
-
-	if (have_node)
-		print_n(_("NUMA node(s):"), cpu->ct_node);
-	if (cpu->vendor)
-		print_s(_("Vendor ID:"), cpu->vendor);
-	if (cpu->family)
-		print_s(_("CPU family:"), cpu->family);
-	if (cpu->model)
-		print_s(_("Model:"), cpu->model);
-	if (cpu->stepping)
-		print_s(_("Stepping:"), cpu->stepping);
-	if (cpu->mhz)
-		print_s(_("CPU MHz:"), cpu->mhz);
-	if (cpu->virtflag) {
-		if (!strcmp(cpu->virtflag, "svm"))
+		cores_per_socket = sockets_per_book = books = 0;
+		/* s390 detects its cpu topology via /proc/sysinfo, if present.
+		 * Using simply the cpu topology masks in sysfs will not give
+		 * usable results since everything is virtualized. E.g.
+		 * virtual core 0 may have only 1 cpu, but virtual core 2 may
+		 * five cpus.
+		 * If the cpu topology is not exported (e.g. 2nd level guest)
+		 * fall back to old calculation scheme.
+		 */
+		if (path_exist(_PATH_PROC_SYSINFO)) {
+			FILE *fd = path_fopen("r", 0, _PATH_PROC_SYSINFO);
+			char pbuf[BUFSIZ];
+			int t0, t1, t2;
+
+			while (fd && fgets(pbuf, sizeof(pbuf), fd) != NULL) {
+				if (sscanf(pbuf, "CPU Topology SW:%d%d%d%d%d%d",
+					   &t0, &t1, &t2, &books, &sockets_per_book,
+					   &cores_per_socket) == 6)
+					break;
+			}
+			if (fd)
+				fclose(fd);
+		}
+		print_n(_("Thread(s) per core:"), desc->nthreads / desc->ncores);
+		print_n(_("Core(s) per socket:"),
+			cores_per_socket ?: desc->ncores / desc->nsockets);
+		if (desc->nbooks) {
+			print_n(_("Socket(s) per book:"),
+				sockets_per_book ?: desc->nsockets / desc->nbooks);
+			print_n(_("Book(s):"), books ?: desc->nbooks);
+		} else {
+			print_n(_("Socket(s):"), sockets_per_book ?: desc->nsockets);
+		}
+	}
+	if (desc->nnodes)
+		print_n(_("NUMA node(s):"), desc->nnodes);
+	if (desc->vendor)
+		print_s(_("Vendor ID:"), desc->vendor);
+	if (desc->family)
+		print_s(_("CPU family:"), desc->family);
+	if (desc->model)
+		print_s(_("Model:"), desc->model);
+	if (desc->stepping)
+		print_s(_("Stepping:"), desc->stepping);
+	if (desc->mhz)
+		print_s(_("CPU MHz:"), desc->mhz);
+	if (desc->bogomips)
+		print_s(_("BogoMIPS:"), desc->bogomips);
+	if (desc->virtflag) {
+		if (!strcmp(desc->virtflag, "svm"))
 			print_s(_("Virtualization:"), "AMD-V");
-		else if (!strcmp(cpu->virtflag, "vmx"))
+		else if (!strcmp(desc->virtflag, "vmx"))
 			print_s(_("Virtualization:"), "VT-x");
 	}
-	if (cpu->hyper) {
-		print_s(_("Hypervisor vendor:"), hv_vendors[cpu->hyper]);
-		print_s(_("Virtualization type:"), virt_types[cpu->virtype]);
+	if (desc->hypervisor)
+		print_s(_("Hypervisor:"), desc->hypervisor);
+	if (desc->hyper) {
+		print_s(_("Hypervisor vendor:"), hv_vendors[desc->hyper]);
+		print_s(_("Virtualization type:"), _(virt_types[desc->virtype]));
 	}
-	if (have_cache) {
-		char buf[512];
-		int i;
-
-		for (i = cpu->ct_cache - 1; i >= 0; i--) {
-			snprintf(buf, sizeof(buf),
-					_("%s cache:"), cpu->cache[i].caname);
-			print_s(buf, cpu->cache[i].casize);
+	if (desc->dispatching >= 0)
+		print_s(_("Dispatching mode:"), _(disp_modes[desc->dispatching]));
+	if (desc->ncaches) {
+		char cbuf[512];
+
+		for (i = desc->ncaches - 1; i >= 0; i--) {
+			snprintf(cbuf, sizeof(cbuf),
+					_("%s cache:"), desc->caches[i].name);
+			print_s(cbuf, desc->caches[i].size);
 		}
 	}
+
+	for (i = 0; i < desc->nnodes; i++) {
+		snprintf(buf, sizeof(buf), _("NUMA node%d CPU(s):"), i);
+		print_cpuset(buf, desc->nodemaps[i], mod->hex);
+	}
 }
 
-void usage(int rc)
+static void __attribute__((__noreturn__)) usage(FILE *out)
 {
-	printf(_("Usage: %s [option]\n"),
-			program_invocation_short_name);
+	size_t i;
 
-	puts(_(	"CPU architecture information helper\n\n"
-		"  -h, --help     usage information\n"
-		"  -p, --parse    print out in parsable instead of printable format.\n"
-		"  -s, --sysroot  use the directory as a new system root.\n"));
-	exit(rc);
-}
+	fputs(USAGE_HEADER, out);
+	fprintf(out,
+	      _(" %s [options]\n"), program_invocation_short_name);
 
-static int
-ca_compare(const void *a, const void *b)
-{
-	struct ca_desc *cache1 = (struct ca_desc *) a;
-	struct ca_desc *cache2 = (struct ca_desc *) b;
+	fputs(USAGE_OPTIONS, out);
+	fputs(_(" -a, --all               print online and offline CPUs (default for -e)\n"
+		" -b, --online            print online CPUs only (default for -p)\n"
+		" -c, --offline           print offline CPUs only\n"
+		" -e, --extended[=<list>] print out an extended readable format\n"
+		" -h, --help              print this help\n"
+		" -p, --parse[=<list>]    print out a parsable format\n"
+		" -s, --sysroot <dir>     use directory DIR as system root\n"
+		" -V, --version           print version information and exit\n"
+		" -x, --hex               print hexadecimal masks rather than lists of CPUs\n"), out);
 
-	return strcmp(cache2->caname, cache1->caname);
+	fprintf(out, _("\nAvailable columns:\n"));
+
+	for (i = 0; i < ARRAY_SIZE(coldescs); i++)
+		fprintf(out, " %13s  %s\n", coldescs[i].name, _(coldescs[i].help));
+
+	fprintf(out, _("\nFor more details see lscpu(1).\n"));
+
+	exit(out == stderr ? EXIT_FAILURE : EXIT_SUCCESS);
 }
 
 int main(int argc, char *argv[])
 {
-	struct cpu_desc _cpu, *cpu = &_cpu;
-	int parsable = 0, c;
-
-	struct option longopts[] = {
+	struct lscpu_modifier _mod = { .mode = OUTPUT_SUMMARY }, *mod = &_mod;
+	struct lscpu_desc _desc = { .flags = 0 }, *desc = &_desc;
+	int c, i;
+	int columns[ARRAY_SIZE(coldescs)], ncolumns = 0;
+	int cpu_modifier_specified = 0;
+
+	static const struct option longopts[] = {
+		{ "all",        no_argument,       0, 'a' },
+		{ "online",     no_argument,       0, 'b' },
+		{ "offline",    no_argument,       0, 'c' },
 		{ "help",	no_argument,       0, 'h' },
-		{ "parse",	no_argument,       0, 'p' },
+		{ "extended",	optional_argument, 0, 'e' },
+		{ "parse",	optional_argument, 0, 'p' },
 		{ "sysroot",	required_argument, 0, 's' },
+		{ "hex",	no_argument,	   0, 'x' },
+		{ "version",	no_argument,	   0, 'V' },
 		{ NULL,		0, 0, 0 }
 	};
 
-	setlocale(LC_MESSAGES, "");
+	static const ul_excl_t excl[] = {	/* rows and cols in ASCII order */
+		{ 'a','b','c' },
+		{ 'e','p' },
+		{ 0 }
+	};
+	int excl_st[ARRAY_SIZE(excl)] = UL_EXCL_STATUS_INIT;
+
+	setlocale(LC_ALL, "");
 	bindtextdomain(PACKAGE, LOCALEDIR);
 	textdomain(PACKAGE);
 
-	while((c = getopt_long(argc, argv, "hps:", longopts, NULL)) != -1) {
+	while ((c = getopt_long(argc, argv, "abce::hp::s:xV", longopts, NULL)) != -1) {
+
+		err_exclusive_options(c, longopts, excl, excl_st);
+
 		switch (c) {
+		case 'a':
+			mod->online = mod->offline = 1;
+			cpu_modifier_specified = 1;
+			break;
+		case 'b':
+			mod->online = 1;
+			cpu_modifier_specified = 1;
+			break;
+		case 'c':
+			mod->offline = 1;
+			cpu_modifier_specified = 1;
+			break;
 		case 'h':
-			usage(EXIT_SUCCESS);
+			usage(stdout);
 		case 'p':
-			parsable = 1;
+			goto hop_over;
+		case 'e':
+			hop_over:
+			if (optarg) {
+				if (*optarg == '=')
+					optarg++;
+				ncolumns = string_to_idarray(optarg,
+						columns, ARRAY_SIZE(columns),
+						column_name_to_id);
+				if (ncolumns < 0)
+					return EXIT_FAILURE;
+			}
+			mod->mode = c == 'p' ? OUTPUT_PARSABLE : OUTPUT_READABLE;
 			break;
 		case 's':
-			strncpy(pathbuf, optarg, sizeof(pathbuf));
+			path_setprefix(optarg);
+			mod->system = SYSTEM_SNAPSHOT;
+			break;
+		case 'x':
+			mod->hex = 1;
 			break;
+		case 'V':
+			printf(_("%s from %s\n"), program_invocation_short_name,
+			       PACKAGE_STRING);
+			return EXIT_SUCCESS;
 		default:
-			usage(EXIT_FAILURE);
+			usage(stderr);
 		}
 	}
 
-	if (chdir(pathbuf) == -1)
-		errx(EXIT_FAILURE,
-		     _("error: change working directory to %s."), pathbuf);
+	if (cpu_modifier_specified && mod->mode == OUTPUT_SUMMARY) {
+		fprintf(stderr,
+			_("%s: options --all, --online and --offline may only "
+			  "be used with options --extended or --parsable.\n"),
+			program_invocation_short_name);
+		return EXIT_FAILURE;
+	}
 
-	memset(cpu, 0, sizeof(*cpu));
+	if (argc != optind)
+		usage(stderr);
 
-	check_system();
+	/* set default cpu display mode if none was specified */
+	if (!mod->online && !mod->offline) {
+		mod->online = 1;
+		mod->offline = mod->mode == OUTPUT_READABLE ? 1 : 0;
+	}
 
-	read_basicinfo(cpu);
+	read_basicinfo(desc, mod);
 
-	if (have_topology)
-		read_topology(cpu);
-	if (have_cache) {
-		read_cache(cpu);
-		qsort(cpu->cache, cpu->ct_cache, sizeof(struct ca_desc), ca_compare);
+	for (i = 0; i < desc->ncpus; i++) {
+		read_topology(desc, i);
+		read_cache(desc, i);
+		read_polarization(desc, i);
+		read_address(desc, i);
+		read_configured(desc, i);
 	}
-	if (have_node)
-		read_nodes(cpu);
 
-	read_hypervisor(cpu);
-
-	/* Show time! */
-	if (parsable)
-		print_parsable(cpu);
-	else
-		print_readable(cpu);
+	if (desc->caches)
+		qsort(desc->caches, desc->ncaches,
+				sizeof(struct cpu_cache), cachecmp);
+
+	read_nodes(desc);
+	read_hypervisor(desc);
+
+	switch(mod->mode) {
+	case OUTPUT_SUMMARY:
+		print_summary(desc, mod);
+		break;
+	case OUTPUT_PARSABLE:
+		if (!ncolumns) {
+			columns[ncolumns++] = COL_CPU;
+			columns[ncolumns++] = COL_CORE;
+			columns[ncolumns++] = COL_SOCKET;
+			columns[ncolumns++] = COL_NODE;
+			columns[ncolumns++] = COL_CACHE;
+			mod->compat = 1;
+		}
+		print_parsable(desc, columns, ncolumns, mod);
+		break;
+	case OUTPUT_READABLE:
+		if (!ncolumns) {
+			/* No list was given. Just print whatever is there. */
+			columns[ncolumns++] = COL_CPU;
+			if (desc->nodemaps)
+				columns[ncolumns++] = COL_NODE;
+			if (desc->bookmaps)
+				columns[ncolumns++] = COL_BOOK;
+			if (desc->socketmaps)
+				columns[ncolumns++] = COL_SOCKET;
+			if (desc->coremaps)
+				columns[ncolumns++] = COL_CORE;
+			if (desc->caches)
+				columns[ncolumns++] = COL_CACHE;
+			if (desc->online)
+				columns[ncolumns++] = COL_ONLINE;
+			if (desc->configured)
+				columns[ncolumns++] = COL_CONFIGURED;
+			if (desc->polarization)
+				columns[ncolumns++] = COL_POLARIZATION;
+			if (desc->addresses)
+				columns[ncolumns++] = COL_ADDRESS;
+		}
+		print_readable(desc, columns, ncolumns, mod);
+		break;
+	}
 
 	return EXIT_SUCCESS;
 }
diff -up util-linux-ng-2.17.2/sys-utils/Makefile.am.lscpu util-linux-ng-2.17.2/sys-utils/Makefile.am
--- util-linux-ng-2.17.2/sys-utils/Makefile.am.lscpu	2010-03-18 23:11:23.000000000 +0100
+++ util-linux-ng-2.17.2/sys-utils/Makefile.am	2012-10-05 17:41:26.613773139 +0200
@@ -18,6 +18,13 @@ dist_man_MANS += dmesg.1 ctrlaltdel.8 cy
 		ldattach.8 lscpu.1 tunelp.8 rtcwake.8
 endif
 
+lscpu_SOURCES = lscpu.c \
+	$(top_srcdir)/lib/cpuset.c \
+	$(top_srcdir)/lib/strutils.c \
+	$(top_srcdir)/lib/path.c \
+	$(top_srcdir)/lib/tt.c \
+	$(top_srcdir)/lib/mbsalign.c
+
 cytune_SOURCES = cytune.c cyclades.h
 tunelp_SOURCES = tunelp.c lp.h
 
